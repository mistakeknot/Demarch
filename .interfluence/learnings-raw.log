
--- 2026-02-21T01:58:06Z | docs/brainstorms/2026-02-20-plugin-synergy-catalog-brainstorm.md | CONTEXT:unknown ---
OLD: # Plugin Synergy Catalog: Low-Hanging Interop Opportunities
NEW: # Plugin Synergy Catalog: Low-Hanging Interop Opportunities
**Bead:** iv-vlg4

--- 2026-02-21T02:00:08Z | docs/brainstorms/2026-02-20-interchart-ecosystem-diagram-brainstorm.md | CONTEXT:unknown ---
OLD: # Interchart: Interactive Ecosystem Diagram Plugin
NEW: # Interchart: Interactive Ecosystem Diagram Plugin
**Bead:** iv-fgde

--- 2026-02-21T02:18:02Z | docs/research/architecture-review-of-plan.md | CONTEXT:unknown ---
OLD: # Architecture Review: Dual-Mode Plugin Architecture Implementation Plan

**Reviewer:** Flux-drive Architecture & Design Reviewer
**Date:** 2026-02-20
**Plan:** `/root/projects/Interverse/docs/plans/2026-02-20-dual-mode-plugin-architecture.md`
NEW: # Architecture Review: Plugin Synergy Interop Implementation Plan
**Plan file:** `docs/plans/2026-02-20-plugin-synergy-interop.md`
**Review date:** 2026-02-20
**Reviewer:** Flux-drive Architecture & Design Reviewer

---

## Executive Summary

The plan is coherent at the protocol level and its interband-as-coordination-layer choice is sound. Most tasks are well-scoped. However there are five structural issues that will be expensive to fix after implementation starts: a signal-schema mismatch between Task 2 and every consumer; a hidden mutation race in the interband.sh upgrade sequence; Task 6's batch shape creating unnecessary rollback granularity; an unresolvable dedup strategy in Task 9; and Task 10 introducing a direct inter-plugin call path that bypasses the interband contract. Task 7 is the only item where the "static vs generated" question is genuine but low-priority.

---

## 1. Boundaries and Coupling

### 1.1 interband.sh is a shared mutable file touched by four separate tasks — must-fix sequencing risk

Tasks 1, 2, and 10 each modify `infra/interband/lib/interband.sh` in separate commits across separate git repositories. The plan commits each interband change immediately after the plugin change that requires it (Tasks 1 and 2 each end with two commits, Task 10 adds a third interband commit). Because interband is its own git repo with its own version line, this means:

- Three separate commits land in `infra/interband` across the lifetime of the plan.
- Each task's implementer reads a stale version of interband.sh if Tasks 1 and 2 are done in different sessions without a pull.
- The case blocks in `interband_validate_payload()`, `interband_default_retention_secs()`, and `interband_default_max_files()` are modified three times at the same logical location in the file.

The plan does not specify that the interband repo must be pulled before starting each subsequent task that modifies it, nor does it prescribe a single consolidated interband commit. This is a merge-conflict waiting to happen, but the deeper issue is testability: the contract between publisher and consumer is split across three commits, making it impossible to verify the full schema in one test run.

**Minimum fix:** Consolidate all three interband.sh additions into a single Task 1 step. Register all three `namespace:channel` pairs (`intercheck:pressure`, `intercheck:checkpoint`, `interstat:budget`) and their retention/max-files defaults in one commit. Tasks 2 and 10 then only touch plugin files. This eliminates the interband coordination risk entirely.

### 1.2 Task 10 creates a direct inter-plugin call path — boundary violation

Task 10 adds interband signal emission inside the `orange` case of `context-monitor.sh`. The code checks `[[ -n "${_ic_interband_lib:-}" ]]` — this variable is set only if the Task 1 interband sourcing block already ran in the same process. That sourcing block lives in the interband write path added by Task 1, meaning Task 10 implicitly depends on Task 1's code to have already executed in the same bash process.

More seriously, Task 10 also emits `intercheck:checkpoint_needed` and includes this message in the hook output:

```
Consider running /intermem:synthesize to preserve learnings.
```

This is a direct plugin-to-plugin coupling by name: intercheck's hook output now contains a command string specific to intermem's public interface. If intermem renames its skill, intercheck breaks silently (the message becomes stale but the code never fails). The interband protocol was designed explicitly to avoid this — publishers write signals, consumers act on them. The correct pattern is for intermem to consume `intercheck:checkpoint_needed` on session-start or via its own hook, not for intercheck to hardcode intermem's skill name in its output.

**Minimum fix:** Remove the hardcoded `/intermem:synthesize` string from the intercheck output message. Replace it with a generic message such as "Consider synthesizing session memory before continuing." The checkpoint signal over interband is already sufficient for any consumer to act.

### 1.3 Task 8 replaces interflux session-start contents entirely — regression risk

The plan says "Replace the contents of `plugins/interflux/hooks/session-start.sh`". The current file contains two substantive lines: `source "$HOOK_DIR/interbase-stub.sh"` and `ib_session_status`. The plan's replacement preserves both lines and adds budget-reading logic, which is correct. However "replace the contents" as an instruction to an implementer is dangerous — it will cause the existing interbase adoption to appear absent in a code review, making it harder to verify the Task 4/8 dependency.

**Minimum fix:** Rephrase Task 8 Step 1 as "Append the following block after line 9" rather than "Replace the contents." Diff-based verification becomes trivial.

---

## 2. Signal Schema Analysis

### 2.1 Task 2 channel name vs. type name diverges from Task 1 — not a bug, but creates confusion

In Task 2, `interband_validate_payload()` registers the type as `interstat:budget_alert`, but the retention and max-files cases use `interstat:budget`. The path generation calls `interband_path "interstat" "budget" "$session_id"`, producing `~/.interband/interstat/budget/<session_id>.json`. Task 3 (interline) and Task 8 (interflux) both read from this path — consistent.

The interband library correctly uses `namespace:channel` as the key for retention/max-files and `namespace:type` as the key for payload validation. These are different concepts and the code handles them correctly. However the channel (`budget`) and type (`budget_alert`) diverge in name, while Task 1 keeps them parallel (`pressure` channel, `context_pressure` type, consistent with the interphase pattern `bead` channel, `bead_phase` type).

**Recommendation:** Rename the Task 2 channel to `budget_alert` for stylistic consistency with Task 1, or document the channel-vs-type naming convention in the interband AGENTS.md. Without documentation, the next developer adding a signal will make an arbitrary choice and the inconsistency compounds.

### 2.2 Task 2: budget_alert emission fires on every hook call above 50% — unbounded writes

The emission logic in Task 2 has no threshold-crossing gate:

```bash
if [[ "$_is_pct_int" -ge 50 ]]; then
    # emit unconditionally
fi
```

The comment says "Only emit at threshold crossings: 50%, 80%, 95%" but the code does not implement threshold crossings. It emits on every PostToolUse:Task call once percentage exceeds 50. Since each agent dispatch triggers the hook, a session that has consumed 60% of its budget will emit a new interband file on every single Task tool call for the rest of the session.

The atomic-write design means each write is individually safe, but the write frequency is unnecessary: the signal changes slowly (percentage changes by single digits per dispatch) but the file is overwritten on every dispatch above the threshold.

**Minimum fix:** Track last-emitted percentage bucket in a session-scoped file (e.g., `/tmp/interstat-budget-last-${session_id}`) and only write when the integer bucket (50, 80, 95) changes. This implements the stated intent and reduces writes by an order of magnitude.

### 2.3 Task 1 pressure level thresholds duplicate context-monitor.sh logic

The threshold computation in Task 1's interband write block recomputes `_ic_pressure_level` from `$PRESSURE` and `$EST_TOKENS` using the same awk/integer comparisons as lines 67-73 of the existing `context-monitor.sh`. The existing file already computes `LEVEL` (green/yellow/orange/red) at line 67, but the interband write is inserted before the `case "$LEVEL"` block — before `$LEVEL` is available — requiring the duplication.

This creates a divergence risk: if the thresholds are ever adjusted, there are two places to update. The existing file has the authoritative thresholds; the interband block has a copy.

**Minimum fix:** Restructure so `$LEVEL` is computed before `_ic_write_state`, then use `$LEVEL` directly in the interband write block. Alternatively, move the interband write inside the existing `case "$LEVEL"` block, where the level is already known. Either approach eliminates the threshold duplication.

---

## 3. Task 6: Batch Shape

### 3.1 Four-plugin batch is too coarse — wrong rollback granularity

Task 6 batches intermem, intertest, internext, and tool-time into one task with a shared for-loop commit. The plan's own `integration.json` contents confirm these four plugins have different companions, different standalone features, and different nudge logic. The rationale for batching appears to be "the steps are identical," but identical steps with different payloads are exactly what per-task commits are for.

The concrete failure mode: if the for-loop commit step fails for one plugin (e.g., intertest already has a session-start.sh), the loop continues silently (the `|| echo "$p: FAIL"` only echoes, does not abort). An implementer following this plan may produce a partial commit covering only 2 of 4 plugins, making task state ambiguous.

The plan also says "Check if each plugin already has a `hooks/hooks.json`. If so, merge the SessionStart entry." This conditional logic buried in a bulk step is the most likely source of execution errors: the implementer must make per-plugin decisions mid-loop.

The architectural risk is not coupling between the four plugins — they remain independent. The risk is that a single task unit with four distinct failure modes makes rollback impossible at per-plugin granularity, and makes progress-tracking via beads or IC runs inaccurate.

**Minimum fix:** Split Task 6 into four tasks (6a–6d). Each is: copy stub, create integration.json, create session-start.sh, check and create/merge hooks.json, commit. Four small tasks with clear per-plugin scope.

**Note:** `intermem` does not have a standard plugin structure at `/root/projects/Interverse/plugins/intermem/` — only docs, brainstorms, and a `.venv` directory are present. Task 6 must verify intermem plugin structure before attempting SDK adoption. This is the highest-risk of the four plugins in this batch.

---

## 4. Task 7: companion-graph.json Static vs. Generated

### 4.1 Static graph is appropriate now, but needs a consistency gate

The plan creates `companion-graph.json` as a hand-authored static file. The concern is whether it stays synchronized with the `integration.json` files added by Tasks 4–6. A generated approach would ensure consistency but requires a build step.

Static is correct for the current state: 12 edges covering a small, known graph that changes infrequently. The real risk is silent divergence: the plan's validation script (Step 2) only checks that plugin names exist as directories — it does not cross-validate edges against `integration.json` companions declarations.

**Minimum fix:** Extend the Step 2 validation script to read each plugin's `integration.json` and assert that every declared companion relationship appears in `companion-graph.json`. This is a trivial addition to the existing python3 validation block. Without it, the graph will begin diverging within the first post-plan plugin addition.

On the static vs. generated question: keep it static until the graph exceeds ~30 edges or a CI gate requires it. The current state does not justify the tooling investment.

---

## 5. Task 9: Verdict-to-Bead Deduplication

### 5.1 String-match dedup is not robust — produces both false positives and false negatives

The dedup check in `verdict_auto_create_beads()`:

```bash
existing=$(bd list --json --quiet 2>/dev/null | jq -r ".[].title" 2>/dev/null | grep -Fc "${summary:0:30}" || echo "0")
[[ "$existing" -eq 0 ]] || continue
```

**False positives (suppression):** A verdict summary starting with "No issues found in authentication" will match any existing bead whose title contains the same 30-character prefix — including unrelated beads from different reviews. The first 30 characters of natural-language summaries are rarely unique identifiers. Common review phrasing ("Missing validation on", "Performance issue in") will suppress legitimate new beads.

**False negatives (duplicates):** Two verdict summaries for the same underlying finding phrased differently (e.g., "Missing input validation on user endpoint" vs. "User endpoint lacks input validation") produce zero match and both become beads. Since `verdict_auto_create_beads` iterates all verdict files on every call and verdict files are only cleaned at sprint start, repeated calls create duplicate beads for the same verdict.

The deeper problem is that summary text is not a stable identifier. Verdict files have no stable ID field; their stable identity is the agent name (the filename without `.json`).

**Minimum fix:** Use the agent name as the dedup key. Maintain a session-scoped map file (e.g., `/tmp/intersynth-bead-map-${CLAUDE_SESSION_ID}.json`) keyed on agent name, recording which bead ID was created for each verdict. Before creating a bead, check this map. After creating, record the new ID. This is session-accurate, O(1) per check, and requires no `bd list` call. At sprint start the map is implicitly reset because `CLAUDE_SESSION_ID` changes.

If cross-session dedup is needed (to prevent re-creating a bead already in the backlog from a previous session), record the agent-name-to-bead-id mapping in a persistent file and check `bd show <id>` to verify the bead still exists before skipping creation.

---

## 6. Pattern Consistency and YAGNI

### 6.1 SessionStart hooks for plugins with no active integrated features — premature

Tasks 4, 5, and 6 add SessionStart hooks that call `ib_session_status` and optionally `ib_nudge_companion`. For plugins like intertest, internext, and tool-time, the hook has no functional effect beyond emitting ecosystem status to stderr. The `integration.json` files for these three plugins list `integrated_features` that do not exist in this plan — they are aspirational.

This adds four new hooks firing on every SessionStart across the ecosystem (each sources interbase-stub.sh, does `command -v` checks, runs `ib_session_status`, optionally runs `ib_nudge_companion` with its glob + file reads) for features that have not been built.

Tasks 4 (interline) and 5 (intersynth) justify SessionStart hooks: interline's layers actively read interband signals from Tasks 1–2; intersynth's Task 9 bridges verdicts to beads. Those two plugins have concrete integrated features shipping in this same plan.

**Recommendation:** For intertest, internext, and tool-time in Task 6: create `integration.json` files only (documentation artifacts). Do not create session-start.sh or hooks.json. Add those hooks when a concrete integrated feature exists in the same plan that uses them.

### 6.2 interbase nudge plugin name is not validated against companion-graph.json

The interbase stub's `ib_nudge_companion()` checks whether the companion is installed via `compgen -G "${HOME}/.claude/plugins/cache/*/${name}/*"`. This is correct. However the companion names passed in session-start hooks are bare plugin names (`"intercheck"`, `"interflux"`, `"interwatch"`) that must match the installed plugin directory name. If any of these plugins are installed under a different directory name (e.g., via a path alias), the nudge fires incorrectly. This is a pre-existing interbase behavior, not introduced by this plan, but the plan amplifies it by adding six new nudge registrations across four tasks.

This is low-priority given the nudge is session-capped and dismissible.

### 6.3 Task 10 intermem-dir check is unreliable

The rate-limit gate in Task 10 checks `[[ -d "$(pwd)/.intermem" ]]`. The current working directory of `context-monitor.sh` is not guaranteed to be the project root across all invocations — it depends on how Claude Code sets CWD for PostToolUse hooks. If CWD is the session working directory rather than the project root, the `.intermem` check will always be false, and the interband checkpoint signal will never emit.

**Minimum fix:** Remove the `.intermem` directory existence check. The checkpoint signal should fire based on pressure threshold alone. Consumers (intermem) decide whether to act based on their own state — this is the correct interband pattern.

---

## 7. Dependency Ordering

The plan's task sequence is correct for the critical path:

```
Task 1 (intercheck publishes) → Task 3 (interline consumes intercheck)
Task 2 (interstat publishes) → Task 3 (interline consumes interstat)
Task 2 (interstat publishes) → Task 8 (interflux consumes interstat)
Task 1/2 (interband.sh updated) → Task 10 (intercheck:checkpoint_needed)
Task 5 (intersynth adopts interbase) → Task 9 (verdict-to-bead bridge)
```

One implicit dependency the plan does not state: Task 4 (interline interbase adoption) creates `hooks/hooks.json`. If interline gains any non-SessionStart hook between plan authoring and Task 4 execution, the plan's create-from-scratch instruction would overwrite it. The plan should include an explicit "check if hooks/hooks.json exists" guard, as Task 5 correctly does but Task 4 does not.

---

## Summary Table

### Must-Fix Before Implementation Starts

| ID | Task | Issue |
|----|------|-------|
| M1 | 1, 2, 10 | Three separate interband.sh commits across sessions create merge-conflict risk and split testability. Consolidate all interband.sh additions into Task 1. |
| M2 | 9 | String-match dedup produces false positives (suppresses valid beads) and false negatives (creates duplicates). Replace with agent-name-keyed session map. |
| M3 | 10 | Hardcoded `/intermem:synthesize` in intercheck output breaks the interband publisher/consumer boundary. Remove it. |
| M4 | 2 | Budget alert emits on every call above threshold, not at crossing points. Add a last-emitted-bucket gate. |

### Fix Before Completion (Not Blocking to Start)

| ID | Task | Issue |
|----|------|-------|
| C1 | 6 | Four-plugin batch should be four separate tasks. Verify intermem plugin structure first. |
| C2 | 1 | Pressure threshold duplication in context-monitor.sh — use existing `$LEVEL` variable. |
| C3 | 7 | Extend validation script to cross-check edges against integration.json companions. |
| C4 | 6 | intertest, internext, tool-time: create integration.json only, no session-start hooks yet. |
| C5 | 8 | Change "Replace contents" to "Append block after line 9." |

### Low-Priority Cleanup

| ID | Task | Issue |
|----|------|-------|
| L1 | 1, 2 | Document channel vs. type naming convention in interband AGENTS.md. |
| L2 | 4 | Add "check if hooks.json exists" guard matching Task 5's guard. |
| L3 | 10 | Remove unreliable `$(pwd)/.intermem` existence check. |

--- 2026-02-21T02:45:42Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 1: Add Interband Pressure Signal to intercheck

**Files:**
- Modify: `plugins/intercheck/hooks/context-monitor.sh:62-97` (after state write, before threshold output)
- Modify: `infra/interband/lib/interband.sh:167-196` (add validation for new payload type)

**Step 1: Add intercheck:pressure payload validation to interband.sh**

Add a new case to `interband_validate_payload()` in `infra/interband/lib/interband.sh`. Insert after the `interlock:coordination_signal` case (line 196):

```bash
        intercheck:context_pressure)
            echo "$payload_json" | jq -e '
                (.level | type == "string" and test("^(green|yellow|orange|red)$")) and
                (.pressure | type == "number" and . >= 0) and
                (.est_tokens | type == "number" and . >= 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
```

**Step 2: Add interband channel defaults for intercheck:pressure**

In `interband.sh`, add to `interband_default_retention_secs()`:

```bash
        intercheck:pressure)   echo "3600" ;;   # 1h (ephemeral, per-session)
```

And to `interband_default_max_files()`:

```bash
        intercheck:pressure)   echo "64" ;;
```

**Step 3: Add interband write to context-monitor.sh**

In `plugins/intercheck/hooks/context-monitor.sh`, after line 63 (`_ic_write_state "$SF" "$NEW_STATE"`), add the interband signal write:

```bash
# Write pressure level to interband for statusline and other consumers
_ic_interband_root="${INTERBAND_ROOT:-${HOME}/.interband}"
_ic_interband_lib=""
for _ic_lib_candidate in \
    "${SCRIPT_DIR}/../../../infra/interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
  [[ -f "$_ic_lib_candidate" ]] && _ic_interband_lib="$_ic_lib_candidate" && break
done

if [[ -n "$_ic_interband_lib" ]]; then
  source "$_ic_interband_lib"
  _ic_pressure_level="green"
  if (( EST_TOKENS > 200000 )) || awk "BEGIN{exit($PRESSURE > 120 ? 0 : 1)}" 2>/dev/null; then
    _ic_pressure_level="red"
  elif (( EST_TOKENS > 180000 )) || awk "BEGIN{exit($PRESSURE > 90 ? 0 : 1)}" 2>/dev/null; then
    _ic_pressure_level="orange"
  elif (( EST_TOKENS > 150000 )) || awk "BEGIN{exit($PRESSURE > 60 ? 0 : 1)}" 2>/dev/null; then
    _ic_pressure_level="yellow"
  fi

  _ic_ib_payload=$(jq -n -c \
    --arg level "$_ic_pressure_level" \
    --argjson pressure "$PRESSURE" \
    --argjson est_tokens "$EST_TOKENS" \
    --argjson ts "$(date +%s)" \
    '{level:$level, pressure:$pressure, est_tokens:$est_tokens, ts:$ts}')
  _ic_ib_file=$(interband_path "intercheck" "pressure" "$SID" 2>/dev/null) || _ic_ib_file=""
  if [[ -n "$_ic_ib_file" ]]; then
    interband_write "$_ic_ib_file" "intercheck" "context_pressure" "$SID" "$_ic_ib_payload" 2>/dev/null || true
  fi
fi
```

**Step 4: Verify context-monitor.sh still works**

Run: `echo '{"session_id":"test-123","tool_name":"Read","tool_output":"hello"}' | bash plugins/intercheck/hooks/context-monitor.sh`
Expected: No output (green level). Check `/tmp/intercheck-test-123.json` exists. Check `~/.interband/intercheck/pressure/test-123.json` was created.

**Step 5: Clean up test artifacts**

```bash
rm -f /tmp/intercheck-test-123.json ~/.interband/intercheck/pressure/test-123.json
```

**Step 6: Commit**

```bash
git -C plugins/intercheck add hooks/context-monitor.sh
git -C infra/interband add lib/interband.sh
git -C plugins/intercheck commit -m "feat(intercheck): publish context pressure to interband"
git -C infra/interband commit -m "feat(interband): add intercheck:context_pressure payload validation"
```
NEW: ### Task 1: Register All Interband Signals + Add Pressure Publisher to intercheck

> **Review fix [C2]:** All interband.sh changes consolidated here (was split across Tasks 1, 2, 10). Tasks 2 and 10 no longer modify interband.sh.

**Files:**
- Modify: `infra/interband/lib/interband.sh:167-196` (add validation for all three new payload types)
- Modify: `plugins/intercheck/hooks/context-monitor.sh:62-97` (after state write, before threshold output)

**Step 1: Add ALL new payload validations to interband.sh**

Add three new cases to `interband_validate_payload()` in `infra/interband/lib/interband.sh`. Insert after the `interlock:coordination_signal` case (line 196):

```bash
        intercheck:context_pressure)
            echo "$payload_json" | jq -e '
                (.level | type == "string" and test("^(green|yellow|orange|red)$")) and
                (.pressure | type == "number" and . >= 0) and
                (.est_tokens | type == "number" and . >= 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
        interstat:budget_alert)
            echo "$payload_json" | jq -e '
                (.pct_consumed | type == "number" and . >= 0 and . <= 100) and
                (.total_tokens | type == "number" and . >= 0) and
                (.session_id | type == "string" and length > 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
        intercheck:checkpoint_needed)
            echo "$payload_json" | jq -e '
                (.trigger | type == "string" and length > 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
```

**Step 2: Add ALL interband channel defaults**

In `interband.sh`, add to `interband_default_retention_secs()`:

```bash
        intercheck:pressure)    echo "3600" ;;   # 1h (ephemeral, per-session)
        interstat:budget)       echo "21600" ;;  # 6h
        intercheck:checkpoint)  echo "3600" ;;   # 1h
```

And to `interband_default_max_files()`:

```bash
        intercheck:pressure)    echo "64" ;;
        interstat:budget)       echo "64" ;;
        intercheck:checkpoint)  echo "32" ;;
```

**Step 3: Add interband write to context-monitor.sh**

> **Review fixes applied:** [M4] Use `_icm_` prefix (avoids collision with `_ic_*` library namespace). [H1] Use 5-candidate sourcing pattern from `lib-gates.sh`. [L1] Use existing `$LEVEL` variable instead of duplicating thresholds. [H6] Add `|| true` to `source`. [L3] Remove dead `_icm_ib_root` variable. [L5] Add `interband_prune_channel` after write.

In `plugins/intercheck/hooks/context-monitor.sh`, after line 63 (`_ic_write_state "$SF" "$NEW_STATE"`), but **before** the `case "$LEVEL"` block so `$LEVEL` is computed first, add the interband signal write. Note: the interband write must be placed **inside or after** the `case "$LEVEL"` computation so `$LEVEL` is available. If `$LEVEL` is computed at line 67 and the `case` begins at line 72, insert the interband block between lines 67 and 72:

```bash
# Write pressure level to interband for statusline and other consumers
_icm_ib_lib=""
_icm_repo_root="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || true)"
for _icm_ib_candidate in \
    "${INTERBAND_LIB:-}" \
    "${SCRIPT_DIR}/../../../infra/interband/lib/interband.sh" \
    "${SCRIPT_DIR}/../../../interband/lib/interband.sh" \
    "${_icm_repo_root}/../interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
  [[ -n "$_icm_ib_candidate" && -f "$_icm_ib_candidate" ]] && _icm_ib_lib="$_icm_ib_candidate" && break
done

if [[ -n "$_icm_ib_lib" ]]; then
  source "$_icm_ib_lib" || true

  _icm_ib_payload=$(jq -n -c \
    --arg level "$LEVEL" \
    --argjson pressure "$PRESSURE" \
    --argjson est_tokens "$EST_TOKENS" \
    --argjson ts "$(date +%s)" \
    '{level:$level, pressure:$pressure, est_tokens:$est_tokens, ts:$ts}')
  _icm_ib_file=$(interband_path "intercheck" "pressure" "$SID" 2>/dev/null) || _icm_ib_file=""
  if [[ -n "$_icm_ib_file" ]]; then
    interband_write "$_icm_ib_file" "intercheck" "context_pressure" "$SID" "$_icm_ib_payload" 2>/dev/null || true
    interband_prune_channel "intercheck" "pressure" 2>/dev/null || true
  fi
fi
```

**Step 4: Verify context-monitor.sh still works**

Run: `echo '{"session_id":"test-123","tool_name":"Read","tool_output":"hello"}' | bash plugins/intercheck/hooks/context-monitor.sh`
Expected: No output (green level). Check `/tmp/intercheck-test-123.json` exists. Check `~/.interband/intercheck/pressure/test-123.json` was created.

Verify the interband envelope structure:

```bash
jq -e '(.version | startswith("1.")) and .namespace == "intercheck" and .type == "context_pressure" and (.payload.level | type == "string") and (.payload.pressure | type == "number") and (.payload.est_tokens | type == "number")' ~/.interband/intercheck/pressure/test-123.json && echo "Envelope valid" || echo "FAIL: invalid envelope"
```

**Step 5: Clean up test artifacts**

```bash
rm -f /tmp/intercheck-test-123.json ~/.interband/intercheck/pressure/test-123.json
```

**Step 6: Commit**

```bash
git -C infra/interband add lib/interband.sh && git -C infra/interband commit -m "feat(interband): add intercheck + interstat payload validation and channel defaults"
git -C plugins/intercheck add hooks/context-monitor.sh && git -C plugins/intercheck commit -m "feat(intercheck): publish context pressure to interband"
```

--- 2026-02-21T02:46:22Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 2: Add Interband Budget Signal to interstat

**Files:**
- Modify: `plugins/interstat/hooks/post-task.sh:41-61` (after SQLite INSERT)
- Modify: `infra/interband/lib/interband.sh` (add interstat:budget_alert validation)

**Step 1: Add interstat:budget_alert payload validation to interband.sh**

In `interband_validate_payload()`, add after the intercheck case:

```bash
        interstat:budget_alert)
            echo "$payload_json" | jq -e '
                (.pct_consumed | type == "number" and . >= 0 and . <= 100) and
                (.total_tokens | type == "number" and . >= 0) and
                (.session_id | type == "string" and length > 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
```

And add retention defaults:

```bash
        interstat:budget)      echo "21600" ;;  # 6h
```

```bash
        interstat:budget)      echo "64" ;;
```

**Step 2: Add budget alert emission to post-task.sh**

In `plugins/interstat/hooks/post-task.sh`, after the successful SQLite INSERT (after line 61), add:

```bash
# Emit budget alert to interband if sprint budget tracking is active
_is_interband_lib=""
for _is_lib_candidate in \
    "$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../infra/interband/lib" && pwd)/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
  [[ -f "$_is_lib_candidate" ]] && _is_interband_lib="$_is_lib_candidate" && break
done

if [[ -n "$_is_interband_lib" && -n "$session_id" ]]; then
  source "$_is_interband_lib"

  # Query total tokens for this session
  _is_total=$(sqlite3 "$DB_PATH" "PRAGMA busy_timeout=5000; SELECT COALESCE(SUM(result_length / 4), 0) FROM agent_runs WHERE session_id='$(printf "%s" "$session_id" | sed "s/'/''/g")';" 2>/dev/null || echo "0")

  # Check if sprint budget is set (via bead state)
  _is_budget="${INTERSTAT_TOKEN_BUDGET:-0}"
  if [[ "$_is_budget" -gt 0 && "$_is_total" -gt 0 ]]; then
    _is_pct=$(awk "BEGIN{printf \"%.1f\", ($_is_total / $_is_budget) * 100}" 2>/dev/null || echo "0")
    _is_pct_int="${_is_pct%.*}"

    # Only emit at threshold crossings: 50%, 80%, 95%
    if [[ "$_is_pct_int" -ge 50 ]]; then
      _is_ib_payload=$(jq -n -c \
        --argjson pct_consumed "$_is_pct" \
        --argjson total_tokens "$_is_total" \
        --arg session_id "$session_id" \
        --argjson ts "$(date +%s)" \
        '{pct_consumed:$pct_consumed, total_tokens:$total_tokens, session_id:$session_id, ts:$ts}')
      _is_ib_file=$(interband_path "interstat" "budget" "$session_id" 2>/dev/null) || _is_ib_file=""
      if [[ -n "$_is_ib_file" ]]; then
        interband_write "$_is_ib_file" "interstat" "budget_alert" "$session_id" "$_is_ib_payload" 2>/dev/null || true
      fi
    fi
  fi
fi
```

**Step 3: Verify post-task.sh still works**

Run: `echo '{"session_id":"test-456","tool_input":{"subagent_type":"Explore","description":"test"},"tool_output":"result"}' | bash plugins/interstat/hooks/post-task.sh`
Expected: Exit 0. Check `~/.claude/interstat/metrics.db` has a new row.

**Step 4: Commit**

```bash
git -C plugins/interstat add hooks/post-task.sh
git -C infra/interband add lib/interband.sh
git -C plugins/interstat commit -m "feat(interstat): publish budget alerts to interband"
git -C infra/interband commit -m "feat(interband): add interstat:budget_alert payload validation"
```
NEW: ### Task 2: Add Interband Budget Signal to interstat

> **Review fix [C2]:** interband.sh validation and defaults already added in Task 1. This task only modifies `post-task.sh`.

**Files:**
- Modify: `plugins/interstat/hooks/post-task.sh:41-61` (after SQLite INSERT)

**Step 1: Add budget alert emission to post-task.sh**

> **Review fixes applied:** [H1] Use 5-candidate sourcing pattern from `lib-gates.sh`. [H2] Use heredoc for SQL query (matches existing INSERT pattern). [M6] Add numeric guards on `_is_budget` and `_is_total`. [H3] Implement actual threshold-crossing logic with tier tracking. [H6] Add `|| true` to `source`.

In `plugins/interstat/hooks/post-task.sh`, after the successful SQLite INSERT (after line 61), add:

```bash
# Emit budget alert to interband if sprint budget tracking is active
_is_interband_lib=""
_is_repo_root="$(git -C "$(dirname "${BASH_SOURCE[0]}")" rev-parse --show-toplevel 2>/dev/null || true)"
for _is_lib_candidate in \
    "${INTERBAND_LIB:-}" \
    "$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../infra/interband/lib" 2>/dev/null && pwd)/interband.sh" \
    "$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../interband/lib" 2>/dev/null && pwd)/interband.sh" \
    "${_is_repo_root}/../interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
  [[ -n "$_is_lib_candidate" && -f "$_is_lib_candidate" ]] && _is_interband_lib="$_is_lib_candidate" && break
done

if [[ -n "$_is_interband_lib" && -n "$session_id" ]]; then
  source "$_is_interband_lib" || true

  # Query total tokens for this session (heredoc matches existing INSERT pattern)
  _is_total=$(sqlite3 "$DB_PATH" <<SQL 2>/dev/null || echo "0"
PRAGMA busy_timeout=5000;
SELECT COALESCE(SUM(result_length / 4), 0)
FROM agent_runs
WHERE session_id='$(printf "%s" "$session_id" | sed "s/'/''/g")';
SQL
  )

  # Guard against non-numeric values
  _is_budget="${INTERSTAT_TOKEN_BUDGET:-0}"
  [[ "$_is_budget" =~ ^[0-9]+$ ]] || _is_budget=0
  [[ "$_is_total" =~ ^[0-9]+$ ]] || _is_total=0

  if [[ "$_is_budget" -gt 0 && "$_is_total" -gt 0 ]]; then
    _is_pct=$(awk "BEGIN{printf \"%.1f\", ($_is_total / $_is_budget) * 100}" 2>/dev/null || echo "0")
    _is_pct_int="${_is_pct%.*}"
    [[ "$_is_pct_int" =~ ^[0-9]+$ ]] || _is_pct_int=0

    # Determine current tier
    _is_tier=""
    if [[ "$_is_pct_int" -ge 95 ]]; then _is_tier="critical"
    elif [[ "$_is_pct_int" -ge 80 ]]; then _is_tier="high"
    elif [[ "$_is_pct_int" -ge 50 ]]; then _is_tier="medium"
    fi

    # Only emit at threshold crossings (tier changes), not every event above 50%
    if [[ -n "$_is_tier" ]]; then
      _is_tier_file="/tmp/interstat-budget-tier-${session_id}"
      _is_last_tier=$(cat "$_is_tier_file" 2>/dev/null || echo "")
      if [[ "$_is_tier" != "$_is_last_tier" ]]; then
        printf '%s' "$_is_tier" > "$_is_tier_file" 2>/dev/null || true
        _is_ib_payload=$(jq -n -c \
          --argjson pct_consumed "$_is_pct" \
          --argjson total_tokens "$_is_total" \
          --arg session_id "$session_id" \
          --argjson ts "$(date +%s)" \
          '{pct_consumed:$pct_consumed, total_tokens:$total_tokens, session_id:$session_id, ts:$ts}')
        _is_ib_file=$(interband_path "interstat" "budget" "$session_id" 2>/dev/null) || _is_ib_file=""
        if [[ -n "$_is_ib_file" ]]; then
          interband_write "$_is_ib_file" "interstat" "budget_alert" "$session_id" "$_is_ib_payload" 2>/dev/null || true
        fi
      fi
    fi
  fi
fi
```

**Step 2: Verify post-task.sh still works**

Run: `echo '{"session_id":"test-456","tool_input":{"subagent_type":"Explore","description":"test"},"tool_output":"result"}' | bash plugins/interstat/hooks/post-task.sh`
Expected: Exit 0. Check `~/.claude/interstat/metrics.db` has a new row.

Verify envelope if budget signal was emitted:

```bash
[[ -f ~/.interband/interstat/budget/test-456.json ]] && jq -e '(.version | startswith("1.")) and .namespace == "interstat" and .type == "budget_alert" and (.payload.pct_consumed | type == "number")' ~/.interband/interstat/budget/test-456.json && echo "Envelope valid" || echo "No budget signal (expected if INTERSTAT_TOKEN_BUDGET not set)"
```

**Step 3: Commit**

```bash
git -C plugins/interstat add hooks/post-task.sh && git -C plugins/interstat commit -m "feat(interstat): publish budget alerts to interband at threshold crossings"
```

--- 2026-02-21T02:46:30Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD:       _il_budget_pct=$(_il_interband_payload_field "$_il_budget_file" "pct_consumed")
      if [ -n "$_il_budget_pct" ]; then
        _il_budget_int="${_il_budget_pct%.*}"
        if [ "${_il_budget_int:-0}" -ge 80 ]; then
NEW:       _il_budget_pct=$(_il_interband_payload_field "$_il_budget_file" "pct_consumed")
      if [ -n "$_il_budget_pct" ]; then
        _il_budget_int="${_il_budget_pct%.*}"
        # Guard against non-numeric values (e.g., jq returning "null")
        case "$_il_budget_int" in ''|*[!0-9]*) _il_budget_int=0 ;; esac
        if [ "${_il_budget_int:-0}" -ge 80 ]; then

--- 2026-02-21T02:46:40Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: **Step 3: Create session-start hook**

Create `plugins/interline/hooks/session-start.sh`:

```bash
#!/usr/bin/env bash
# interline session-start hook — source interbase and nudge companions
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$HOOK_DIR/interbase-stub.sh"

ib_session_status
ib_nudge_companion "intercheck" "Adds context pressure indicator to your statusline"
```

**Step 4: Register the session-start hook**

Create `plugins/interline/hooks/hooks.json`:
NEW: **Step 3: Create session-start hook**

> **Review fix [L2]:** Added `set -euo pipefail` for consistency with all other hooks in the codebase.

Create `plugins/interline/hooks/session-start.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail
# interline session-start hook — source interbase and nudge companions
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$HOOK_DIR/interbase-stub.sh"

ib_session_status
ib_nudge_companion "intercheck" "Adds context pressure indicator to your statusline"
```

**Step 4: Register the session-start hook**

> **Review fix [L2 from architecture]:** Check if `hooks.json` already exists before creating (matching Task 5's guard pattern).

Check if `plugins/interline/hooks/hooks.json` exists. If so, merge the SessionStart entry. If not, create it:

--- 2026-02-21T02:46:47Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: Create `plugins/intersynth/hooks/session-start.sh`:

```bash
#!/usr/bin/env bash
# intersynth session-start hook — source interbase and nudge companions
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$HOOK_DIR/interbase-stub.sh"

ib_session_status
ib_nudge_companion "interflux" "Enables multi-agent review with verdict synthesis"
```
NEW: Create `plugins/intersynth/hooks/session-start.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail
# intersynth session-start hook — source interbase and nudge companions
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$HOOK_DIR/interbase-stub.sh"

ib_session_status
ib_nudge_companion "interflux" "Enables multi-agent review with verdict synthesis"
```

--- 2026-02-21T02:47:29Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 6: Interbase SDK Adoption — intermem, intertest, internext, tool-time

This task repeats the same pattern for 4 more plugins. Each follows identical steps:

**For each plugin (intermem, intertest, internext, tool-time):**

**Step 1: Copy interbase stub**

```bash
cp sdk/interbase/templates/interbase-stub.sh plugins/<plugin>/hooks/interbase-stub.sh
```

**Step 2: Create integration.json**

`plugins/<plugin>/.claude-plugin/integration.json` — customize `standalone_features`, `integrated_features`, and `companions` for each:

**intermem:**
```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Auto-memory synthesis and promotion to reference docs",
    "Time-based decay and demotion of stale entries"
  ],
  "integrated_features": [
    { "feature": "Citation freshness from interwatch drift scores", "requires": "interwatch" },
    { "feature": "Smart checkpoint synthesis from intercheck pressure", "requires": "intercheck" }
  ],
  "companions": {
    "recommended": ["interwatch"],
    "optional": ["intercheck"]
  }
}
```

**intertest:**
```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Systematic debugging discipline",
    "Test-driven development guidance",
    "Verification gates before completion claims"
  ],
  "integrated_features": [
    { "feature": "Syntax error stream from intercheck", "requires": "intercheck" }
  ],
  "companions": {
    "recommended": [],
    "optional": ["intercheck"]
  }
}
```

**internext:**
```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Work prioritization with impact/effort/risk scoring",
    "Tradeoff-aware next-task recommendations"
  ],
  "integrated_features": [
    { "feature": "Historical effort calibration from interstat", "requires": "interstat" },
    { "feature": "Discovery confidence boost from interject", "requires": "interject" }
  ],
  "companions": {
    "recommended": [],
    "optional": ["interstat", "interject"]
  }
}
```

**tool-time:**
```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Tool usage event collection and analytics",
    "Usage pattern dashboards"
  ],
  "integrated_features": [
    { "feature": "Cross-reference with interstat token metrics", "requires": "interstat" }
  ],
  "companions": {
    "recommended": [],
    "optional": ["interstat"]
  }
}
```

**Step 3: Create session-start hook for each**

Each `plugins/<plugin>/hooks/session-start.sh`:

```bash
#!/usr/bin/env bash
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$HOOK_DIR/interbase-stub.sh"
ib_session_status
```

Add companion nudges where appropriate:
- **intermem:** `ib_nudge_companion "interwatch" "Enables citation freshness checking for promoted entries"`
- **intertest:** (no nudge — companions are optional)
- **internext:** `ib_nudge_companion "interstat" "Calibrates effort estimates with historical token data"`
- **tool-time:** (no nudge — companions are optional)

**Step 4: Register SessionStart hooks**

Check if each plugin already has a `hooks/hooks.json`. If so, merge the SessionStart entry. If the plugin uses a different hooks path, create at the correct location.

**Step 5: Make executable, test each**

```bash
for p in intermem intertest internext tool-time; do
  chmod +x "plugins/$p/hooks/session-start.sh"
  bash "plugins/$p/hooks/session-start.sh" && echo "$p: OK" || echo "$p: FAIL"
done
```

**Step 6: Commit per plugin**

```bash
for p in intermem intertest internext tool-time; do
  git -C "plugins/$p" add hooks/interbase-stub.sh hooks/session-start.sh .claude-plugin/integration.json
  [ -f "plugins/$p/hooks/hooks.json" ] && git -C "plugins/$p" add hooks/hooks.json
  git -C "plugins/$p" commit -m "feat($p): adopt interbase SDK with companion nudges"
done
```
NEW: ### Task 6: Interbase SDK Adoption — intermem, intertest, internext, tool-time

> **Review fixes applied:** [M3] Split into four independent sub-tasks (6a–6d) for per-plugin rollback and accurate progress tracking. [C4] intertest, internext, tool-time: create `integration.json` only (documentation artifacts); defer session-start hooks until a concrete integrated feature ships in a plan that uses them. intermem gets hooks because checkpoint synthesis (Task 10) is a concrete consumer. [L2] Added `set -euo pipefail` to session-start stubs. [L7] Collapsed multi-line loops to one-liners. [M3-note] Verify intermem plugin structure before SDK adoption (it may lack standard plugin layout).

---

#### Task 6a: Interbase SDK Adoption — intermem

**Prerequisites:** Verify `plugins/intermem/` has standard plugin structure (`.claude-plugin/plugin.json`, `hooks/` directory). If not, create the necessary directories first.

**Step 1: Copy interbase stub**

```bash
mkdir -p plugins/intermem/hooks && cp sdk/interbase/templates/interbase-stub.sh plugins/intermem/hooks/interbase-stub.sh
```

**Step 2: Create integration.json**

Create `plugins/intermem/.claude-plugin/integration.json`:

```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Auto-memory synthesis and promotion to reference docs",
    "Time-based decay and demotion of stale entries"
  ],
  "integrated_features": [
    { "feature": "Citation freshness from interwatch drift scores", "requires": "interwatch" },
    { "feature": "Smart checkpoint synthesis from intercheck pressure", "requires": "intercheck" }
  ],
  "companions": {
    "recommended": ["interwatch"],
    "optional": ["intercheck"]
  }
}
```

**Step 3: Create session-start hook** (intermem has a concrete consumer: Task 10 checkpoint synthesis)

```bash
#!/usr/bin/env bash
set -euo pipefail
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$HOOK_DIR/interbase-stub.sh"
ib_session_status
ib_nudge_companion "interwatch" "Enables citation freshness checking for promoted entries"
```

**Step 4: Register SessionStart hook**

Check if `plugins/intermem/hooks/hooks.json` exists. If so, merge. If not, create with standard SessionStart entry.

**Step 5: Test and commit**

```bash
chmod +x plugins/intermem/hooks/session-start.sh && bash plugins/intermem/hooks/session-start.sh && echo "intermem: OK" || echo "intermem: FAIL"
git -C plugins/intermem add hooks/interbase-stub.sh hooks/session-start.sh .claude-plugin/integration.json && [ -f plugins/intermem/hooks/hooks.json ] && git -C plugins/intermem add hooks/hooks.json; git -C plugins/intermem commit -m "feat(intermem): adopt interbase SDK with companion nudges"
```

---

#### Task 6b: Interbase SDK Adoption — intertest (integration.json only)

> No session-start hook — intertest has no concrete integrated feature shipping in this plan.

**Step 1: Create integration.json**

Create `plugins/intertest/.claude-plugin/integration.json`:

```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Systematic debugging discipline",
    "Test-driven development guidance",
    "Verification gates before completion claims"
  ],
  "integrated_features": [
    { "feature": "Syntax error stream from intercheck", "requires": "intercheck" }
  ],
  "companions": {
    "recommended": [],
    "optional": ["intercheck"]
  }
}
```

**Step 2: Commit**

```bash
git -C plugins/intertest add .claude-plugin/integration.json && git -C plugins/intertest commit -m "feat(intertest): add integration.json for ecosystem metadata"
```

---

#### Task 6c: Interbase SDK Adoption — internext (integration.json only)

> No session-start hook — internext has no concrete integrated feature shipping in this plan.

**Step 1: Create integration.json**

Create `plugins/internext/.claude-plugin/integration.json`:

```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Work prioritization with impact/effort/risk scoring",
    "Tradeoff-aware next-task recommendations"
  ],
  "integrated_features": [
    { "feature": "Historical effort calibration from interstat", "requires": "interstat" },
    { "feature": "Discovery confidence boost from interject", "requires": "interject" }
  ],
  "companions": {
    "recommended": [],
    "optional": ["interstat", "interject"]
  }
}
```

**Step 2: Commit**

```bash
git -C plugins/internext add .claude-plugin/integration.json && git -C plugins/internext commit -m "feat(internext): add integration.json for ecosystem metadata"
```

---

#### Task 6d: Interbase SDK Adoption — tool-time (integration.json only)

> No session-start hook — tool-time has no concrete integrated feature shipping in this plan.

**Step 1: Create integration.json**

Create `plugins/tool-time/.claude-plugin/integration.json`:

```json
{
  "ecosystem": "interverse",
  "interbase_min_version": "1.0.0",
  "ecosystem_only": false,
  "standalone_features": [
    "Tool usage event collection and analytics",
    "Usage pattern dashboards"
  ],
  "integrated_features": [
    { "feature": "Cross-reference with interstat token metrics", "requires": "interstat" }
  ],
  "companions": {
    "recommended": [],
    "optional": ["interstat"]
  }
}
```

**Step 2: Commit**

```bash
git -C plugins/tool-time add .claude-plugin/integration.json && git -C plugins/tool-time commit -m "feat(tool-time): add integration.json for ecosystem metadata"
```

--- 2026-02-21T02:47:41Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: **Step 2: Validate the graph**

```bash
python3 -c "
import json, os
g = json.load(open('companion-graph.json'))
plugins = set(os.listdir('plugins'))
errors = []
for e in g['edges']:
    if e['from'] not in plugins:
        errors.append(f\"Unknown plugin: {e['from']}\")
    if e['to'] not in plugins:
        errors.append(f\"Unknown plugin: {e['to']}\")
print(f\"{len(g['edges'])} edges, {len(errors)} errors\")
for err in errors:
    print(f'  ERROR: {err}')
"
```

Expected: `12 edges, 0 errors`
NEW: **Step 2: Validate the graph**

> **Review fix [L10]:** Validation now cross-checks edges against each plugin's `integration.json` companions declarations.

```bash
python3 -c "
import json, os, pathlib
g = json.load(open('companion-graph.json'))
plugins = set(os.listdir('plugins'))
errors = []
for e in g['edges']:
    if e['from'] not in plugins:
        errors.append(f\"Unknown plugin: {e['from']}\")
    if e['to'] not in plugins:
        errors.append(f\"Unknown plugin: {e['to']}\")

# Cross-validate: every companion in integration.json should appear in the graph
for p in plugins:
    ij = pathlib.Path(f'plugins/{p}/.claude-plugin/integration.json')
    if ij.exists():
        meta = json.load(open(ij))
        companions = meta.get('companions', {})
        for kind in ('recommended', 'optional'):
            for comp in companions.get(kind, []):
                if not any(e['from'] == p and e['to'] == comp for e in g['edges']):
                    errors.append(f'{p}: companion {comp} ({kind}) not in graph')

print(f\"{len(g['edges'])} edges, {len(errors)} errors\")
for err in errors:
    print(f'  ERROR: {err}')
"
```

Expected: `12 edges, 0 errors`

--- 2026-02-21T02:48:21Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 8: Cost-Aware Review Depth — Always-On Budget Signal

**Files:**
- Modify: `plugins/interflux/hooks/session-start.sh` (read interband budget signal)

**Step 1: Modify interflux session-start to read interstat budget**

Replace the contents of `plugins/interflux/hooks/session-start.sh`:

```bash
#!/usr/bin/env bash
# interflux session-start hook — source interbase, read budget signal, emit status
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$HOOK_DIR/interbase-stub.sh"
ib_session_status

# Read interstat budget signal if available (always-on, not sprint-only)
_if_interband_root="${INTERBAND_ROOT:-${HOME}/.interband}"
_if_session_id="${CLAUDE_SESSION_ID:-}"
if [[ -n "$_if_session_id" && -z "${FLUX_BUDGET_REMAINING:-}" ]]; then
  _if_budget_file="${_if_interband_root}/interstat/budget/${_if_session_id}.json"
  if [[ -f "$_if_budget_file" ]]; then
    _if_pct=$(jq -r '.payload.pct_consumed // empty' "$_if_budget_file" 2>/dev/null)
    if [[ -n "$_if_pct" ]]; then
      _if_pct_int="${_if_pct%.*}"
      # Convert percentage consumed to remaining tokens estimate
      # Default budget 500k tokens if not set
      _if_budget="${INTERSTAT_TOKEN_BUDGET:-500000}"
      _if_remaining=$(awk "BEGIN{printf \"%d\", $_if_budget * (100 - $_if_pct) / 100}" 2>/dev/null || echo "")
      if [[ -n "$_if_remaining" && "$_if_remaining" -gt 0 ]]; then
        export FLUX_BUDGET_REMAINING="$_if_remaining"
      fi
    fi
  fi
fi
```

**Step 2: Verify interflux session-start works**

```bash
CLAUDE_SESSION_ID=test-789 bash plugins/interflux/hooks/session-start.sh && echo "OK"
```

Expected: `OK`. No interband file exists so `FLUX_BUDGET_REMAINING` stays unset.

**Step 3: Commit**

```bash
git -C plugins/interflux add hooks/session-start.sh
git -C plugins/interflux commit -m "feat(interflux): always-on budget signal from interstat interband"
```
NEW: ### Task 8: Cost-Aware Review Depth — Always-On Budget Signal

> **Review fixes applied:** [C1] Read `session_id` from stdin JSON (NOT `CLAUDE_SESSION_ID` env var — that doesn't exist). [M5] Source interband.sh and use `interband_read_payload` for envelope validation instead of raw jq. [L11] Append new block after existing lines, not "replace contents". [M9] Use `INTERMOD_LIB=/nonexistent` override for fallback testing (not destructive `mv`). Export via `CLAUDE_ENV_FILE` so subsequent hooks can see the value.

**Files:**
- Modify: `plugins/interflux/hooks/session-start.sh` (append budget-reading block)

**Prerequisites:** Verify `plugins/interflux/hooks/session-start.sh` current contents. Grep for existing `command -v ic`, `command -v bd`, or `ib_has_ic` patterns that need replacing with `ib_*` calls (PRD F4 requirement).

**Step 1: Append budget-reading block to interflux session-start**

After the existing lines (`source "$HOOK_DIR/interbase-stub.sh"` and `ib_session_status`), append:

```bash
# Read interstat budget signal if available (always-on, not sprint-only)
# CRITICAL: session_id comes from stdin JSON, NOT from env var
HOOK_INPUT=$(cat)   # must consume stdin before anything else
_if_session_id=$(printf '%s' "$HOOK_INPUT" | jq -r '.session_id // empty' 2>/dev/null)

_if_interband_root="${INTERBAND_ROOT:-${HOME}/.interband}"

# Source interband for envelope validation
_if_interband_lib=""
_if_repo_root="$(git -C "$HOOK_DIR" rev-parse --show-toplevel 2>/dev/null || true)"
for _if_lib_candidate in \
    "${INTERBAND_LIB:-}" \
    "${HOOK_DIR}/../../../infra/interband/lib/interband.sh" \
    "${HOOK_DIR}/../../../interband/lib/interband.sh" \
    "${_if_repo_root}/../interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
  [[ -n "$_if_lib_candidate" && -f "$_if_lib_candidate" ]] && _if_interband_lib="$_if_lib_candidate" && break
done

if [[ -n "$_if_session_id" && -z "${FLUX_BUDGET_REMAINING:-}" ]]; then
  _if_budget_file="${_if_interband_root}/interstat/budget/${_if_session_id}.json"
  if [[ -f "$_if_budget_file" ]]; then
    # Use interband_read_payload for envelope validation if available
    _if_pct=""
    if [[ -n "$_if_interband_lib" ]]; then
      source "$_if_interband_lib" || true
      _if_payload=$(interband_read_payload "$_if_budget_file" 2>/dev/null) || _if_payload=""
      if [[ -n "$_if_payload" ]]; then
        _if_pct=$(printf '%s' "$_if_payload" | jq -r '.pct_consumed // empty' 2>/dev/null)
      fi
    else
      # Fallback: raw jq if interband.sh not available
      _if_pct=$(jq -r '.payload.pct_consumed // empty' "$_if_budget_file" 2>/dev/null)
    fi

    if [[ -n "$_if_pct" ]]; then
      _if_pct_int="${_if_pct%.*}"
      [[ "$_if_pct_int" =~ ^[0-9]+$ ]] || _if_pct_int=0
      # Convert percentage consumed to remaining tokens estimate
      _if_budget="${INTERSTAT_TOKEN_BUDGET:-500000}"
      [[ "$_if_budget" =~ ^[0-9]+$ ]] || _if_budget=500000
      _if_remaining=$(awk "BEGIN{printf \"%d\", $_if_budget * (100 - $_if_pct) / 100}" 2>/dev/null || echo "")
      if [[ -n "$_if_remaining" && "$_if_remaining" -gt 0 && -n "${CLAUDE_ENV_FILE:-}" ]]; then
        echo "export FLUX_BUDGET_REMAINING=${_if_remaining}" >> "$CLAUDE_ENV_FILE"
      fi
    fi
  fi
fi
```

**Important:** The `HOOK_INPUT=$(cat)` line must be at the **top** of the file, before `source "$HOOK_DIR/interbase-stub.sh"`, since stdin can only be consumed once. Restructure the hook so stdin is consumed first:

```bash
#!/usr/bin/env bash
set -euo pipefail
# interflux session-start hook — source interbase, read budget signal, emit status
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HOOK_INPUT=$(cat)   # consume stdin first — session_id is here

source "$HOOK_DIR/interbase-stub.sh"
ib_session_status

# [budget-reading block from above, using $HOOK_INPUT for session_id]
```

**Step 2: Verify interflux session-start works — live mode**

```bash
echo '{"session_id":"test-789"}' | bash plugins/interflux/hooks/session-start.sh && echo "OK"
```

Expected: `OK`. No interband file exists so `FLUX_BUDGET_REMAINING` stays unset.

**Step 3: Verify fallback mode (interbase stub only, no live intermod)**

```bash
echo '{"session_id":"test-789"}' | INTERMOD_LIB=/nonexistent bash plugins/interflux/hooks/session-start.sh 2>&1
```

Expected: Exit 0. Stub functions used. No errors.

**Step 4: Run existing interflux tests**

```bash
bash plugins/interflux/tests/test-budget.sh
```

This is a required regression gate, not optional discovery.

**Step 5: Commit**

```bash
git -C plugins/interflux add hooks/session-start.sh && git -C plugins/interflux commit -m "feat(interflux): always-on budget signal from interstat interband"
```

--- 2026-02-21T02:48:56Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 9: Verdict-to-Bead Bridge (Opt-in)

**Files:**
- Modify: `plugins/intersynth/hooks/lib-verdict.sh` (add `verdict_auto_create_beads` function)

**Step 1: Read existing lib-verdict.sh**

Read `plugins/intersynth/hooks/lib-verdict.sh` to understand the current API.

**Step 2: Add verdict_auto_create_beads function**

Append to `plugins/intersynth/hooks/lib-verdict.sh`:

```bash
# Auto-create beads for critical verdict findings (opt-in via INTERSYNTH_AUTO_BEAD=true)
verdict_auto_create_beads() {
    [[ "${INTERSYNTH_AUTO_BEAD:-}" == "true" ]] || return 0
    command -v bd >/dev/null 2>&1 || return 0

    local verdicts_dir="${1:-${HOME}/.clavain/verdicts}"
    [[ -d "$verdicts_dir" ]] || return 0

    local created=0
    for verdict_file in "$verdicts_dir"/*.json; do
        [[ -f "$verdict_file" ]] || continue

        local status agent summary
        status=$(jq -r '.status // ""' "$verdict_file" 2>/dev/null)
        [[ "$status" == "NEEDS_ATTENTION" ]] || continue

        agent=$(jq -r '.agent // "unknown"' "$verdict_file" 2>/dev/null)
        summary=$(jq -r '.summary // ""' "$verdict_file" 2>/dev/null)
        [[ -n "$summary" ]] || continue

        # Check for existing bead with similar title
        local title="Review finding: ${summary:0:60}"
        local existing
        existing=$(bd list --json --quiet 2>/dev/null | jq -r ".[].title" 2>/dev/null | grep -Fc "${summary:0:30}" || echo "0")
        [[ "$existing" -eq 0 ]] || continue

        # Create bead
        local new_id
        new_id=$(bd create --title="$title" --type=task --priority=1 --description="From $agent review. $summary" 2>&1 | grep -oE 'iv-[a-z0-9]+' || echo "")
        if [[ -n "$new_id" ]]; then
            created=$((created + 1))
        fi
    done

    if [[ "$created" -gt 0 ]]; then
        echo "[intersynth] Auto-created $created beads from critical verdict findings" >&2
    fi
}
```

**Step 3: Test the function (dry run)**

```bash
source plugins/intersynth/hooks/lib-verdict.sh
INTERSYNTH_AUTO_BEAD=false verdict_auto_create_beads && echo "Opt-out works"
```

Expected: Returns immediately (opt-in guard).

**Step 4: Commit**

```bash
git -C plugins/intersynth add hooks/lib-verdict.sh
git -C plugins/intersynth commit -m "feat(intersynth): opt-in verdict-to-bead bridge for P0/P1 findings"
```
NEW: ### Task 9: Verdict-to-Bead Bridge (Opt-in)

> **Review fixes applied:** [H4] Replace 30-char prefix string-match dedup with agent-name-keyed session map. [H4] Filter to open/in_progress beads only (closed beads don't block new ones). [L9] Guard jq against non-array `bd list` output.

**Files:**
- Modify: `plugins/intersynth/hooks/lib-verdict.sh` (add `verdict_auto_create_beads` function)

**Step 1: Read existing lib-verdict.sh**

Read `plugins/intersynth/hooks/lib-verdict.sh` to understand the current API.

**Step 2: Add verdict_auto_create_beads function**

Append to `plugins/intersynth/hooks/lib-verdict.sh`:

```bash
# Auto-create beads for critical verdict findings (opt-in via INTERSYNTH_AUTO_BEAD=true)
verdict_auto_create_beads() {
    [[ "${INTERSYNTH_AUTO_BEAD:-}" == "true" ]] || return 0
    command -v bd >/dev/null 2>&1 || return 0

    local verdicts_dir="${1:-${HOME}/.clavain/verdicts}"
    [[ -d "$verdicts_dir" ]] || return 0

    # Session-scoped dedup map: agent-name → bead-id
    # Uses agent name (filename without .json) as stable key, not summary text
    local session_id="${CLAUDE_SESSION_ID:-$$}"
    local bead_map="/tmp/intersynth-bead-map-${session_id}.json"
    [[ -f "$bead_map" ]] || echo '{}' > "$bead_map"

    local created=0
    for verdict_file in "$verdicts_dir"/*.json; do
        [[ -f "$verdict_file" ]] || continue

        local status agent summary agent_key
        status=$(jq -r '.status // ""' "$verdict_file" 2>/dev/null)
        [[ "$status" == "NEEDS_ATTENTION" ]] || continue

        agent=$(jq -r '.agent // "unknown"' "$verdict_file" 2>/dev/null)
        summary=$(jq -r '.summary // ""' "$verdict_file" 2>/dev/null)
        [[ -n "$summary" ]] || continue

        # Dedup key: agent name from filename (stable identifier)
        agent_key="$(basename "$verdict_file" .json)"

        # Check session map first (O(1), no bd call)
        local mapped_id
        mapped_id=$(jq -r --arg k "$agent_key" '.[$k] // empty' "$bead_map" 2>/dev/null)
        [[ -z "$mapped_id" ]] || continue

        # Fallback: check open beads with longer prefix (50 chars) and status filter
        local title="Review finding: ${summary:0:60}"
        local existing
        existing=$(bd list --status=open --json --quiet 2>/dev/null \
          | jq -r --arg prefix "${summary:0:50}" \
            'if type == "array" then [.[] | select(.title | tostring | contains($prefix))] | length else 0 end' \
          2>/dev/null || echo "0")
        [[ "$existing" -eq 0 ]] || continue

        # Create bead
        local new_id
        new_id=$(bd create --title="$title" --type=task --priority=1 --description="From $agent review. $summary" 2>&1 | grep -oE 'iv-[a-z0-9]+' || echo "")
        if [[ -n "$new_id" ]]; then
            # Record in session map to prevent duplicates on re-invocation
            local tmp_map
            tmp_map=$(mktemp "${bead_map}.XXXXXX") || continue
            jq --arg k "$agent_key" --arg v "$new_id" '. + {($k): $v}' "$bead_map" > "$tmp_map" 2>/dev/null && mv -f "$tmp_map" "$bead_map" || rm -f "$tmp_map"
            created=$((created + 1))
        fi
    done

    if [[ "$created" -gt 0 ]]; then
        echo "[intersynth] Auto-created $created beads from critical verdict findings" >&2
    fi
}
```

**Step 3: Test the function (dry run)**

```bash
source plugins/intersynth/hooks/lib-verdict.sh
INTERSYNTH_AUTO_BEAD=false verdict_auto_create_beads && echo "Opt-out works"
```

Expected: Returns immediately (opt-in guard).

**Step 4: Run existing intersynth tests**

```bash
bash plugins/intersynth/tests/test-verdict.sh 2>/dev/null || echo "No existing test suite"
```

**Step 5: Commit**

```bash
git -C plugins/intersynth add hooks/lib-verdict.sh && git -C plugins/intersynth commit -m "feat(intersynth): opt-in verdict-to-bead bridge with agent-name dedup"
```

--- 2026-02-21T02:49:36Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 10: Smart Checkpoint Triggers

**Files:**
- Modify: `plugins/intercheck/hooks/context-monitor.sh` (at orange/red thresholds, check for intermem)

**Step 1: Add intermem synthesis trigger at Orange threshold**

In `plugins/intercheck/hooks/context-monitor.sh`, modify the `orange` case (around line 89-91) to check for intermem entries:

```bash
  orange)
    # Check if intermem has unprocessed entries (smart checkpoint)
    _ic_checkpoint_triggered=""
    if command -v python3 >/dev/null 2>&1; then
      _ic_intermem_dir="$(pwd)/.intermem"
      _ic_last_checkpoint="/tmp/intercheck-intermem-checkpoint-${SID}"
      if [[ -d "$_ic_intermem_dir" ]] && [[ ! -f "$_ic_last_checkpoint" || $(( NOW - $(stat -c %Y "$_ic_last_checkpoint" 2>/dev/null || echo 0) )) -gt 900 ]]; then
        # Rate limit: max once per 15 minutes
        touch "$_ic_last_checkpoint" 2>/dev/null || true
        # Signal intermem via interband
        if [[ -n "${_ic_interband_lib:-}" ]]; then
          _ic_cp_payload=$(jq -n -c --argjson ts "$NOW" '{"trigger":"orange_pressure","ts":$ts}')
          _ic_cp_file=$(interband_path "intercheck" "checkpoint" "$SID" 2>/dev/null) || _ic_cp_file=""
          if [[ -n "$_ic_cp_file" ]]; then
            interband_write "$_ic_cp_file" "intercheck" "checkpoint_needed" "$SID" "$_ic_cp_payload" 2>/dev/null || true
            _ic_checkpoint_triggered=" Consider running /intermem:synthesize to preserve learnings."
          fi
        fi
      fi
    fi
    jq -n --arg msg "Context pressure is high (pressure: $PRESSURE, ~${EST_TOKENS} tokens). Finish current work and commit. Avoid launching new subagents.${_ic_checkpoint_triggered}" \
      '{"additionalContext": $msg}'
    ;;
```

**Step 2: Add checkpoint_needed payload validation to interband.sh**

```bash
        intercheck:checkpoint_needed)
            echo "$payload_json" | jq -e '
                (.trigger | type == "string" and length > 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
```

And retention defaults:

```bash
        intercheck:checkpoint)  echo "3600" ;;  # 1h
```

```bash
        intercheck:checkpoint)  echo "32" ;;
```

**Step 3: Test the modified orange case**

```bash
# Create a fake state file at orange-level pressure
echo '{"calls":100,"last_call_ts":'$(date +%s)',"pressure":95,"heavy_calls":40,"est_tokens":185000,"syntax_errors":0,"format_runs":0}' > /tmp/intercheck-test-cp.json
echo '{"session_id":"test-cp","tool_name":"Read","tool_output":"x"}' | bash plugins/intercheck/hooks/context-monitor.sh
```

Expected: Output includes "Context pressure is high" message.

**Step 4: Clean up test files**

```bash
rm -f /tmp/intercheck-test-cp.json /tmp/intercheck-intermem-checkpoint-test-cp
```

**Step 5: Commit**

```bash
git -C plugins/intercheck add hooks/context-monitor.sh
git -C infra/interband add lib/interband.sh
git -C plugins/intercheck commit -m "feat(intercheck): smart checkpoint triggers for intermem synthesis"
git -C infra/interband commit -m "feat(interband): add intercheck:checkpoint_needed payload validation"
```
NEW: ### Task 10: Smart Checkpoint Triggers

> **Review fixes applied:** [C2] interband.sh changes already in Task 1 — this task only modifies context-monitor.sh. [M7] Removed `python3` guard (code uses only bash/jq/stat). [M2] Removed hardcoded `/intermem:synthesize` — the interband signal is sufficient; consumers decide how to act. [L9] Removed unreliable `$(pwd)/.intermem` check — CWD not guaranteed to be project root. Checkpoint fires on pressure threshold alone. [H5] Atomic `mkdir` rate-limit instead of check-then-act `touch`. [L5] Added `interband_prune_channel`. Uses `_icm_` prefix (consistent with Task 1).
>
> **Dependency:** Requires Task 1's interband library sourcing block in context-monitor.sh. The `_icm_ib_lib` variable must be set by Task 1's code.

**Files:**
- Modify: `plugins/intercheck/hooks/context-monitor.sh` (at orange threshold)

**Step 1: Add checkpoint trigger at Orange threshold**

In `plugins/intercheck/hooks/context-monitor.sh`, modify the `orange` case (around line 89-91):

```bash
  orange)
    # Smart checkpoint: signal intermem via interband at orange pressure
    _icm_checkpoint_msg=""
    _icm_last_checkpoint="/tmp/intercheck-intermem-checkpoint-${SID}"
    # Atomic rate-limit: mkdir is POSIX-atomic on local filesystems
    _icm_cp_lock="/tmp/intercheck-cp-lock-${SID}"
    if [[ ! -f "$_icm_last_checkpoint" || $(( NOW - $(stat -c %Y "$_icm_last_checkpoint" 2>/dev/null || echo 0) )) -gt 900 ]]; then
      if mkdir "$_icm_cp_lock" 2>/dev/null; then
        touch "$_icm_last_checkpoint" 2>/dev/null || true
        rmdir "$_icm_cp_lock" 2>/dev/null || true
        # Signal intermem via interband (requires Task 1's interband sourcing)
        if [[ -n "${_icm_ib_lib:-}" ]]; then
          _icm_cp_payload=$(jq -n -c --argjson ts "$NOW" '{"trigger":"orange_pressure","ts":$ts}')
          _icm_cp_file=$(interband_path "intercheck" "checkpoint" "$SID" 2>/dev/null) || _icm_cp_file=""
          if [[ -n "$_icm_cp_file" ]]; then
            interband_write "$_icm_cp_file" "intercheck" "checkpoint_needed" "$SID" "$_icm_cp_payload" 2>/dev/null || true
            interband_prune_channel "intercheck" "checkpoint" 2>/dev/null || true
            _icm_checkpoint_msg=" Consider synthesizing session memory before continuing."
          fi
        fi
      fi
    fi
    jq -n --arg msg "Context pressure is high (pressure: $PRESSURE, ~${EST_TOKENS} tokens). Finish current work and commit. Avoid launching new subagents.${_icm_checkpoint_msg}" \
      '{"additionalContext": $msg}'
    ;;
```

**Step 2: Test the modified orange case**

```bash
# Create a fake state file at orange-level pressure
echo '{"calls":100,"last_call_ts":'$(date +%s)',"pressure":95,"heavy_calls":40,"est_tokens":185000,"syntax_errors":0,"format_runs":0}' > /tmp/intercheck-test-cp.json
echo '{"session_id":"test-cp","tool_name":"Read","tool_output":"x"}' | bash plugins/intercheck/hooks/context-monitor.sh
```

Expected: Output includes "Context pressure is high" message. If interband is available, check `~/.interband/intercheck/checkpoint/test-cp.json` was created.

**Step 3: Clean up test files**

```bash
rm -f /tmp/intercheck-test-cp.json /tmp/intercheck-intermem-checkpoint-test-cp /tmp/intercheck-cp-lock-test-cp ~/.interband/intercheck/checkpoint/test-cp.json
```

**Step 4: Commit**

```bash
git -C plugins/intercheck add hooks/context-monitor.sh && git -C plugins/intercheck commit -m "feat(intercheck): smart checkpoint triggers for intermem synthesis"
```

--- 2026-02-21T02:50:14Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: **Tech Stack:** Bash (hooks, interband library), JSON (interband envelopes, config), SQLite (interstat), jq (payload construction/parsing)

---

### Task 1: Register All Interband Signals + Add Pressure Publisher to intercheck
NEW: **Tech Stack:** Bash (hooks, interband library), JSON (interband envelopes, config), SQLite (interstat), jq (payload construction/parsing)

---

### Review Fixes Applied (2026-02-20)

Three review agents (architecture, correctness, quality) analyzed this plan. All fixes have been incorporated inline with `[ID]` tags tracing back to the findings. Summary of structural changes:

| ID | Severity | Fix |
|----|----------|-----|
| C1 | CRITICAL | Read `session_id` from stdin JSON, not phantom `CLAUDE_SESSION_ID` env var (Task 8) |
| C2 | CRITICAL | Consolidate all interband.sh changes into Task 1 (was split across Tasks 1, 2, 10) |
| H1 | HIGH | Use 5-candidate interband sourcing pattern from `lib-gates.sh` (Tasks 1, 2) |
| H2 | HIGH | Use heredoc for SQL queries, matching existing `post-task.sh` pattern (Task 2) |
| H3 | HIGH | Implement actual threshold-crossing logic with tier tracking (Task 2) |
| H4 | HIGH | Replace 30-char prefix dedup with agent-name-keyed session map (Task 9) |
| H5 | HIGH | Atomic `mkdir` rate-limit for checkpoint, atomic write for state (Task 10) |
| H6 | HIGH | Add `\|\| true` to all `source` calls under `set -euo pipefail` (Tasks 1, 2) |
| M1 | MEDIUM | Guard placement bug in stub template — set `_INTERBASE_LOADED=1` unconditionally (NOT in this plan — fix in `sdk/interbase/templates/interbase-stub.sh` before implementing) |
| M2 | MEDIUM | Remove hardcoded `/intermem:synthesize` from intercheck output (Task 10) |
| M3 | MEDIUM | Split Task 6 into four sub-tasks (6a-6d) for per-plugin rollback (Task 6) |
| M4 | MEDIUM | Rename `_ic_` temporaries to `_icm_` to avoid library namespace collision (Task 1) |
| M5 | MEDIUM | Source interband.sh for `interband_read_payload` envelope validation (Task 8) |
| M6 | MEDIUM | Add numeric guards on `INTERSTAT_TOKEN_BUDGET` and computed values (Task 2) |
| M7 | MEDIUM | Remove phantom `python3` guard around bash-only code (Task 10) |
| M8 | MEDIUM | Fix nudge `_ib_nudge_is_dismissed` jq-absent fallback: return 0 (silent), not 1 (fire always) — fix in interbase.sh, not this plan |
| M9 | MEDIUM | Replace destructive `mv ~/.intermod` test with `INTERMOD_LIB=/nonexistent` (Task 8) |
| C4 | SCOPE | Defer session-start hooks for plugins without concrete features (Task 6b-6d: integration.json only) |
| L1 | LOW | Use existing `$LEVEL` variable instead of duplicating thresholds (Task 1) |
| L2 | LOW | Add `set -euo pipefail` to all new session-start hooks (Tasks 4, 5, 6a) |
| L3 | LOW | Remove dead `_ic_interband_root` variable (Task 1) |
| L4 | LOW | Numeric guard on `_il_budget_int` against non-numeric strings (Task 3) |
| L5 | LOW | Add `interband_prune_channel` after writes (Tasks 1, 10) |
| L7 | LOW | Collapse multi-line for loops to one-liners (Task 6) |
| L8 | LOW | Add envelope structure validation to verify steps (Tasks 1, 2) |
| L9 | LOW | Remove unreliable `$(pwd)/.intermem` check; guard jq against non-array (Tasks 9, 10) |
| L10 | LOW | Cross-validate companion-graph.json edges against integration.json (Task 7) |
| L11 | LOW | Change Task 8 from "replace contents" to "append block" (Task 8) |

**Pre-implementation prerequisite (NOT in this plan):** Fix `_INTERBASE_LOADED=1` guard in `sdk/interbase/templates/interbase-stub.sh` — set unconditionally before live source attempt, not only in fallback path [M1]. Also fix `_ib_nudge_is_dismissed` jq-absent fallback to return 0 (treated as dismissed) instead of 1 [M8].

---

### Task 1: Register All Interband Signals + Add Pressure Publisher to intercheck

--- 2026-02-21T03:24:21Z | plugins/interchart/.github/workflows/regenerate.yml | CONTEXT:unknown ---
OLD:       - name: Generate diagram
        run: |
          node scripts/scan.js workspace > /tmp/scan.json
          NODE_COUNT=$(node -e "let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>console.log(JSON.parse(d).stats.nodes))" < /tmp/scan.json)
          EDGE_COUNT=$(node -e "let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>console.log(JSON.parse(d).stats.edges))" < /tmp/scan.json)
          echo "Scanned: ${NODE_COUNT} nodes, ${EDGE_COUNT} edges"

          node -e "
            const fs = require('fs');
            const tmpl = fs.readFileSync('templates/ecosystem.html', 'utf8');
            const data = fs.readFileSync('/tmp/scan.json', 'utf8');
            fs.writeFileSync('/tmp/index.html', tmpl.replace('/*DATA_PLACEHOLDER*/', data.trim()));
          "
          echo "Generated /tmp/index.html ($(wc -c < /tmp/index.html) bytes)"

      - name: Check for changes
        id: diff
        run: |
          if git show origin/gh-pages:index.html > /tmp/old.html 2>/dev/null; then
            OLD_NODES=$(grep -o '"nodes":[0-9]*' /tmp/old.html | head -1)
            NEW_NODES=$(grep -o '"nodes":[0-9]*' /tmp/index.html | head -1)
            OLD_EDGES=$(grep -o '"edges":[0-9]*' /tmp/old.html | head -1)
            NEW_EDGES=$(grep -o '"edges":[0-9]*' /tmp/index.html | head -1)
            if [ "$OLD_NODES" = "$NEW_NODES" ] && [ "$OLD_EDGES" = "$NEW_EDGES" ]; then
              echo "No structural changes (same node/edge counts)"
              echo "changed=false" >> "$GITHUB_OUTPUT"
            else
              echo "Changes: nodes $OLD_NODES -> $NEW_NODES, edges $OLD_EDGES -> $NEW_EDGES"
              echo "changed=true" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "No previous version — first deploy"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Deploy to gh-pages
        if: steps.diff.outputs.changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: /tmp
          keep_files: false
          include_files: index.html
NEW:       - name: Generate diagram
        run: |
          mkdir -p dist
          node scripts/scan.js workspace > dist/scan.json
          NODE_COUNT=$(node -e "let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>console.log(JSON.parse(d).stats.nodes))" < dist/scan.json)
          EDGE_COUNT=$(node -e "let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>console.log(JSON.parse(d).stats.edges))" < dist/scan.json)
          echo "Scanned: ${NODE_COUNT} nodes, ${EDGE_COUNT} edges"

          node -e "
            const fs = require('fs');
            const tmpl = fs.readFileSync('templates/ecosystem.html', 'utf8');
            const data = fs.readFileSync('dist/scan.json', 'utf8');
            fs.writeFileSync('dist/index.html', tmpl.replace('/*DATA_PLACEHOLDER*/', data.trim()));
          "
          rm dist/scan.json
          echo "Generated dist/index.html ($(wc -c < dist/index.html) bytes)"

      - name: Check for changes
        id: diff
        run: |
          if git show origin/gh-pages:index.html > /tmp/old.html 2>/dev/null; then
            OLD_NODES=$(grep -o '"nodes":[0-9]*' /tmp/old.html | head -1)
            NEW_NODES=$(grep -o '"nodes":[0-9]*' dist/index.html | head -1)
            OLD_EDGES=$(grep -o '"edges":[0-9]*' /tmp/old.html | head -1)
            NEW_EDGES=$(grep -o '"edges":[0-9]*' dist/index.html | head -1)
            if [ "$OLD_NODES" = "$NEW_NODES" ] && [ "$OLD_EDGES" = "$NEW_EDGES" ]; then
              echo "No structural changes (same node/edge counts)"
              echo "changed=false" >> "$GITHUB_OUTPUT"
            else
              echo "Changes: nodes $OLD_NODES -> $NEW_NODES, edges $OLD_EDGES -> $NEW_EDGES"
              echo "changed=true" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "No previous version — first deploy"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Deploy to gh-pages
        if: steps.diff.outputs.changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: dist
          keep_files: false

--- 2026-02-21T03:42:56Z | plugins/interchart/.github/workflows/regenerate.yml | CONTEXT:unknown ---
OLD:       - name: Assemble monorepo tree
        run: |
          mkdir -p workspace/plugins workspace/hub workspace/services workspace/sdk workspace/Interforge

          # Clone all plugin repos in parallel
          plugins=(
            intercheck intercraft interdev interdoc interfluence interflux
            interform interject interkasten interleave interlens interline
            interlock intermap intermem intermux internext interpath
            interpeer interphase interpub intersearch interserve interslack
            interstat intersynth intertest interwatch tldr-swinton tool-time
            tuivision
          )
          for p in "${plugins[@]}"; do
            git clone --depth 1 --single-branch "https://github.com/mistakeknot/${p}.git" "workspace/plugins/${p}" &
          done

          # Clone hub, services
          git clone --depth 1 --single-branch https://github.com/mistakeknot/Clavain.git workspace/os/clavain &
          git clone --depth 1 --single-branch https://github.com/mistakeknot/intermute.git workspace/services/intermute &

          # Wait for all clones to finish
          wait

          echo "Assembled $(ls workspace/plugins | wc -l) plugins + hub + services"
NEW:       - name: Discover repos
        id: discover
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch all public repos for mistakeknot (paginate)
          REPOS=$(gh api --paginate '/users/mistakeknot/repos?per_page=100&type=public' --jq '.[].name' | sort)
          echo "Found $(echo "$REPOS" | wc -l) repos total"

          # Classify repos into monorepo locations
          PLUGINS=""
          HUB=""
          SERVICES=""
          SKIP="Interverse interchart"

          for repo in $REPOS; do
            # Skip non-ecosystem repos
            case "$repo" in
              Interverse|interchart) continue ;;
            esac

            # Known fixed mappings
            case "$repo" in
              Clavain)   HUB="$repo"; continue ;;
              intermute) SERVICES="$repo"; continue ;;
            esac

            # Anything starting with inter* or known plugin names → plugin
            case "$repo" in
              inter*|tldr-swinton|tool-time|tuivision)
                PLUGINS="${PLUGINS} ${repo}"
                ;;
            esac
          done

          echo "Plugins:${PLUGINS}"
          echo "Hub: ${HUB}"
          echo "Services: ${SERVICES}"
          echo "plugins=${PLUGINS}" >> "$GITHUB_OUTPUT"
          echo "hub=${HUB}" >> "$GITHUB_OUTPUT"
          echo "services=${SERVICES}" >> "$GITHUB_OUTPUT"

      - name: Assemble monorepo tree
        run: |
          mkdir -p workspace/plugins workspace/hub workspace/services workspace/Interforge

          # Clone all discovered plugins in parallel
          for p in ${{ steps.discover.outputs.plugins }}; do
            git clone --depth 1 --single-branch "https://github.com/mistakeknot/${p}.git" "workspace/plugins/${p}" 2>/dev/null &
          done

          # Clone hub
          if [ -n "${{ steps.discover.outputs.hub }}" ]; then
            git clone --depth 1 --single-branch "https://github.com/mistakeknot/${{ steps.discover.outputs.hub }}.git" workspace/os/clavain 2>/dev/null &
          fi

          # Clone services
          if [ -n "${{ steps.discover.outputs.services }}" ]; then
            git clone --depth 1 --single-branch "https://github.com/mistakeknot/${{ steps.discover.outputs.services }}.git" workspace/services/intermute 2>/dev/null &
          fi

          wait

          PLUGIN_COUNT=$(ls workspace/plugins 2>/dev/null | wc -l)
          echo "Assembled ${PLUGIN_COUNT} plugins + hub + services"

--- 2026-02-21T03:43:08Z | README.md | CONTEXT:unknown ---
OLD: # Interverse

Monorepo for the inter-module ecosystem — Claude Code plugins, services, and infrastructure.

Each subproject keeps its own `.git` and GitHub repo. This monorepo provides shared scripts, co-location for development, and the plugin marketplace.
NEW: # Interverse

Monorepo for the inter-module ecosystem — Claude Code plugins, services, and infrastructure.

Each subproject keeps its own `.git` and GitHub repo. This monorepo provides shared scripts, co-location for development, and the plugin marketplace.

**[Interactive Ecosystem Diagram](https://mistakeknot.github.io/interchart/)** — explore how all plugins, skills, agents, and services connect. Auto-regenerates every 6 hours.

--- 2026-02-21T03:43:14Z | README.md | CONTEXT:unknown ---
OLD: | [intercheck](https://github.com/mistakeknot/intercheck) | 0.1.4 | Code quality guards and session health monitoring |
| [interdoc](https://github.com/mistakeknot/interdoc) | 5.1.0 | Recursive AGENTS.md generator with structural auto-fix, CLAUDE.md harmonization, and GPT critique |
NEW: | [interchart](https://github.com/mistakeknot/interchart) | 0.1.0 | Interactive ecosystem diagram — D3.js force graph of all plugins, skills, and relationships |
| [intercheck](https://github.com/mistakeknot/intercheck) | 0.1.4 | Code quality guards and session health monitoring |
| [interdoc](https://github.com/mistakeknot/interdoc) | 5.1.0 | Recursive AGENTS.md generator with structural auto-fix, CLAUDE.md harmonization, and GPT critique |

--- 2026-02-21T03:46:42Z | plugins/interchart/.github/workflows/regenerate.yml | CONTEXT:unknown ---
OLD: on:
  schedule:
    # Every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
NEW: on:
  schedule:
    # Every 6 hours as safety net
    - cron: '0 */6 * * *'
  repository_dispatch:
    types: [ecosystem-changed]
  workflow_dispatch:

--- 2026-02-21T03:46:47Z | plugins/interchart/.github/workflows/regenerate.yml | CONTEXT:unknown ---
OLD:         if: steps.diff.outputs.changed == 'true' || github.event_name == 'workflow_dispatch'
NEW:         if: steps.diff.outputs.changed == 'true' || github.event_name != 'schedule'

--- 2026-02-21T03:47:29Z | sdk/interbase/templates/interbase-stub.sh | CONTEXT:unknown ---
OLD: [[ -n "${_INTERBASE_LOADED:-}" ]] && return 0

# Try centralized copy first (ecosystem users)
# NOTE: Do NOT set _INTERBASE_LOADED before sourcing — the live copy sets its
# own guard. Setting it here would cause the live source to return immediately,
# skipping all function definitions.
_interbase_live="${INTERMOD_LIB:-${HOME}/.intermod/interbase/interbase.sh}"
if [[ -f "$_interbase_live" ]]; then
    _INTERBASE_SOURCE="live"
    source "$_interbase_live"
    return 0
fi

# Fallback: inline stubs (standalone users)
_INTERBASE_LOADED=1
_INTERBASE_SOURCE="stub"
NEW: [[ -n "${_INTERBASE_LOADED:-}" ]] && return 0
_INTERBASE_LOADED=1   # Set unconditionally before source attempt [M1]

# Try centralized copy first (ecosystem users)
_interbase_live="${INTERMOD_LIB:-${HOME}/.intermod/interbase/interbase.sh}"
if [[ -f "$_interbase_live" ]]; then
    _INTERBASE_SOURCE="live"
    source "$_interbase_live"
    return 0
fi

# Fallback: inline stubs (standalone users)
_INTERBASE_SOURCE="stub"

--- 2026-02-21T03:47:34Z | sdk/interbase/lib/interbase.sh | CONTEXT:unknown ---
OLD: _ib_nudge_is_dismissed() {
    local plugin="$1" companion="$2"
    local nf key
    nf="$(_ib_nudge_state_file)"
    [[ -f "$nf" ]] || return 1
    command -v jq &>/dev/null || return 1
NEW: _ib_nudge_is_dismissed() {
    local plugin="$1" companion="$2"
    local nf key
    nf="$(_ib_nudge_state_file)"
    [[ -f "$nf" ]] || return 1
    command -v jq &>/dev/null || return 0  # [M8] No jq → treat as dismissed (silent), not fire always

--- 2026-02-21T03:47:40Z | sdk/interbase/lib/interbase.sh | CONTEXT:unknown ---
OLD: _ib_nudge_session_count() {
    local sf
    sf="$(_ib_nudge_session_file)"
    [[ -f "$sf" ]] || { echo "0"; return; }
    command -v jq &>/dev/null || { echo "0"; return; }
NEW: _ib_nudge_session_count() {
    local sf
    sf="$(_ib_nudge_session_file)"
    [[ -f "$sf" ]] || { echo "0"; return; }
    command -v jq &>/dev/null || { echo "99"; return; }  # [M8] No jq → budget exhausted (silent)

--- 2026-02-21T03:48:15Z | infra/interband/lib/interband.sh | CONTEXT:unknown ---
OLD:         interlock:coordination_signal)
            echo "$payload_json" | jq -e '
                (.layer | type == "string" and length > 0) and
                (.icon | type == "string" and length > 0) and
                (.text | type == "string" and length > 0) and
                (.priority | type == "number" and . >= 0) and
                (.ts | type == "string" and length > 0)
            ' >/dev/null 2>&1 || return 1
            ;;
    esac
NEW:         interlock:coordination_signal)
            echo "$payload_json" | jq -e '
                (.layer | type == "string" and length > 0) and
                (.icon | type == "string" and length > 0) and
                (.text | type == "string" and length > 0) and
                (.priority | type == "number" and . >= 0) and
                (.ts | type == "string" and length > 0)
            ' >/dev/null 2>&1 || return 1
            ;;
        intercheck:context_pressure)
            echo "$payload_json" | jq -e '
                (.level | type == "string" and test("^(green|yellow|orange|red)$")) and
                (.pressure | type == "number" and . >= 0) and
                (.est_tokens | type == "number" and . >= 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
        interstat:budget_alert)
            echo "$payload_json" | jq -e '
                (.pct_consumed | type == "number" and . >= 0 and . <= 100) and
                (.total_tokens | type == "number" and . >= 0) and
                (.session_id | type == "string" and length > 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
        intercheck:checkpoint_needed)
            echo "$payload_json" | jq -e '
                (.trigger | type == "string" and length > 0) and
                (.ts | type == "number")
            ' >/dev/null 2>&1 || return 1
            ;;
    esac

--- 2026-02-21T03:48:23Z | infra/interband/lib/interband.sh | CONTEXT:unknown ---
OLD:         interphase:bead)       echo "86400" ;;  # 24h
        *)                     echo "86400" ;;
    esac
}

interband_default_max_files() {
    local namespace="${1:-}" channel="${2:-}"
    case "${namespace}:${channel}" in
        clavain:dispatch)      echo "128" ;;
        interlock:coordination) echo "256" ;;
        interphase:bead)       echo "256" ;;
        *)                     echo "256" ;;
NEW:         interphase:bead)        echo "86400" ;;  # 24h
        intercheck:pressure)   echo "3600" ;;   # 1h (ephemeral, per-session)
        interstat:budget)      echo "21600" ;;  # 6h
        intercheck:checkpoint) echo "3600" ;;   # 1h
        *)                     echo "86400" ;;
    esac
}

interband_default_max_files() {
    local namespace="${1:-}" channel="${2:-}"
    case "${namespace}:${channel}" in
        clavain:dispatch)       echo "128" ;;
        interlock:coordination) echo "256" ;;
        interphase:bead)        echo "256" ;;
        intercheck:pressure)    echo "64" ;;
        interstat:budget)       echo "64" ;;
        intercheck:checkpoint)  echo "32" ;;
        *)                      echo "256" ;;

--- 2026-02-21T03:48:42Z | plugins/intercheck/hooks/context-monitor.sh | CONTEXT:unknown ---
OLD: # Only emit output when a threshold is crossed
case "$LEVEL" in
NEW: # Write pressure level to interband for statusline and other consumers
_icm_ib_lib=""
_icm_repo_root="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || true)"
for _icm_ib_candidate in \
    "${INTERBAND_LIB:-}" \
    "${SCRIPT_DIR}/../../../infra/interband/lib/interband.sh" \
    "${SCRIPT_DIR}/../../../interband/lib/interband.sh" \
    "${_icm_repo_root}/../interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
  [[ -n "$_icm_ib_candidate" && -f "$_icm_ib_candidate" ]] && _icm_ib_lib="$_icm_ib_candidate" && break
done

if [[ -n "$_icm_ib_lib" ]]; then
  source "$_icm_ib_lib" || true

  _icm_ib_payload=$(jq -n -c \
    --arg level "${LEVEL:-green}" \
    --argjson pressure "$PRESSURE" \
    --argjson est_tokens "$EST_TOKENS" \
    --argjson ts "$NOW" \
    '{level:$level, pressure:$pressure, est_tokens:$est_tokens, ts:$ts}')
  _icm_ib_file=$(interband_path "intercheck" "pressure" "$SID" 2>/dev/null) || _icm_ib_file=""
  if [[ -n "$_icm_ib_file" ]]; then
    interband_write "$_icm_ib_file" "intercheck" "context_pressure" "$SID" "$_icm_ib_payload" 2>/dev/null || true
    interband_prune_channel "intercheck" "pressure" 2>/dev/null || true
  fi
fi

# Only emit output when a threshold is crossed
case "$LEVEL" in

--- 2026-02-21T03:49:21Z | plugins/intercheck/hooks/context-monitor.sh | CONTEXT:unknown ---
OLD: # Write pressure level to interband for statusline and other consumers
_icm_ib_lib=""
_icm_repo_root="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || true)"
for _icm_ib_candidate in \
    "${INTERBAND_LIB:-}" \
    "${SCRIPT_DIR}/../../../infra/interband/lib/interband.sh" \
    "${SCRIPT_DIR}/../../../interband/lib/interband.sh" \
    "${_icm_repo_root}/../interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
NEW: # Write pressure level to interband for statusline and other consumers
_icm_ib_lib=""
_icm_hooks_dir="$(cd "$(dirname "$0")" && pwd)"
_icm_repo_root="$(git -C "$_icm_hooks_dir" rev-parse --show-toplevel 2>/dev/null || true)"
for _icm_ib_candidate in \
    "${INTERBAND_LIB:-}" \
    "${_icm_hooks_dir}/../../../infra/interband/lib/interband.sh" \
    "${_icm_hooks_dir}/../../../interband/lib/interband.sh" \
    "${_icm_repo_root}/../interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do

--- 2026-02-21T03:52:34Z | plugins/interstat/hooks/post-task.sh | CONTEXT:unknown ---
OLD: exit 0
NEW: # Emit budget alert to interband if sprint budget tracking is active
_is_interband_lib=""
_is_repo_root="$(git -C "$(dirname "${BASH_SOURCE[0]}")" rev-parse --show-toplevel 2>/dev/null || true)"
for _is_lib_candidate in \
    "${INTERBAND_LIB:-}" \
    "$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../infra/interband/lib" 2>/dev/null && pwd)/interband.sh" \
    "$(cd "$(dirname "${BASH_SOURCE[0]}")/../../../interband/lib" 2>/dev/null && pwd)/interband.sh" \
    "${_is_repo_root}/../interband/lib/interband.sh" \
    "${HOME}/.local/share/interband/lib/interband.sh"; do
  [[ -n "$_is_lib_candidate" && -f "$_is_lib_candidate" ]] && _is_interband_lib="$_is_lib_candidate" && break
done

if [[ -n "$_is_interband_lib" && -n "$session_id" ]]; then
  source "$_is_interband_lib" || true

  # Query total tokens for this session (heredoc matches existing INSERT pattern)
  _is_total=$(sqlite3 "$DB_PATH" <<SQL 2>/dev/null || echo "0"
PRAGMA busy_timeout=5000;
SELECT COALESCE(SUM(result_length / 4), 0)
FROM agent_runs
WHERE session_id='$(printf "%s" "$session_id" | sed "s/'/''/g")';
SQL
  )

  # Guard against non-numeric values
  _is_budget="${INTERSTAT_TOKEN_BUDGET:-0}"
  [[ "$_is_budget" =~ ^[0-9]+$ ]] || _is_budget=0
  [[ "$_is_total" =~ ^[0-9]+$ ]] || _is_total=0

  if [[ "$_is_budget" -gt 0 && "$_is_total" -gt 0 ]]; then
    _is_pct=$(awk "BEGIN{printf \"%.1f\", ($_is_total / $_is_budget) * 100}" 2>/dev/null || echo "0")
    _is_pct_int="${_is_pct%.*}"
    [[ "$_is_pct_int" =~ ^[0-9]+$ ]] || _is_pct_int=0

    # Determine current tier
    _is_tier=""
    if [[ "$_is_pct_int" -ge 95 ]]; then _is_tier="critical"
    elif [[ "$_is_pct_int" -ge 80 ]]; then _is_tier="high"
    elif [[ "$_is_pct_int" -ge 50 ]]; then _is_tier="medium"
    fi

    # Only emit at threshold crossings (tier changes), not every event above 50%
    if [[ -n "$_is_tier" ]]; then
      _is_tier_file="/tmp/interstat-budget-tier-${session_id}"
      _is_last_tier=$(cat "$_is_tier_file" 2>/dev/null || echo "")
      if [[ "$_is_tier" != "$_is_last_tier" ]]; then
        printf '%s' "$_is_tier" > "$_is_tier_file" 2>/dev/null || true
        _is_ib_payload=$(jq -n -c \
          --argjson pct_consumed "$_is_pct" \
          --argjson total_tokens "$_is_total" \
          --arg session_id "$session_id" \
          --argjson ts "$(date +%s)" \
          '{pct_consumed:$pct_consumed, total_tokens:$total_tokens, session_id:$session_id, ts:$ts}')
        _is_ib_file=$(interband_path "interstat" "budget" "$session_id" 2>/dev/null) || _is_ib_file=""
        if [[ -n "$_is_ib_file" ]]; then
          interband_write "$_is_ib_file" "interstat" "budget_alert" "$session_id" "$_is_ib_payload" 2>/dev/null || true
        fi
      fi
    fi
  fi
fi

exit 0

--- 2026-02-21T03:53:26Z | plugins/interstat/hooks/post-task.sh | CONTEXT:unknown ---
OLD:   # Query total tokens for this session (heredoc matches existing INSERT pattern)
  _is_total=$(sqlite3 "$DB_PATH" <<SQL 2>/dev/null || echo "0"
PRAGMA busy_timeout=5000;
SELECT COALESCE(SUM(result_length / 4), 0)
FROM agent_runs
WHERE session_id='$(printf "%s" "$session_id" | sed "s/'/''/g")';
SQL
  )
NEW:   # Query total tokens for this session (-cmd separates PRAGMA from query output)
  _is_total=$(sqlite3 -cmd 'PRAGMA busy_timeout=5000' "$DB_PATH" \
    "SELECT COALESCE(SUM(result_length / 4), 0) FROM agent_runs WHERE session_id='$(printf "%s" "$session_id" | sed "s/'/''/g")';" \
    2>/dev/null || echo "0")

--- 2026-02-21T03:53:50Z | plugins/interstat/hooks/post-task.sh | CONTEXT:unknown ---
OLD:   # Query total tokens for this session (-cmd separates PRAGMA from query output)
  _is_total=$(sqlite3 -cmd 'PRAGMA busy_timeout=5000' "$DB_PATH" \
    "SELECT COALESCE(SUM(result_length / 4), 0) FROM agent_runs WHERE session_id='$(printf "%s" "$session_id" | sed "s/'/''/g")';" \
    2>/dev/null || echo "0")
NEW:   # Query total tokens for this session (.timeout is silent, unlike PRAGMA busy_timeout)
  _is_total=$(sqlite3 "$DB_PATH" ".timeout 5000" \
    "SELECT COALESCE(SUM(result_length / 4), 0) FROM agent_runs WHERE session_id='$(printf "%s" "$session_id" | sed "s/'/''/g")';" \
    2>/dev/null || echo "0")

--- 2026-02-21T03:54:17Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 2: Add Interband Budget Signal to interstat
NEW: ### Task 2: Add Interband Budget Signal to interstat [DONE]

--- 2026-02-21T03:56:45Z | plugins/interline/scripts/statusline.sh | CONTEXT:unknown ---
OLD:   context_display=" · $(_il_color "$ctx_color" "${pct_int}%")"
fi

# --- Build status line ---
NEW:   context_display=" · $(_il_color "$ctx_color" "${pct_int}%")"
fi

# --- Layer 4: Context pressure from intercheck interband signal ---
pressure_label=""
if _il_cfg_bool '.layers.pressure'; then
  if [ -n "$session_id" ]; then
    _il_pressure_file="$_il_interband_root/intercheck/pressure/${session_id}.json"
    if [ -f "$_il_pressure_file" ]; then
      _il_pressure_level=$(_il_interband_payload_field "$_il_pressure_file" "level")
      if [ -n "$_il_pressure_level" ] && [ "$_il_pressure_level" != "green" ]; then
        case "$_il_pressure_level" in
          yellow)  _il_pressure_color="${cfg_color_context_warn:-220}" ;;
          orange)  _il_pressure_color="208" ;;
          red)     _il_pressure_color="${cfg_color_context_critical:-196}" ;;
          *)       _il_pressure_color="245" ;;
        esac
        pressure_label="$(_il_color "$_il_pressure_color" "$_il_pressure_level")"
      fi
    fi
  fi
fi

# --- Layer 5: Budget alert from interstat interband signal ---
budget_label=""
if _il_cfg_bool '.layers.budget'; then
  if [ -n "$session_id" ]; then
    _il_budget_file="$_il_interband_root/interstat/budget/${session_id}.json"
    if [ -f "$_il_budget_file" ]; then
      _il_budget_pct=$(_il_interband_payload_field "$_il_budget_file" "pct_consumed")
      if [ -n "$_il_budget_pct" ]; then
        _il_budget_int="${_il_budget_pct%.*}"
        # Guard against non-numeric values (e.g., jq returning "null")
        case "$_il_budget_int" in ''|*[!0-9]*) _il_budget_int=0 ;; esac
        if [ "${_il_budget_int:-0}" -ge 80 ]; then
          _il_budget_color="${cfg_color_context_critical:-196}"
          budget_label="$(_il_color "$_il_budget_color" "${_il_budget_int}% budget")"
        elif [ "${_il_budget_int:-0}" -ge 50 ]; then
          _il_budget_color="${cfg_color_context_warn:-220}"
          budget_label="$(_il_color "$_il_budget_color" "${_il_budget_int}% budget")"
        fi
      fi
    fi
  fi
fi

# --- Build status line ---

--- 2026-02-21T03:56:54Z | plugins/interline/scripts/statusline.sh | CONTEXT:unknown ---
OLD:   if [ -n "$phase_label" ]; then
    status_line="$status_line${sep}$phase_label"
  fi
fi

echo -e "$status_line"
NEW:   if [ -n "$phase_label" ]; then
    status_line="$status_line${sep}$phase_label"
  fi
fi

# Append ambient indicators (always visible, independent of dispatch/coord/bead)
if [ -n "$pressure_label" ]; then
  status_line="$status_line${sep}$pressure_label"
fi
if [ -n "$budget_label" ]; then
  status_line="$status_line${sep}$budget_label"
fi

echo -e "$status_line"

--- 2026-02-21T03:57:24Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 3: Enrich interline Statusline with Pressure and Budget
NEW: ### Task 3: Enrich interline Statusline with Pressure and Budget [DONE]

--- 2026-02-21T03:59:01Z | sdk/interbase/templates/interbase-stub.sh | CONTEXT:unknown ---
OLD: [[ -n "${_INTERBASE_LOADED:-}" ]] && return 0
_INTERBASE_LOADED=1   # Set unconditionally before source attempt [M1]

# Try centralized copy first (ecosystem users)
_interbase_live="${INTERMOD_LIB:-${HOME}/.intermod/interbase/interbase.sh}"
if [[ -f "$_interbase_live" ]]; then
    _INTERBASE_SOURCE="live"
    source "$_interbase_live"
    return 0
fi

# Fallback: inline stubs (standalone users)
_INTERBASE_SOURCE="stub"
NEW: [[ -n "${_INTERBASE_LOADED:-}" ]] && return 0

# Try centralized copy first (ecosystem users)
# NOTE: Do NOT set _INTERBASE_LOADED before sourcing — the live copy
# sets it itself. Setting it here would trigger the live copy's guard.
_interbase_live="${INTERMOD_LIB:-${HOME}/.intermod/interbase/interbase.sh}"
if [[ -f "$_interbase_live" ]]; then
    _INTERBASE_SOURCE="live"
    source "$_interbase_live"
    return 0
fi

# Fallback: inline stubs (standalone users)
_INTERBASE_LOADED=1
_INTERBASE_SOURCE="stub"

--- 2026-02-21T04:00:43Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 4: Interbase SDK Adoption — interline
NEW: ### Task 4: Interbase SDK Adoption — interline [DONE]

--- 2026-02-21T04:00:44Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 5: Interbase SDK Adoption — intersynth
NEW: ### Task 5: Interbase SDK Adoption — intersynth [DONE]

--- 2026-02-21T04:00:45Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 6: Interbase SDK Adoption — intermem, intertest, internext, tool-time
NEW: ### Task 6: Interbase SDK Adoption — intermem, intertest, internext, tool-time [DONE]

--- 2026-02-21T04:01:25Z | companion-graph.json | CONTEXT:unknown ---
OLD:     {
      "from": "intersynth",
      "to": "interflux",
      "relationship": "enhances",
      "benefit": "Enables multi-agent review verdict consumption"
    }
  ]
}
NEW:     {
      "from": "intersynth",
      "to": "interflux",
      "relationship": "enhances",
      "benefit": "Enables multi-agent review verdict consumption"
    },
    {
      "from": "interflux",
      "to": "interphase",
      "relationship": "enhances",
      "benefit": "Phase tracking on review completion"
    },
    {
      "from": "intersynth",
      "to": "interphase",
      "relationship": "enhances",
      "benefit": "Sprint-aware verdict linking"
    },
    {
      "from": "intertest",
      "to": "intercheck",
      "relationship": "enhances",
      "benefit": "Syntax error stream feeds debugging discipline"
    },
    {
      "from": "tool-time",
      "to": "interstat",
      "relationship": "enhances",
      "benefit": "Cross-reference usage patterns with token metrics"
    }
  ]
}

--- 2026-02-21T04:01:40Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 7: Companion Plugin Dependency Graph
NEW: ### Task 7: Companion Plugin Dependency Graph [DONE]

--- 2026-02-21T04:02:51Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 8: Cost-Aware Review Depth — Always-On Budget Signal
NEW: ### Task 8: Cost-Aware Review Depth — Always-On Budget Signal [DONE]

--- 2026-02-21T04:03:20Z | plugins/intersynth/hooks/lib-verdict.sh | CONTEXT:unknown ---
OLD:     echo "$total"
}
NEW:     echo "$total"
}

# Auto-create beads for critical verdict findings (opt-in via INTERSYNTH_AUTO_BEAD=true)
verdict_auto_create_beads() {
    [[ "${INTERSYNTH_AUTO_BEAD:-}" == "true" ]] || return 0
    command -v bd >/dev/null 2>&1 || return 0

    local verdicts_dir="${1:-${VERDICT_DIR}}"
    [[ -d "$verdicts_dir" ]] || return 0

    # Session-scoped dedup map: agent-name → bead-id
    # Uses agent name (filename without .json) as stable key, not summary text
    local session_id="${CLAUDE_SESSION_ID:-$$}"
    local bead_map="/tmp/intersynth-bead-map-${session_id}.json"
    [[ -f "$bead_map" ]] || echo '{}' > "$bead_map"

    local created=0
    for verdict_file in "$verdicts_dir"/*.json; do
        [[ -f "$verdict_file" ]] || continue

        local status agent summary agent_key
        status=$(jq -r '.status // ""' "$verdict_file" 2>/dev/null)
        [[ "$status" == "NEEDS_ATTENTION" ]] || continue

        agent=$(jq -r '.agent // "unknown"' "$verdict_file" 2>/dev/null)
        summary=$(jq -r '.summary // ""' "$verdict_file" 2>/dev/null)
        [[ -n "$summary" ]] || continue

        # Dedup key: agent name from filename (stable identifier)
        agent_key="$(basename "$verdict_file" .json)"

        # Check session map first (O(1), no bd call)
        local mapped_id
        mapped_id=$(jq -r --arg k "$agent_key" '.[$k] // empty' "$bead_map" 2>/dev/null)
        [[ -z "$mapped_id" ]] || continue

        # Fallback: check open beads with longer prefix (50 chars) and status filter
        local title="Review finding: ${summary:0:60}"
        local existing
        existing=$(bd list --status=open --json --quiet 2>/dev/null \
          | jq -r --arg prefix "${summary:0:50}" \
            'if type == "array" then [.[] | select(.title | tostring | contains($prefix))] | length else 0 end' \
          2>/dev/null || echo "0")
        [[ "$existing" -eq 0 ]] || continue

        # Create bead
        local new_id
        new_id=$(bd create --title="$title" --type=task --priority=1 --description="From $agent review. $summary" 2>&1 | grep -oE 'iv-[a-z0-9]+' || echo "")
        if [[ -n "$new_id" ]]; then
            # Record in session map to prevent duplicates on re-invocation
            local tmp_map
            tmp_map=$(mktemp "${bead_map}.XXXXXX") || continue
            jq --arg k "$agent_key" --arg v "$new_id" '. + {($k): $v}' "$bead_map" > "$tmp_map" 2>/dev/null && mv -f "$tmp_map" "$bead_map" || rm -f "$tmp_map"
            created=$((created + 1))
        fi
    done

    if [[ "$created" -gt 0 ]]; then
        echo "[intersynth] Auto-created $created beads from critical verdict findings" >&2
    fi
}

--- 2026-02-21T04:03:54Z | plugins/intercheck/hooks/context-monitor.sh | CONTEXT:unknown ---
OLD:   orange)
    jq -n --arg msg "Context pressure is high (pressure: $PRESSURE, ~${EST_TOKENS} tokens). Finish current work and commit. Avoid launching new subagents." \
      '{"additionalContext": $msg}'
    ;;
NEW:   orange)
    # Smart checkpoint: signal intermem via interband at orange pressure
    _icm_checkpoint_msg=""
    _icm_last_checkpoint="/tmp/intercheck-intermem-checkpoint-${SID}"
    # Atomic rate-limit: mkdir is POSIX-atomic on local filesystems
    _icm_cp_lock="/tmp/intercheck-cp-lock-${SID}"
    if [[ ! -f "$_icm_last_checkpoint" || $(( NOW - $(stat -c %Y "$_icm_last_checkpoint" 2>/dev/null || echo 0) )) -gt 900 ]]; then
      if mkdir "$_icm_cp_lock" 2>/dev/null; then
        touch "$_icm_last_checkpoint" 2>/dev/null || true
        rmdir "$_icm_cp_lock" 2>/dev/null || true
        # Signal intermem via interband (requires Task 1's interband sourcing)
        if [[ -n "${_icm_ib_lib:-}" ]]; then
          _icm_cp_payload=$(jq -n -c --argjson ts "$NOW" '{"trigger":"orange_pressure","ts":$ts}')
          _icm_cp_file=$(interband_path "intercheck" "checkpoint" "$SID" 2>/dev/null) || _icm_cp_file=""
          if [[ -n "$_icm_cp_file" ]]; then
            interband_write "$_icm_cp_file" "intercheck" "checkpoint_needed" "$SID" "$_icm_cp_payload" 2>/dev/null || true
            interband_prune_channel "intercheck" "checkpoint" 2>/dev/null || true
            _icm_checkpoint_msg=" Consider synthesizing session memory before continuing."
          fi
        fi
      fi
    fi
    jq -n --arg msg "Context pressure is high (pressure: $PRESSURE, ~${EST_TOKENS} tokens). Finish current work and commit. Avoid launching new subagents.${_icm_checkpoint_msg}" \
      '{"additionalContext": $msg}'
    ;;

--- 2026-02-21T04:04:30Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 9: Verdict-to-Bead Bridge (Opt-in)
NEW: ### Task 9: Verdict-to-Bead Bridge (Opt-in) [DONE]

--- 2026-02-21T04:04:31Z | docs/plans/2026-02-20-plugin-synergy-interop.md | CONTEXT:unknown ---
OLD: ### Task 10: Smart Checkpoint Triggers
NEW: ### Task 10: Smart Checkpoint Triggers [DONE]

--- 2026-02-21T04:10:08Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  background: #161b22;
  border-bottom: 1px solid #30363d;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}

#toolbar .title {
  font-weight: 600;
  font-size: 14px;
  color: #f0f6fc;
  margin-right: 12px;
  white-space: nowrap;
}

#toolbar .stats {
  font-size: 11px;
  color: #8b949e;
  margin-right: 12px;
  white-space: nowrap;
}

.filter-btn {
  border: 1px solid #30363d;
  background: transparent;
  color: #8b949e;
  padding: 3px 10px;
  border-radius: 12px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}

.filter-btn.active {
  border-color: var(--type-color);
  color: var(--type-color);
  background: color-mix(in srgb, var(--type-color) 12%, transparent);
}

.filter-btn:hover { border-color: #58a6ff; }

.filter-btn.meta {
  font-weight: 600;
  border-color: #58a6ff;
  color: #58a6ff;
}

.filter-btn.meta:hover { background: rgba(88, 166, 255, 0.1); }

#graph { width: 100vw; height: 100vh; padding-top: 44px; }
#graph svg { width: 100%; height: 100%; }
NEW: #toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  background: #161b22;
  border-bottom: 1px solid #30363d;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  height: 44px;
}

#toolbar .title {
  font-weight: 600;
  font-size: 14px;
  color: #f0f6fc;
  white-space: nowrap;
}

#toolbar .stats {
  font-size: 11px;
  color: #8b949e;
  white-space: nowrap;
}

#filter-sidebar {
  position: fixed;
  top: 44px;
  left: 0;
  width: 180px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

#filter-sidebar .sidebar-title {
  font-size: 11px;
  font-weight: 600;
  color: #8b949e;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 4px;
}

#filter-sidebar .meta-row {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
}

.filter-btn {
  border: 1px solid #30363d;
  background: transparent;
  color: #8b949e;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 6px;
}

.filter-btn .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.filter-btn.active {
  border-color: var(--type-color);
  color: var(--type-color);
  background: color-mix(in srgb, var(--type-color) 12%, transparent);
}

.filter-btn:hover { border-color: #58a6ff; }

.filter-btn.meta {
  font-weight: 600;
  border-color: #58a6ff;
  color: #58a6ff;
  width: auto;
  flex: 1;
  text-align: center;
  justify-content: center;
}

.filter-btn.meta:hover { background: rgba(88, 166, 255, 0.1); }

#search-box {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  padding: 4px 10px; border-radius: 6px; font-size: 12px;
  width: 160px; margin-left: auto;
}
#search-box:focus { outline: none; border-color: #58a6ff; }

#graph { width: 100vw; height: 100vh; padding-top: 44px; padding-left: 180px; }
#graph svg { width: 100%; height: 100%; }

--- 2026-02-21T04:12:12Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div id="toolbar">
  <span class="title">Interverse Ecosystem</span>
  <span class="stats" id="stats"></span>
  <button class="filter-btn meta" onclick="showAll()">All</button>
  <button class="filter-btn meta" onclick="hideAll()">None</button>
  <button class="filter-btn meta" id="overlap-toggle" onclick="toggleOverlapEdges()">Overlap Edges: On</button>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<div id="graph"></div>
NEW: <div id="toolbar">
  <span class="title">Interverse Ecosystem</span>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<div id="filter-sidebar">
  <div class="sidebar-title">Filters</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAll()">All</button>
    <button class="filter-btn meta" onclick="hideAll()">None</button>
  </div>
  <button class="filter-btn meta" id="overlap-toggle" onclick="toggleOverlapEdges()">Overlaps: On</button>
  <div id="filter-list"></div>
</div>

<div id="graph"></div>

--- 2026-02-21T04:12:19Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // Build filter buttons
const toolbar = document.getElementById('toolbar');
const searchBox = document.getElementById('search-box');
for (const [type, color] of Object.entries(TYPE_COLORS)) {
  const count = data.stats.byType[type] || 0;
  if (count === 0) continue;
  const btn = document.createElement('button');
  btn.className = 'filter-btn active';
  btn.style.setProperty('--type-color', color);
  btn.textContent = TYPE_LABELS[type] + ' (' + count + ')';
  btn.dataset.type = type;
  btn.onclick = function() { toggleFilter(type, btn); };
  toolbar.insertBefore(btn, searchBox);
}
NEW: // Build filter buttons into sidebar
const filterList = document.getElementById('filter-list');
for (const [type, color] of Object.entries(TYPE_COLORS)) {
  const count = data.stats.byType[type] || 0;
  if (count === 0) continue;
  const btn = document.createElement('button');
  btn.className = 'filter-btn active';
  btn.style.setProperty('--type-color', color);
  const dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  btn.appendChild(document.createTextNode(TYPE_LABELS[type] + ' (' + count + ')'));
  btn.dataset.type = type;
  btn.onclick = function() { toggleFilter(type, btn); };
  filterList.appendChild(btn);
}

--- 2026-02-21T04:12:23Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: .legend {
  position: fixed; bottom: 12px; left: 12px;
NEW: .legend {
  position: fixed; bottom: 12px; left: 192px;

--- 2026-02-21T04:12:29Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #detail-panel .meta-item span { color: #c9d1d9; }

#search-box {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  padding: 4px 10px; border-radius: 6px; font-size: 12px;
  width: 160px; margin-left: auto;
}
#search-box:focus { outline: none; border-color: #58a6ff; }

.legend {
NEW: #detail-panel .meta-item span { color: #c9d1d9; }

.legend {

--- 2026-02-21T04:12:35Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // D3 Setup
const width = window.innerWidth;
const height = window.innerHeight - 44;
NEW: // D3 Setup
const sidebarWidth = 180;
const width = window.innerWidth;
const height = window.innerHeight - 44;

--- 2026-02-21T04:12:38Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   .force('center', d3.forceCenter(width / 2, height / 2))
NEW:   .force('center', d3.forceCenter((width - sidebarWidth) / 2 + sidebarWidth, height / 2))

--- 2026-02-21T04:12:44Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   var scale = 0.8 / Math.max(bounds.width / width, bounds.height / height);
  var midX = bounds.x + bounds.width / 2;
  var midY = bounds.y + bounds.height / 2;
  svg.transition().duration(750).call(
    zoomBehavior.transform,
    d3.zoomIdentity.translate(width / 2 - scale * midX, height / 2 - scale * midY).scale(scale)
NEW:   var graphWidth = width - sidebarWidth;
  var scale = 0.8 / Math.max(bounds.width / graphWidth, bounds.height / height);
  var midX = bounds.x + bounds.width / 2;
  var midY = bounds.y + bounds.height / 2;
  svg.transition().duration(750).call(
    zoomBehavior.transform,
    d3.zoomIdentity.translate(graphWidth / 2 + sidebarWidth - scale * midX, height / 2 - scale * midY).scale(scale)

--- 2026-02-21T04:12:50Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #filter-sidebar .meta-row {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
}
NEW: #filter-sidebar .meta-row {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
}

#filter-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  border-top: 1px solid #30363d;
  padding-top: 8px;
}

--- 2026-02-21T04:18:07Z | docs/research/architecture-review-of-prd.md | CONTEXT:unknown ---
OLD: # Architecture Review: intercore PRD

**Date:** 2026-02-17
**Document:** `/root/projects/Interverse/docs/prds/2026-02-17-intercore-state-database.md`
**Reviewer:** Claude Opus 4.6 (Architecture & Design)
NEW: # Architecture Review: B1 Static Routing Table PRD

**PRD:** `/root/projects/Interverse/os/clavain/docs/prds/2026-02-20-static-routing-table.md`
**Brainstorm:** `/root/projects/Interverse/os/clavain/docs/brainstorms/2026-02-20-static-routing-table-brainstorm.md`
**Date:** 2026-02-20
**Reviewer:** fd-architecture (Flux-drive Architecture & Design Reviewer)
**Full verdict:** `/root/projects/Interverse/.clavain/verdicts/fd-architecture.md`

--- 2026-02-21T04:18:47Z | docs/research/correctness-review-of-prd.md | CONTEXT:unknown ---
OLD: # Correctness Review: PRD iv-8jpf — Reflect Phase Sprint Integration

**Reviewed:** 2026-02-20
**Document:** `/root/projects/Interverse/docs/prds/2026-02-20-reflect-phase-sprint-integration.md`
**Reviewer role:** Flux-drive Correctness (data integrity, phase state machines, gate logic)
NEW: # Correctness Review: PRD B1 — Static Routing Table (2026-02-20)

> Note: This file was previously used for a different PRD review (reflect-phase-sprint-integration).
> That content is superseded by this B1 routing table review.

**Source PRD:** `/root/projects/Interverse/os/clavain/docs/prds/2026-02-20-static-routing-table.md`
**Brainstorm:** `/root/projects/Interverse/os/clavain/docs/brainstorms/2026-02-20-static-routing-table-brainstorm.md`
**Verdict file:** `/root/projects/Interverse/os/clavain/.clavain/verdicts/fd-correctness.md`
**Reviewer:** fd-correctness (Julik, Flux-drive Correctness Reviewer)
**Date:** 2026-02-20

---

See full analysis in the verdict file above. Summary of findings:

## Invariants Under Review

1. **Resolution determinism** — Same (phase, category, agent) inputs must always return the same model.
2. **Fail-closed on bad config** — Missing or malformed `routing.yaml` must not silently produce a wrong model.
3. **`inherit` is not a model name** — The sentinel must be intercepted before reaching external dispatch APIs.
4. **YAML parser correctness** — The awk/sed parser must not silently misparse legal YAML.
5. **No TOCTOU on the config file** — Concurrent writes by model-routing and reads by resolve_model must not produce partial reads.
6. **Migration atomicity** — Deleting `tiers.yaml` must not occur before `lib-routing.sh` is verified working.
7. **Companion routing is explicit** — Removing companion agent frontmatter without a replacement mechanism must not silently drop model selection.

## Summary Table

| # | Finding | Severity | Invariant Broken |
|---|---------|----------|-----------------|
| 1 | Phase with `categories` block, caller omits `--category` — undefined behavior | HIGH | Resolution determinism |
| 2 | `inherit` sentinel not intercepted; quality mode overrides only defaults.model | CRITICAL | `inherit` is not a model name |
| 3 | Comment stripping absent; regex metachar injection; multi-level parse unspecified | HIGH | YAML parser correctness |
| 4 | Silent fallback on valid-but-wrong YAML indistinguishable from key-not-found | MEDIUM | Fail-closed on bad config |
| 5 | Concurrent read/write of routing.yaml — partial read window | MEDIUM | No TOCTOU on config file |
| 6 | Companion agents lose model selection with no replacement mechanism | HIGH | Companion routing is explicit |
| 7 | `--agent` without `--phase` has ambiguous fallthrough | MEDIUM | Resolution determinism |
| 8 | Dispatch fallback chain implementation not specified | LOW-MEDIUM | Migration atomicity |

---

## Previous Review (archived below — Reflect Phase Sprint Integration)

The following content is the previous review of PRD iv-8jpf. Kept for reference.

---

# Correctness Review: PRD iv-8jpf — Reflect Phase Sprint Integration

**Reviewed:** 2026-02-20
**Document:** `/root/projects/Interverse/docs/prds/2026-02-20-reflect-phase-sprint-integration.md`
**Reviewer role:** Flux-drive Correctness (data integrity, phase state machines, gate logic)

--- 2026-02-21T04:24:23Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: .link.overlaps-with { stroke: #FF6B6B; stroke-dasharray: 6 3; stroke-width: 2.2; stroke-opacity: 0.85; }
.link.part-of { stroke: #30363d; }
NEW: .link.part-of { stroke: #30363d; }

.domain-hull {
  fill-opacity: 0.08;
  stroke-opacity: 0.35;
  stroke-width: 1.5;
  stroke-dasharray: 6 3;
  pointer-events: none;
  transition: fill-opacity 0.3s, stroke-opacity 0.3s;
}
.domain-hull:hover { fill-opacity: 0.14; stroke-opacity: 0.5; }
.domain-hull.hidden { fill-opacity: 0; stroke-opacity: 0; }

.domain-label {
  font-size: 9px;
  font-weight: 600;
  fill-opacity: 0.4;
  pointer-events: none;
  text-anchor: middle;
}

--- 2026-02-21T04:24:29Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   <button class="filter-btn meta" id="overlap-toggle" onclick="toggleOverlapEdges()">Overlap Edges: On</button>
  <button class="filter-btn meta" id="overlap-only-toggle" onclick="toggleOverlapOnly()">Only Overlaps: Off</button>
  <div id="filter-list"></div>
NEW:   <div id="filter-list"></div>
  <div class="sidebar-title" style="margin-top: 12px">Domains</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAllDomains()">All</button>
    <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
  </div>
  <div id="domain-list"></div>

--- 2026-02-21T04:24:36Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // State
const activeFilters = new Set(Object.keys(TYPE_COLORS));
let selectedNode = null;
let searchQuery = '';
let showOverlapEdges = true;
let overlapOnlyMode = false;
NEW: // State
const activeFilters = new Set(Object.keys(TYPE_COLORS));
let selectedNode = null;
let searchQuery = '';

--- 2026-02-21T04:24:47Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: const graphNodes = data.nodes.map(function(n) { return Object.assign({}, n); });
const graphLinks = data.edges.map(function(e) { return Object.assign({}, e); });
const overlapNodeIds = new Set();
graphLinks.forEach(function(l) {
  if (l.type === 'overlaps-with') {
    overlapNodeIds.add(getNodeId(l.source));
    overlapNodeIds.add(getNodeId(l.target));
  }
});
NEW: const graphNodes = data.nodes.map(function(n) { return Object.assign({}, n); });
const graphLinks = data.edges.filter(function(e) { return e.type !== 'overlaps-with'; })
  .map(function(e) { return Object.assign({}, e); });

// Build domain groups from overlap edges
const domainMembers = {};  // domain -> Set of node IDs
data.edges.forEach(function(e) {
  if (e.type !== 'overlaps-with' || !e.meta || !e.meta.domains) return;
  e.meta.domains.forEach(function(domain) {
    if (!domainMembers[domain]) domainMembers[domain] = new Set();
    domainMembers[domain].add(e.source);
    domainMembers[domain].add(e.target);
  });
});

const DOMAIN_COLORS = {};
const DOMAIN_PALETTE = [
  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
  '#DDA0DD', '#FF8C42', '#98D8C8', '#F7DC6F', '#BB8FCE',
  '#85C1E9'
];
var domainNames = Object.keys(domainMembers).sort();
domainNames.forEach(function(name, i) {
  DOMAIN_COLORS[name] = DOMAIN_PALETTE[i % DOMAIN_PALETTE.length];
});

const DOMAIN_LABELS = {};
domainNames.forEach(function(name) {
  DOMAIN_LABELS[name] = name.replace(/-/g, ' ').replace(/\b\w/g, function(c) { return c.toUpperCase(); });
});

const activeDomains = new Set(domainNames);

--- 2026-02-21T04:24:54Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // D3 Setup
const sidebarWidth = 180;
NEW: // Build domain toggle buttons
var domainList = document.getElementById('domain-list');
domainNames.forEach(function(domain) {
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  var color = DOMAIN_COLORS[domain];
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  var count = domainMembers[domain].size;
  btn.appendChild(document.createTextNode(DOMAIN_LABELS[domain] + ' (' + count + ')'));
  btn.dataset.domain = domain;
  btn.onclick = function() { toggleDomain(domain, btn); };
  domainList.appendChild(btn);
});

// D3 Setup
const sidebarWidth = 180;

--- 2026-02-21T04:25:01Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: const svg = d3.select('#graph').append('svg').attr('width', width).attr('height', height);
const g = svg.append('g');
NEW: const svg = d3.select('#graph').append('svg').attr('width', width).attr('height', height);
const g = svg.append('g');

// Hull layer (drawn first = behind everything)
const hullGroup = g.append('g').attr('class', 'hulls');
const hullLabelGroup = g.append('g').attr('class', 'hull-labels');

--- 2026-02-21T04:25:03Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD: # --- Find routing.yaml ---
_routing_find_config() {
  local script_dir
  script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local source_dir="${CLAVAIN_SOURCE_DIR:-${CLAVAIN_DIR:-}}"

  # 1. Relative to this script
  if [[ -f "$script_dir/../config/routing.yaml" ]]; then
NEW: # --- Find routing.yaml ---
_routing_find_config() {
  # 0. Explicit env var override
  if [[ -n "${CLAVAIN_ROUTING_CONFIG:-}" && -f "$CLAVAIN_ROUTING_CONFIG" ]]; then
    echo "$CLAVAIN_ROUTING_CONFIG"
    return 0
  fi

  local script_dir
  script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local source_dir="${CLAVAIN_SOURCE_DIR:-${CLAVAIN_DIR:-}}"

  # 1. Relative to this script
  if [[ -f "$script_dir/../config/routing.yaml" ]]; then

--- 2026-02-21T04:25:19Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: simulation.on('tick', function() {
  link.attr('x1', function(d) { return d.source.x; })
    .attr('y1', function(d) { return d.source.y; })
    .attr('x2', function(d) { return d.target.x; })
    .attr('y2', function(d) { return d.target.y; });
  node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
});
NEW: // Convex hull helper — takes [[x,y], ...], returns expanded hull path string
function computeHullPath(points, padding) {
  if (points.length < 2) return null;
  if (points.length === 2) {
    // Two-point "hull": draw a rounded rect between them
    var dx = points[1][0] - points[0][0];
    var dy = points[1][1] - points[0][1];
    var len = Math.sqrt(dx * dx + dy * dy) || 1;
    var nx = -dy / len * padding;
    var ny = dx / len * padding;
    return 'M' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'L' + (points[1][0] + nx) + ',' + (points[1][1] + ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[1][0] - nx) + ',' + (points[1][1] - ny) +
      'L' + (points[0][0] - nx) + ',' + (points[0][1] - ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'Z';
  }
  var hull = d3.polygonHull(points);
  if (!hull) return null;
  // Expand hull outward by padding
  var cx = d3.mean(hull, function(p) { return p[0]; });
  var cy = d3.mean(hull, function(p) { return p[1]; });
  var expanded = hull.map(function(p) {
    var dx = p[0] - cx;
    var dy = p[1] - cy;
    var dist = Math.sqrt(dx * dx + dy * dy) || 1;
    return [p[0] + dx / dist * padding, p[1] + dy / dist * padding];
  });
  return 'M' + expanded.map(function(p) { return p[0] + ',' + p[1]; }).join('L') + 'Z';
}

// Build node lookup for fast access
var nodeById = {};
graphNodes.forEach(function(n) { nodeById[n.id] = n; });

function updateHulls() {
  var hullData = [];
  domainNames.forEach(function(domain) {
    if (!activeDomains.has(domain)) return;
    var points = [];
    domainMembers[domain].forEach(function(id) {
      var n = nodeById[id];
      if (n && activeFilters.has(n.type)) points.push([n.x, n.y]);
    });
    if (points.length >= 2) {
      hullData.push({ domain: domain, points: points, color: DOMAIN_COLORS[domain] });
    }
  });

  var hulls = hullGroup.selectAll('path').data(hullData, function(d) { return d.domain; });
  hulls.exit().remove();
  hulls.enter().append('path')
    .attr('class', 'domain-hull')
    .merge(hulls)
    .attr('fill', function(d) { return d.color; })
    .attr('stroke', function(d) { return d.color; })
    .attr('d', function(d) { return computeHullPath(d.points, 30); });

  var labels = hullLabelGroup.selectAll('text').data(hullData, function(d) { return d.domain; });
  labels.exit().remove();
  labels.enter().append('text')
    .attr('class', 'domain-label')
    .merge(labels)
    .attr('fill', function(d) { return d.color; })
    .attr('x', function(d) { return d3.mean(d.points, function(p) { return p[0]; }); })
    .attr('y', function(d) { return d3.min(d.points, function(p) { return p[1]; }) - 35; })
    .text(function(d) { return DOMAIN_LABELS[d.domain]; });
}

simulation.on('tick', function() {
  link.attr('x1', function(d) { return d.source.x; })
    .attr('y1', function(d) { return d.source.y; })
    .attr('x2', function(d) { return d.target.x; })
    .attr('y2', function(d) { return d.target.y; });
  node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  updateHulls();
});

--- 2026-02-21T04:25:27Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function toggleOverlapEdges() {
  showOverlapEdges = !showOverlapEdges;
  var btn = document.getElementById('overlap-toggle');
  btn.textContent = 'Overlap Edges: ' + (showOverlapEdges ? 'On' : 'Off');
  if (!showOverlapEdges && overlapOnlyMode) {
    overlapOnlyMode = false;
    var onlyBtn = document.getElementById('overlap-only-toggle');
    onlyBtn.textContent = 'Only Overlaps: Off';
  }
  applyFilters();
}

function toggleOverlapOnly() {
  overlapOnlyMode = !overlapOnlyMode;
  if (overlapOnlyMode) showOverlapEdges = true;
  document.getElementById('overlap-toggle').textContent = 'Overlap Edges: ' + (showOverlapEdges ? 'On' : 'Off');
  var btn = document.getElementById('overlap-only-toggle');
  btn.textContent = 'Only Overlaps: ' + (overlapOnlyMode ? 'On' : 'Off');
  applyFilters();
}
NEW: function toggleDomain(domain, btn) {
  if (activeDomains.has(domain)) { activeDomains.delete(domain); btn.classList.remove('active'); }
  else { activeDomains.add(domain); btn.classList.add('active'); }
  updateHulls();
}

function showAllDomains() {
  domainNames.forEach(function(d) { activeDomains.add(d); });
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.add('active'); });
  updateHulls();
}

function hideAllDomains() {
  activeDomains.clear();
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.remove('active'); });
  updateHulls();
}

--- 2026-02-21T04:25:36Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function applyFilters() {
  node.style('display', function(d) {
    if (!activeFilters.has(d.type)) return 'none';
    if (overlapOnlyMode && !overlapNodeIds.has(d.id)) return 'none';
    if (searchQuery && !d.label.toLowerCase().includes(searchQuery) && !d.id.toLowerCase().includes(searchQuery)) return 'none';
    return null;
  });
  link.style('display', function(l) {
    if (!showOverlapEdges && l.type === 'overlaps-with') return 'none';
    if (overlapOnlyMode && l.type !== 'overlaps-with') return 'none';
    var sn = graphNodes.find(function(n) { return n.id === getNodeId(l.source); });
    var tn = graphNodes.find(function(n) { return n.id === getNodeId(l.target); });
    if (!sn || !tn || !activeFilters.has(sn.type) || !activeFilters.has(tn.type)) return 'none';
    if (overlapOnlyMode && (!overlapNodeIds.has(sn.id) || !overlapNodeIds.has(tn.id))) return 'none';
    return null;
  });
}
NEW: function applyFilters() {
  node.style('display', function(d) {
    if (!activeFilters.has(d.type)) return 'none';
    if (searchQuery && !d.label.toLowerCase().includes(searchQuery) && !d.id.toLowerCase().includes(searchQuery)) return 'none';
    return null;
  });
  link.style('display', function(l) {
    var sn = graphNodes.find(function(n) { return n.id === getNodeId(l.source); });
    var tn = graphNodes.find(function(n) { return n.id === getNodeId(l.target); });
    if (!sn || !tn || !activeFilters.has(sn.type) || !activeFilters.has(tn.type)) return 'none';
    return null;
  });
  updateHulls();
}

--- 2026-02-21T04:25:42Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: document.getElementById('stats').textContent =
  data.stats.nodes + ' nodes \u00b7 ' + data.stats.edges + ' edges \u00b7 ' + (data.stats.overlaps || 0) + ' overlaps \u00b7 Generated ' + new Date(data.generated).toLocaleDateString();
NEW: document.getElementById('stats').textContent =
  data.stats.nodes + ' nodes \u00b7 ' + data.stats.edges + ' edges \u00b7 ' + domainNames.length + ' domains \u00b7 Generated ' + new Date(data.generated).toLocaleDateString();

--- 2026-02-21T04:25:47Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #filter-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  border-top: 1px solid #30363d;
  padding-top: 8px;
}
NEW: #filter-list, #domain-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  border-top: 1px solid #30363d;
  padding-top: 8px;
}

--- 2026-02-21T04:27:13Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD: # --- Public: resolve subagent model ---
routing_resolve_model() {
  _routing_load_cache

  local phase="" category="" agent=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --phase)   phase="$2"; shift 2 ;;
      --category) category="$2"; shift 2 ;;
      --agent)   agent="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  # 1. Per-agent override
  if [[ -n "$agent" && -n "${_ROUTING_SA_OVERRIDE[$agent]:-}" ]]; then
    echo "${_ROUTING_SA_OVERRIDE[$agent]}"
    return 0
  fi

  # 2. Phase-specific category
  if [[ -n "$phase" && -n "$category" && -n "${_ROUTING_SA_PHASE_CAT[${phase}:${category}]:-}" ]]; then
    echo "${_ROUTING_SA_PHASE_CAT[${phase}:${category}]}"
    return 0
  fi

  # 3. Phase-level model
  if [[ -n "$phase" && -n "${_ROUTING_SA_PHASE_MODEL[$phase]:-}" ]]; then
    echo "${_ROUTING_SA_PHASE_MODEL[$phase]}"
    return 0
  fi

  # 4. Default category
  if [[ -n "$category" && -n "${_ROUTING_SA_DEFAULTS[$category]:-}" ]]; then
    echo "${_ROUTING_SA_DEFAULTS[$category]}"
    return 0
  fi

  # 5. Default model
  if [[ -n "$_ROUTING_SA_DEFAULT_MODEL" ]]; then
    echo "$_ROUTING_SA_DEFAULT_MODEL"
    return 0
  fi

  # 6. No config — caller uses its own default
  return 0
}
NEW: # --- Public: resolve subagent model ---
# resolve_model MUST never return "inherit" — it is an internal sentinel
# meaning "this level has no override, continue to next level."
routing_resolve_model() {
  _routing_load_cache

  local phase="" category="" agent=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --phase)   phase="$2"; shift 2 ;;
      --category) category="$2"; shift 2 ;;
      --agent)   agent="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  local result=""

  # 1. Per-agent override
  if [[ -z "$result" && -n "$agent" && -n "${_ROUTING_SA_OVERRIDE[$agent]:-}" ]]; then
    result="${_ROUTING_SA_OVERRIDE[$agent]}"
    [[ "$result" == "inherit" ]] && result=""
  fi

  # 2. Phase-specific category
  if [[ -z "$result" && -n "$phase" && -n "$category" && -n "${_ROUTING_SA_PHASE_CAT[${phase}:${category}]:-}" ]]; then
    result="${_ROUTING_SA_PHASE_CAT[${phase}:${category}]}"
    [[ "$result" == "inherit" ]] && result=""
  fi

  # 3. Phase-level model
  if [[ -z "$result" && -n "$phase" && -n "${_ROUTING_SA_PHASE_MODEL[$phase]:-}" ]]; then
    result="${_ROUTING_SA_PHASE_MODEL[$phase]}"
    [[ "$result" == "inherit" ]] && result=""
  fi

  # 4. Default category
  if [[ -z "$result" && -n "$category" && -n "${_ROUTING_SA_DEFAULTS[$category]:-}" ]]; then
    result="${_ROUTING_SA_DEFAULTS[$category]}"
    [[ "$result" == "inherit" ]] && result=""
  fi

  # 5. Default model
  if [[ -z "$result" && -n "$_ROUTING_SA_DEFAULT_MODEL" ]]; then
    result="$_ROUTING_SA_DEFAULT_MODEL"
    [[ "$result" == "inherit" ]] && result=""
  fi

  # 6. Ultimate fallback — never return "inherit" or empty from a configured file
  if [[ -z "$result" && -n "$_ROUTING_CONFIG_PATH" ]]; then
    result="sonnet"
  fi

  # Guard: resolve_model MUST never return "inherit"
  [[ "$result" == "inherit" ]] && result="sonnet"

  [[ -n "$result" ]] && echo "$result"
  return 0
}

--- 2026-02-21T04:27:25Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD:   done < "$_ROUTING_CONFIG_PATH"

  _ROUTING_CACHE_POPULATED=1
}
NEW:   done < "$_ROUTING_CONFIG_PATH"

  # Warn if config exists but nothing was parsed (likely malformed)
  if [[ -n "$_ROUTING_CONFIG_PATH" && -z "$_ROUTING_SA_DEFAULT_MODEL" && ${#_ROUTING_SA_DEFAULTS[@]} -eq 0 ]]; then
    echo "Warning: routing.yaml exists but no subagent defaults were parsed — possible malformed config" >&2
  fi

  _ROUTING_CACHE_POPULATED=1
}

--- 2026-02-21T04:28:49Z | plugins/interserve/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD: "version": "0.1.2"
NEW: "version": "0.1.3"

--- 2026-02-21T04:28:50Z | plugins/interstat/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD: "version": "0.2.4"
NEW: "version": "0.2.5"

--- 2026-02-21T04:29:12Z | os/clavain/tests/shell/test_routing.bats | CONTEXT:unknown ---
OLD: @test "resolve_model --phase executing --category research falls through to defaults.categories" {
    _source_routing
    result="$(routing_resolve_model --phase executing --category research)"
    [[ "$result" == "haiku" ]]
}
NEW: @test "resolve_model --phase executing --category research returns phase model (not default category)" {
    # Resolution: phase-category (not set) → phase-model (sonnet) → returns sonnet
    # Phase model takes priority over default category
    _source_routing
    result="$(routing_resolve_model --phase executing --category research)"
    [[ "$result" == "sonnet" ]]
}

--- 2026-02-21T04:29:15Z | infra/marketplace/.claude-plugin/marketplace.json | CONTEXT:unknown ---
OLD:       "description": "Token efficiency benchmarking for agent workflows — PostToolUse:Task hook captures real-time events to SQLite, SessionEnd hook backfills token data from JSONL, report shows percentiles and decision gate.",
      "version": "0.2.4",
NEW:       "description": "Token efficiency benchmarking for agent workflows — PostToolUse:Task hook captures real-time events to SQLite, SessionEnd hook backfills token data from JSONL, report shows percentiles and decision gate.",
      "version": "0.2.5",

--- 2026-02-21T04:29:15Z | infra/intercore/internal/portfolio/deps.go | CONTEXT:unknown ---
OLD: // Add inserts a dependency edge. Returns error if duplicate.
func (s *DepStore) Add(ctx context.Context, portfolioRunID, upstream, downstream string) error {
	if upstream == downstream {
		return fmt.Errorf("add dep: upstream and downstream cannot be the same project")
	}
	_, err := s.db.ExecContext(ctx, `
		INSERT INTO project_deps (portfolio_run_id, upstream_project, downstream_project, created_at)
		VALUES (?, ?, ?, ?)`,
		portfolioRunID, upstream, downstream, time.Now().Unix(),
	)
	if err != nil {
		return fmt.Errorf("add dep: %w", err)
	}
	return nil
}
NEW: // Add inserts a dependency edge. Returns error if duplicate or would create a cycle.
func (s *DepStore) Add(ctx context.Context, portfolioRunID, upstream, downstream string) error {
	if upstream == downstream {
		return fmt.Errorf("add dep: upstream and downstream cannot be the same project")
	}
	// Check for cycles: if downstream can already reach upstream via existing edges,
	// adding upstream→downstream would create a cycle.
	reachable, err := s.HasPath(ctx, portfolioRunID, downstream, upstream)
	if err != nil {
		return fmt.Errorf("add dep: cycle check: %w", err)
	}
	if reachable {
		return fmt.Errorf("add dep: cycle detected: adding %s → %s would create a cycle", upstream, downstream)
	}
	_, err = s.db.ExecContext(ctx, `
		INSERT INTO project_deps (portfolio_run_id, upstream_project, downstream_project, created_at)
		VALUES (?, ?, ?, ?)`,
		portfolioRunID, upstream, downstream, time.Now().Unix(),
	)
	if err != nil {
		return fmt.Errorf("add dep: %w", err)
	}
	return nil
}

// HasPath checks whether a directed path exists from 'from' to 'to' in the
// dependency graph using DFS. Returns true if 'to' is reachable from 'from'.
func (s *DepStore) HasPath(ctx context.Context, portfolioRunID, from, to string) (bool, error) {
	visited := make(map[string]bool)
	stack := []string{from}
	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if node == to {
			return true, nil
		}
		if visited[node] {
			continue
		}
		visited[node] = true
		downstream, err := s.GetDownstream(ctx, portfolioRunID, node)
		if err != nil {
			return false, err
		}
		stack = append(stack, downstream...)
	}
	return false, nil
}

--- 2026-02-21T04:29:35Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: // Suppress unused import warning — time is used by the Dep struct in deps.go
var _ = time.Now
NEW: func TestAddDep_DirectCycle(t *testing.T) {
	db := tempDB(t)
	s := NewDepStore(db)
	ctx := context.Background()

	// A → B exists
	if err := s.Add(ctx, "portfolio1", "/proj/a", "/proj/b"); err != nil {
		t.Fatalf("Add A→B: %v", err)
	}
	// Adding B → A should fail (direct cycle)
	err := s.Add(ctx, "portfolio1", "/proj/b", "/proj/a")
	if err == nil {
		t.Fatal("expected cycle detection error for B→A")
	}
}

func TestAddDep_TransitiveCycle(t *testing.T) {
	db := tempDB(t)
	s := NewDepStore(db)
	ctx := context.Background()

	// A → B, B → C
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")
	s.Add(ctx, "portfolio1", "/proj/b", "/proj/c")

	// Adding C → A should fail (transitive cycle: A→B→C→A)
	err := s.Add(ctx, "portfolio1", "/proj/c", "/proj/a")
	if err == nil {
		t.Fatal("expected cycle detection error for C→A")
	}
}

func TestAddDep_NoCycleFalsePositive(t *testing.T) {
	db := tempDB(t)
	s := NewDepStore(db)
	ctx := context.Background()

	// A → B, A → C (diamond top)
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/c")

	// Adding C → B should succeed (no cycle — it's a diamond shape)
	if err := s.Add(ctx, "portfolio1", "/proj/c", "/proj/b"); err != nil {
		t.Fatalf("Add C→B should succeed (no cycle): %v", err)
	}
}

func TestHasPath(t *testing.T) {
	db := tempDB(t)
	s := NewDepStore(db)
	ctx := context.Background()

	// Build graph: A → B → C
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")
	s.Add(ctx, "portfolio1", "/proj/b", "/proj/c")

	tests := []struct {
		from, to string
		want     bool
	}{
		{"/proj/a", "/proj/c", true},  // transitive
		{"/proj/a", "/proj/b", true},  // direct
		{"/proj/c", "/proj/a", false}, // no reverse path
		{"/proj/b", "/proj/a", false}, // no reverse path
		{"/proj/a", "/proj/a", false}, // self (not in graph)
		{"/proj/x", "/proj/y", false}, // non-existent nodes
	}
	for _, tt := range tests {
		got, err := s.HasPath(ctx, "portfolio1", tt.from, tt.to)
		if err != nil {
			t.Fatalf("HasPath(%s, %s): %v", tt.from, tt.to, err)
		}
		if got != tt.want {
			t.Errorf("HasPath(%s, %s) = %v, want %v", tt.from, tt.to, got, tt.want)
		}
	}
}

// Suppress unused import warning — time is used by the Dep struct in deps.go
var _ = time.Now

--- 2026-02-21T04:29:38Z | os/clavain/tests/shell/test_routing.bats | CONTEXT:unknown ---
OLD: @test "missing config returns empty (caller uses its own default)" {
    _source_routing "/nonexistent/routing.yaml"
    result="$(routing_resolve_model)"
    [[ -z "$result" ]]
}
NEW: @test "missing CLAVAIN_ROUTING_CONFIG falls through to script-relative discovery" {
    # When the env var points to a nonexistent file, _routing_find_config
    # falls through to script-relative, CLAVAIN_SOURCE_DIR, and cache paths.
    # Since we run from the project dir, script-relative finds the real config.
    _source_routing "/nonexistent/routing.yaml"
    result="$(routing_resolve_model)"
    # Result is non-empty because the script-relative path finds config/routing.yaml
    [[ -n "$result" ]]
}

--- 2026-02-21T04:29:53Z | infra/intercore/internal/portfolio/deps.go | CONTEXT:unknown ---
OLD: // HasPath checks whether a directed path exists from 'from' to 'to' in the
// dependency graph using DFS. Returns true if 'to' is reachable from 'from'.
func (s *DepStore) HasPath(ctx context.Context, portfolioRunID, from, to string) (bool, error) {
	visited := make(map[string]bool)
	stack := []string{from}
	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if node == to {
			return true, nil
		}
		if visited[node] {
			continue
		}
		visited[node] = true
		downstream, err := s.GetDownstream(ctx, portfolioRunID, node)
		if err != nil {
			return false, err
		}
		stack = append(stack, downstream...)
	}
	return false, nil
}
NEW: // HasPath checks whether a directed path of length >= 1 exists from 'from' to
// 'to' in the dependency graph using DFS. Returns true if 'to' is reachable
// from 'from' by following at least one edge.
func (s *DepStore) HasPath(ctx context.Context, portfolioRunID, from, to string) (bool, error) {
	visited := make(map[string]bool)
	// Start DFS from from's immediate downstream neighbors (not from itself)
	// so we require at least one edge traversal.
	initial, err := s.GetDownstream(ctx, portfolioRunID, from)
	if err != nil {
		return false, err
	}
	stack := initial
	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if node == to {
			return true, nil
		}
		if visited[node] {
			continue
		}
		visited[node] = true
		downstream, err := s.GetDownstream(ctx, portfolioRunID, node)
		if err != nil {
			return false, err
		}
		stack = append(stack, downstream...)
	}
	return false, nil
}

--- 2026-02-21T04:30:10Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: // Check type constants for gateRules.
const (
	CheckArtifactExists   = "artifact_exists"
	CheckAgentsComplete   = "agents_complete"
	CheckVerdictExists    = "verdict_exists"
	CheckChildrenAtPhase  = "children_at_phase"
)
NEW: // Check type constants for gateRules.
const (
	CheckArtifactExists    = "artifact_exists"
	CheckAgentsComplete    = "agents_complete"
	CheckVerdictExists     = "verdict_exists"
	CheckChildrenAtPhase   = "children_at_phase"
	CheckUpstreamsAtPhase  = "upstreams_at_phase"
)

--- 2026-02-21T04:30:18Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: // PortfolioQuerier abstracts queries for portfolio run children.
// Implemented by phase.Store; tests can use stubs.
type PortfolioQuerier interface {
	GetChildren(ctx context.Context, runID string) ([]*Run, error)
}
NEW: // PortfolioQuerier abstracts queries for portfolio run children.
// Implemented by phase.Store; tests can use stubs.
type PortfolioQuerier interface {
	GetChildren(ctx context.Context, runID string) ([]*Run, error)
}

// DepQuerier abstracts dependency graph queries for gate evaluation.
// Implemented by portfolio.DepStore; tests can use stubs.
type DepQuerier interface {
	GetUpstream(ctx context.Context, portfolioRunID, downstream string) ([]string, error)
}

--- 2026-02-21T04:30:23Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: // evaluateGate checks whether a phase transition should be allowed.
// Returns gate result, tier, structured evidence, and any error.
func evaluateGate(ctx context.Context, run *Run, cfg GateConfig, from, to string, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier) (result, tier string, evidence *GateEvidence, err error) {
NEW: // evaluateGate checks whether a phase transition should be allowed.
// Returns gate result, tier, structured evidence, and any error.
func evaluateGate(ctx context.Context, run *Run, cfg GateConfig, from, to string, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier) (result, tier string, evidence *GateEvidence, err error) {

--- 2026-02-21T04:30:23Z | os/clavain/agents/review/plan-reviewer.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:30:24Z | os/clavain/agents/review/data-migration-expert.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:30:25Z | os/clavain/agents/workflow/bug-reproduction-validator.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:30:27Z | os/clavain/agents/workflow/pr-comment-resolver.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:30:29Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 	// Portfolio runs: inject children_at_phase check for every transition
	isPortfolio := run.ProjectDir == ""
	if isPortfolio {
		rules = append(rules, gateRule{check: CheckChildrenAtPhase, phase: to})
	}

	if len(rules) == 0 {
NEW: 	// Portfolio runs: inject children_at_phase check for every transition
	isPortfolio := run.ProjectDir == ""
	if isPortfolio {
		rules = append(rules, gateRule{check: CheckChildrenAtPhase, phase: to})
	}

	// Child runs with a parent: inject upstreams_at_phase check for every transition
	if run.ParentRunID != nil && *run.ParentRunID != "" {
		rules = append(rules, gateRule{check: CheckUpstreamsAtPhase, phase: to})
	}

	if len(rules) == 0 {

--- 2026-02-21T04:30:40Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 		default:
			cond.Result = GateFail
			cond.Detail = fmt.Sprintf("unknown check type: %q", rule.check)
			allPass = false
		}

		evidence.Conditions = append(evidence.Conditions, cond)
NEW: 		case CheckUpstreamsAtPhase:
			if dq == nil || pq == nil {
				cond.Result = GateFail
				cond.Detail = "no dep/portfolio querier provided"
				allPass = false
				break
			}
			upstreams, qerr := dq.GetUpstream(ctx, *run.ParentRunID, run.ProjectDir)
			if qerr != nil {
				return "", "", nil, fmt.Errorf("gate check: get upstreams: %w", qerr)
			}
			if len(upstreams) == 0 {
				cond.Result = GatePass
				cond.Detail = "no upstream dependencies"
				break
			}
			// Load all siblings to find upstream runs
			siblings, qerr := pq.GetChildren(ctx, *run.ParentRunID)
			if qerr != nil {
				return "", "", nil, fmt.Errorf("gate check: get siblings: %w", qerr)
			}
			siblingByProject := make(map[string]*Run)
			for _, s := range siblings {
				siblingByProject[s.ProjectDir] = s
			}
			behind := 0
			var behindDetails []string
			for _, upstream := range upstreams {
				upstreamRun, ok := siblingByProject[upstream]
				if !ok {
					continue // upstream project has no child run — not blocking
				}
				if upstreamRun.Status == StatusCompleted {
					continue // completed upstreams don't block
				}
				upstreamChain := ResolveChain(upstreamRun)
				targetIdx := ChainPhaseIndex(upstreamChain, rule.phase)
				if targetIdx < 0 {
					continue // upstream chain doesn't have this phase
				}
				upstreamIdx := ChainPhaseIndex(upstreamChain, upstreamRun.Phase)
				if upstreamIdx < targetIdx {
					behind++
					behindDetails = append(behindDetails, fmt.Sprintf("%s at %s", upstream, upstreamRun.Phase))
				}
			}
			count := behind
			cond.Count = &count
			if behind == 0 {
				cond.Result = GatePass
			} else {
				cond.Result = GateFail
				cond.Detail = fmt.Sprintf("upstreams behind phase %q: %v", rule.phase, behindDetails)
				allPass = false
			}

		default:
			cond.Result = GateFail
			cond.Detail = fmt.Sprintf("unknown check type: %q", rule.check)
			allPass = false
		}

		evidence.Conditions = append(evidence.Conditions, cond)

--- 2026-02-21T04:30:45Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: // EvaluateGate performs a dry-run gate check for the next transition.
// This is the public entry point used by `ic gate check`.
func EvaluateGate(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier) (*GateCheckResult, error) {
NEW: // EvaluateGate performs a dry-run gate check for the next transition.
// This is the public entry point used by `ic gate check`.
func EvaluateGate(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier) (*GateCheckResult, error) {

--- 2026-02-21T04:30:50Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 	result, tier, evidence, err := evaluateGate(ctx, run, cfg, run.Phase, toPhase, rt, vq, pq)
	if err != nil {
		return nil, fmt.Errorf("evaluate gate: %w", err)
	}

	return &GateCheckResult{
NEW: 	result, tier, evidence, err := evaluateGate(ctx, run, cfg, run.Phase, toPhase, rt, vq, pq, dq)
	if err != nil {
		return nil, fmt.Errorf("evaluate gate: %w", err)
	}

	return &GateCheckResult{

--- 2026-02-21T04:31:00Z | infra/intercore/internal/phase/machine.go | CONTEXT:unknown ---
OLD: // rt and vq may be nil when Priority >= 4 (TierNone skips gate evaluation).
// pq may be nil for non-portfolio runs.
// callback may be nil — Advance checks before calling.
func Advance(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, callback PhaseEventCallback) (*AdvanceResult, error) {
NEW: // rt and vq may be nil when Priority >= 4 (TierNone skips gate evaluation).
// pq may be nil for non-portfolio runs.
// dq may be nil for non-child runs (runs without a parent_run_id).
// callback may be nil — Advance checks before calling.
func Advance(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier, callback PhaseEventCallback) (*AdvanceResult, error) {

--- 2026-02-21T04:31:04Z | infra/intercore/internal/phase/machine.go | CONTEXT:unknown ---
OLD: 	// Evaluate gate
	gateResult, gateTier, evidence, gateErr := evaluateGate(ctx, run, cfg, fromPhase, toPhase, rt, vq, pq)
NEW: 	// Evaluate gate
	gateResult, gateTier, evidence, gateErr := evaluateGate(ctx, run, cfg, fromPhase, toPhase, rt, vq, pq, dq)

--- 2026-02-21T04:31:38Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	result, err := phase.Advance(ctx, store, id, phase.GateConfig{
		Priority:   priority,
		DisableAll: disableGates,
		SkipReason: skipReason,
	}, rtStore, dStore, store, phaseCallback)
NEW: 	// Wire DepQuerier for child runs with dependencies
	var dq phase.DepQuerier
	if run.ParentRunID != nil && *run.ParentRunID != "" {
		dq = portfolio.NewDepStore(d.SqlDB())
	}

	result, err := phase.Advance(ctx, store, id, phase.GateConfig{
		Priority:   priority,
		DisableAll: disableGates,
		SkipReason: skipReason,
	}, rtStore, dStore, store, dq, phaseCallback)

--- 2026-02-21T04:31:53Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	"github.com/mistakeknot/interverse/infra/intercore/internal/budget"
	"github.com/mistakeknot/interverse/infra/intercore/internal/dispatch"
	"github.com/mistakeknot/interverse/infra/intercore/internal/event"
	"github.com/mistakeknot/interverse/infra/intercore/internal/phase"
	"github.com/mistakeknot/interverse/infra/intercore/internal/runtrack"
	"github.com/mistakeknot/interverse/infra/intercore/internal/state"
NEW: 	"github.com/mistakeknot/interverse/infra/intercore/internal/budget"
	"github.com/mistakeknot/interverse/infra/intercore/internal/dispatch"
	"github.com/mistakeknot/interverse/infra/intercore/internal/event"
	"github.com/mistakeknot/interverse/infra/intercore/internal/phase"
	portfoliopkg "github.com/mistakeknot/interverse/infra/intercore/internal/portfolio"
	"github.com/mistakeknot/interverse/infra/intercore/internal/runtrack"
	"github.com/mistakeknot/interverse/infra/intercore/internal/state"

--- 2026-02-21T04:31:56Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 		dq = portfolio.NewDepStore(d.SqlDB())
NEW: 		dq = portfoliopkg.NewDepStore(d.SqlDB())

--- 2026-02-21T04:32:06Z | infra/intercore/cmd/ic/gate.go | CONTEXT:unknown ---
OLD: 	"github.com/mistakeknot/interverse/infra/intercore/internal/dispatch"
	"github.com/mistakeknot/interverse/infra/intercore/internal/phase"
	"github.com/mistakeknot/interverse/infra/intercore/internal/runtrack"
NEW: 	"github.com/mistakeknot/interverse/infra/intercore/internal/dispatch"
	"github.com/mistakeknot/interverse/infra/intercore/internal/phase"
	"github.com/mistakeknot/interverse/infra/intercore/internal/portfolio"
	"github.com/mistakeknot/interverse/infra/intercore/internal/runtrack"

--- 2026-02-21T04:32:11Z | infra/intercore/cmd/ic/gate.go | CONTEXT:unknown ---
OLD: 	store := phase.New(d.SqlDB())
	rtStore := runtrack.New(d.SqlDB())
	dStore := dispatch.New(d.SqlDB(), nil)

	result, err := phase.EvaluateGate(ctx, store, runID, phase.GateConfig{
		Priority: priority,
	}, rtStore, dStore, store)
NEW: 	store := phase.New(d.SqlDB())
	rtStore := runtrack.New(d.SqlDB())
	dStore := dispatch.New(d.SqlDB(), nil)
	depStore := portfolio.NewDepStore(d.SqlDB())

	result, err := phase.EvaluateGate(ctx, store, runID, phase.GateConfig{
		Priority: priority,
	}, rtStore, dStore, store, depStore)

--- 2026-02-21T04:32:27Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // Build domain toggle buttons
var domainList = document.getElementById('domain-list');
domainNames.forEach(function(domain) {
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  var color = DOMAIN_COLORS[domain];
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  var count = domainMembers[domain].size;
  btn.appendChild(document.createTextNode(DOMAIN_LABELS[domain] + ' (' + count + ')'));
  btn.dataset.domain = domain;
  btn.onclick = function() { toggleDomain(domain, btn); };
  domainList.appendChild(btn);
});

// D3 Setup
NEW: // D3 Setup

--- 2026-02-21T04:32:32Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: const activeDomains = new Set(domainNames);

// Force simulation
NEW: const activeDomains = new Set(domainNames);

// Build domain toggle buttons
var domainList = document.getElementById('domain-list');
domainNames.forEach(function(domain) {
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  var color = DOMAIN_COLORS[domain];
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  var count = domainMembers[domain].size;
  btn.appendChild(document.createTextNode(DOMAIN_LABELS[domain] + ' (' + count + ')'));
  btn.dataset.domain = domain;
  btn.onclick = function() { toggleDomain(domain, btn); };
  domainList.appendChild(btn);
});

// Force simulation

--- 2026-02-21T04:32:54Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: Advance(ctx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil)
NEW: Advance(ctx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil, nil)

--- 2026-02-21T04:32:57Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: Advance(ctx, store, id, GateConfig{Priority: 2}, rtStore, nil, nil, nil)
NEW: Advance(ctx, store, id, GateConfig{Priority: 2}, rtStore, nil, nil, nil, nil)

--- 2026-02-21T04:33:02Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: Advance(ctx, store, id, GateConfig{Priority: 0}, rtStore, dStore, nil, nil)
NEW: Advance(ctx, store, id, GateConfig{Priority: 0}, rtStore, dStore, nil, nil, nil)

--- 2026-02-21T04:33:06Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: Advance(ctx, store, id, GateConfig{Priority: 0, DisableAll: true}, nil, nil, nil, nil)
NEW: Advance(ctx, store, id, GateConfig{Priority: 0, DisableAll: true}, nil, nil, nil, nil, nil)

--- 2026-02-21T04:33:10Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: EvaluateGate(ctx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil)
NEW: EvaluateGate(ctx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil)

--- 2026-02-21T04:33:14Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: EvaluateGate(cancelCtx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil)
NEW: EvaluateGate(cancelCtx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil)

--- 2026-02-21T04:35:05Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: 		result, err := Advance(context.Background(), store, runID, cfg, rt, nil, nil, nil)
NEW: 		result, err := Advance(context.Background(), store, runID, cfg, rt, nil, nil, nil, nil)

--- 2026-02-21T04:35:23Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: , nil, nil, nil, nil)
NEW: , nil, nil, nil, nil, nil)

--- 2026-02-21T04:35:38Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: 		result, err := Advance(context.Background(), store, runID, cfg, rt, nil, nil, nil, nil, nil)
NEW: 		result, err := Advance(context.Background(), store, runID, cfg, rt, nil, nil, nil, nil)

--- 2026-02-21T04:35:46Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: rtStore, nil, nil, nil)
NEW: rtStore, nil, nil, nil, nil)

--- 2026-02-21T04:36:32Z | infra/intercore/cmd/ic/portfolio.go | CONTEXT:unknown ---
OLD: 	"github.com/mistakeknot/interverse/infra/intercore/internal/portfolio"
)
NEW: 	"github.com/mistakeknot/interverse/infra/intercore/internal/phase"
	"github.com/mistakeknot/interverse/infra/intercore/internal/portfolio"
)

--- 2026-02-21T04:36:38Z | infra/intercore/cmd/ic/portfolio.go | CONTEXT:unknown ---
OLD: 	if len(args) == 0 {
		fmt.Fprintf(os.Stderr, "ic: portfolio: missing subcommand (dep, relay)\n")
		return 3
	}

	switch args[0] {
	case "dep":
		return cmdPortfolioDep(ctx, args[1:])
	case "relay":
		return cmdPortfolioRelay(ctx, args[1:])
	default:
		fmt.Fprintf(os.Stderr, "ic: portfolio: unknown subcommand: %s\n", args[0])
		return 3
	}
NEW: 	if len(args) == 0 {
		fmt.Fprintf(os.Stderr, "ic: portfolio: missing subcommand (dep, relay, order, status)\n")
		return 3
	}

	switch args[0] {
	case "dep":
		return cmdPortfolioDep(ctx, args[1:])
	case "relay":
		return cmdPortfolioRelay(ctx, args[1:])
	case "order":
		return cmdPortfolioOrder(ctx, args[1:])
	case "status":
		return cmdPortfolioStatus(ctx, args[1:])
	default:
		fmt.Fprintf(os.Stderr, "ic: portfolio: unknown subcommand: %s\n", args[0])
		return 3
	}

--- 2026-02-21T04:36:42Z | os/clavain/agents/review/plan-reviewer.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:36:43Z | os/clavain/agents/review/data-migration-expert.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:36:44Z | os/clavain/agents/workflow/bug-reproduction-validator.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:36:45Z | os/clavain/agents/workflow/pr-comment-resolver.md | CONTEXT:unknown ---
OLD: model: sonnet
---
NEW: ---

--- 2026-02-21T04:36:59Z | infra/intercore/cmd/ic/portfolio.go | CONTEXT:unknown ---
OLD: 	fmt.Fprintf(os.Stderr, "[relay] stopped\n")
	return 0
}
NEW: 	fmt.Fprintf(os.Stderr, "[relay] stopped\n")
	return 0
}

func cmdPortfolioOrder(ctx context.Context, args []string) int {
	if len(args) < 1 {
		fmt.Fprintf(os.Stderr, "ic: portfolio order: usage: ic portfolio order <portfolio-id>\n")
		return 3
	}
	portfolioID := args[0]

	d, err := openDB()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: portfolio order: %v\n", err)
		return 2
	}
	defer d.Close()

	depStore := portfolio.NewDepStore(d.SqlDB())
	deps, err := depStore.List(ctx, portfolioID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: portfolio order: %v\n", err)
		return 2
	}

	order, err := portfolio.TopologicalSort(deps)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: portfolio order: %v\n", err)
		return 2
	}

	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(order)
	} else {
		for i, p := range order {
			fmt.Printf("%d\t%s\n", i+1, p)
		}
	}
	return 0
}

func cmdPortfolioStatus(ctx context.Context, args []string) int {
	if len(args) < 1 {
		fmt.Fprintf(os.Stderr, "ic: portfolio status: usage: ic portfolio status <portfolio-id>\n")
		return 3
	}
	portfolioID := args[0]

	d, err := openDB()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: portfolio status: %v\n", err)
		return 2
	}
	defer d.Close()

	store := phase.New(d.SqlDB())
	depStore := portfolio.NewDepStore(d.SqlDB())

	children, err := store.GetChildren(ctx, portfolioID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: portfolio status: %v\n", err)
		return 2
	}

	deps, err := depStore.List(ctx, portfolioID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: portfolio status: %v\n", err)
		return 2
	}

	// Build upstream map: project → []upstream projects
	upstreamMap := make(map[string][]string)
	for _, dep := range deps {
		upstreamMap[dep.DownstreamProject] = append(upstreamMap[dep.DownstreamProject], dep.UpstreamProject)
	}

	// Index children by project dir
	childByProject := make(map[string]*phase.Run)
	for _, c := range children {
		childByProject[c.ProjectDir] = c
	}

	type childStatus struct {
		Project   string   `json:"project"`
		Phase     string   `json:"phase"`
		Status    string   `json:"status"`
		Ready     bool     `json:"ready"`
		BlockedBy []string `json:"blocked_by,omitempty"`
	}

	var statuses []childStatus
	for _, child := range children {
		cs := childStatus{
			Project: child.ProjectDir,
			Phase:   child.Phase,
			Status:  child.Status,
			Ready:   true,
		}

		if child.Status == phase.StatusCompleted || child.Status == phase.StatusCancelled {
			statuses = append(statuses, cs)
			continue
		}

		childChain := phase.ResolveChain(child)
		childIdx := phase.ChainPhaseIndex(childChain, child.Phase)

		for _, upstream := range upstreamMap[child.ProjectDir] {
			upRun, ok := childByProject[upstream]
			if !ok {
				continue
			}
			if upRun.Status == phase.StatusCompleted {
				continue
			}
			upChain := phase.ResolveChain(upRun)
			upIdx := phase.ChainPhaseIndex(upChain, upRun.Phase)
			if upIdx < childIdx {
				cs.Ready = false
				cs.BlockedBy = append(cs.BlockedBy, fmt.Sprintf("%s (at %s)", upstream, upRun.Phase))
			}
		}

		statuses = append(statuses, cs)
	}

	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(statuses)
	} else {
		fmt.Printf("%-40s %-20s %-12s %-6s %s\n", "PROJECT", "PHASE", "STATUS", "READY", "BLOCKED BY")
		for _, cs := range statuses {
			blockedBy := ""
			if len(cs.BlockedBy) > 0 {
				blockedBy = strings.Join(cs.BlockedBy, ", ")
			}
			ready := "yes"
			if !cs.Ready {
				ready = "no"
			}
			fmt.Printf("%-40s %-20s %-12s %-6s %s\n", cs.Project, cs.Phase, cs.Status, ready, blockedBy)
		}
	}
	return 0
}

--- 2026-02-21T04:37:54Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: echo "  E5 discovery tests passed"

# --- Version sync check ---
NEW: echo "  E5 discovery tests passed"

# --- E9: Portfolio Dependency Scheduling ---
echo ""
echo "=== E9: Portfolio Dependency Scheduling ==="

# Create a portfolio run (project_dir="" signals portfolio)
PORTFOLIO_RUN=$(ic run create --project="" --goal="Portfolio dep test" --projects="/proj/a,/proj/b,/proj/c" --db="$TEST_DB")
[[ -n "$PORTFOLIO_RUN" ]] || fail "portfolio run create returned empty ID"
pass "portfolio: create"

# Add dependencies: A → B (B depends on A), A → C (C depends on A)
ic portfolio dep add "$PORTFOLIO_RUN" --upstream="/proj/a" --downstream="/proj/b" --db="$TEST_DB" >/dev/null
ic portfolio dep add "$PORTFOLIO_RUN" --upstream="/proj/a" --downstream="/proj/c" --db="$TEST_DB" >/dev/null
pass "portfolio: deps added"

# List deps
dep_list=$(ic portfolio dep list "$PORTFOLIO_RUN" --json --db="$TEST_DB")
dep_count=$(echo "$dep_list" | jq 'length')
[[ "$dep_count" -eq 2 ]] || fail "should have 2 deps, got: $dep_count"
pass "portfolio: dep list"

# Cycle detection: B → A should fail (A already → B)
ic portfolio dep add "$PORTFOLIO_RUN" --upstream="/proj/b" --downstream="/proj/a" --db="$TEST_DB" 2>/dev/null && fail "cycle should be rejected" || true
pass "portfolio: cycle rejected"

# Topological order
order_out=$(ic portfolio order "$PORTFOLIO_RUN" --json --db="$TEST_DB")
first=$(echo "$order_out" | jq -r '.[0]')
# /proj/a should be first (it has no upstream deps)
[[ "$first" == "/proj/a" ]] || fail "topo order first should be /proj/a, got: $first"
pass "portfolio: topological order"

# Portfolio status — children should exist from --projects flag
status_out=$(ic portfolio status "$PORTFOLIO_RUN" --json --db="$TEST_DB")
status_count=$(echo "$status_out" | jq 'length')
[[ "$status_count" -eq 3 ]] || fail "portfolio status should show 3 children, got: $status_count"
pass "portfolio: status shows children"

# Gate check on child B: should check upstreams_at_phase
# Child A is at brainstorm, child B is at brainstorm — upstreams_at_phase should pass
# (both at same phase, so B is not ahead of A)
CHILD_B_ID=$(ic run list --db="$TEST_DB" --json | jq -r ".[] | select(.project_dir == \"/proj/b\") | .id")
[[ -n "$CHILD_B_ID" ]] || fail "child B not found"
gate_b=$(ic gate check "$CHILD_B_ID" --priority=4 --json --db="$TEST_DB" 2>/dev/null) || true
pass "portfolio: gate check on child"

# Advance child A past brainstorm (priority 4 bypasses artifact gate)
CHILD_A_ID=$(ic run list --db="$TEST_DB" --json | jq -r ".[] | select(.project_dir == \"/proj/a\") | .id")
ic run advance "$CHILD_A_ID" --priority=4 --db="$TEST_DB" >/dev/null

# Now try to advance child B with hard gate — B's upstream (A) is at brainstorm-reviewed,
# which is ahead of B's current phase (brainstorm), so the upstreams_at_phase gate should PASS
# since we check if upstream is at or past the target phase
gate_b2=$(ic gate check "$CHILD_B_ID" --priority=0 --json --db="$TEST_DB")
echo "$gate_b2" | jq -e '.result == "pass"' >/dev/null || fail "child B gate should pass when upstream A is ahead, got: $gate_b2"
pass "portfolio: upstream gate passes when upstream is ahead"

# Diamond dependency: add B → C (C now depends on both A and B)
ic portfolio dep add "$PORTFOLIO_RUN" --upstream="/proj/b" --downstream="/proj/c" --db="$TEST_DB" >/dev/null
pass "portfolio: diamond dep added (no cycle)"

# No-dep portfolio: create one without deps, advance freely
NODEP_PORTFOLIO=$(ic run create --project="" --goal="No-dep portfolio" --projects="/proj/x,/proj/y" --db="$TEST_DB")
CHILD_X_ID=$(ic run list --db="$TEST_DB" --json | jq -r ".[] | select(.project_dir == \"/proj/x\") | .id")
ic run advance "$CHILD_X_ID" --priority=4 --db="$TEST_DB" >/dev/null
child_x_phase=$(ic run phase "$CHILD_X_ID" --db="$TEST_DB")
[[ "$child_x_phase" != "brainstorm" ]] || fail "no-dep child should advance freely, got: $child_x_phase"
pass "portfolio: no-dep child advances freely"

echo "  E9 portfolio dependency scheduling tests passed"

# --- Version sync check ---

--- 2026-02-21T04:39:35Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // Stats
document.getElementById('stats').textContent =
  data.stats.nodes + ' nodes \u00b7 ' + data.stats.edges + ' edges \u00b7 ' + domainNames.length + ' domains \u00b7 Generated ' + new Date(data.generated).toLocaleDateString();
NEW: // Stats (updated after domain extraction below)

--- 2026-02-21T04:39:37Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: # Create a portfolio run (project_dir="" signals portfolio)
PORTFOLIO_RUN=$(ic run create --project="" --goal="Portfolio dep test" --projects="/proj/a,/proj/b,/proj/c" --db="$TEST_DB")
[[ -n "$PORTFOLIO_RUN" ]] || fail "portfolio run create returned empty ID"
pass "portfolio: create"
NEW: # Create a portfolio run (project_dir="" signals portfolio)
# head -1: portfolio create prints child IDs on subsequent lines
PORTFOLIO_RUN=$(ic run create --project="" --goal="Portfolio dep test" --projects="/proj/a,/proj/b,/proj/c" --db="$TEST_DB" | head -1)
[[ -n "$PORTFOLIO_RUN" ]] || fail "portfolio run create returned empty ID"
pass "portfolio: create"

--- 2026-02-21T04:39:41Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: NODEP_PORTFOLIO=$(ic run create --project="" --goal="No-dep portfolio" --projects="/proj/x,/proj/y" --db="$TEST_DB")
NEW: NODEP_PORTFOLIO=$(ic run create --project="" --goal="No-dep portfolio" --projects="/proj/x,/proj/y" --db="$TEST_DB" | head -1)

--- 2026-02-21T04:39:59Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: const activeDomains = new Set(domainNames);

// Build domain toggle buttons
NEW: const activeDomains = new Set(domainNames);

// Stats
document.getElementById('stats').textContent =
  data.stats.nodes + ' nodes \u00b7 ' + data.stats.edges + ' edges \u00b7 ' + domainNames.length + ' domains \u00b7 Generated ' + new Date(data.generated).toLocaleDateString();

// Build domain toggle buttons

--- 2026-02-21T04:42:08Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: # Gate check on child B: should check upstreams_at_phase
# Child A is at brainstorm, child B is at brainstorm — upstreams_at_phase should pass
# (both at same phase, so B is not ahead of A)
CHILD_B_ID=$(ic run list --db="$TEST_DB" --json | jq -r ".[] | select(.project_dir == \"/proj/b\") | .id")
[[ -n "$CHILD_B_ID" ]] || fail "child B not found"
gate_b=$(ic gate check "$CHILD_B_ID" --priority=4 --json --db="$TEST_DB" 2>/dev/null) || true
pass "portfolio: gate check on child"

# Advance child A past brainstorm (priority 4 bypasses artifact gate)
CHILD_A_ID=$(ic run list --db="$TEST_DB" --json | jq -r ".[] | select(.project_dir == \"/proj/a\") | .id")
ic run advance "$CHILD_A_ID" --priority=4 --db="$TEST_DB" >/dev/null

# Now try to advance child B with hard gate — B's upstream (A) is at brainstorm-reviewed,
# which is ahead of B's current phase (brainstorm), so the upstreams_at_phase gate should PASS
# since we check if upstream is at or past the target phase
gate_b2=$(ic gate check "$CHILD_B_ID" --priority=0 --json --db="$TEST_DB")
echo "$gate_b2" | jq -e '.result == "pass"' >/dev/null || fail "child B gate should pass when upstream A is ahead, got: $gate_b2"
pass "portfolio: upstream gate passes when upstream is ahead"
NEW: # Find child IDs
CHILD_A_ID=$(ic run list --db="$TEST_DB" --json | jq -r ".[] | select(.project_dir == \"/proj/a\") | .id")
CHILD_B_ID=$(ic run list --db="$TEST_DB" --json | jq -r ".[] | select(.project_dir == \"/proj/b\") | .id")
[[ -n "$CHILD_A_ID" ]] || fail "child A not found"
[[ -n "$CHILD_B_ID" ]] || fail "child B not found"
pass "portfolio: children found"

# Add artifacts so artifact_exists gate doesn't block
ic run artifact add "$CHILD_A_ID" --phase=brainstorm --path=docs/brainstorms/a.md --db="$TEST_DB" >/dev/null
ic run artifact add "$CHILD_B_ID" --phase=brainstorm --path=docs/brainstorms/b.md --db="$TEST_DB" >/dev/null

# Advance child A past brainstorm (hard priority, artifact exists so passes)
ic run advance "$CHILD_A_ID" --priority=0 --db="$TEST_DB" >/dev/null

# Gate check on child B (hard priority): artifact_exists passes (artifact added),
# upstreams_at_phase passes (upstream A is at brainstorm-reviewed, ahead of B's target)
gate_b=$(ic gate check "$CHILD_B_ID" --priority=0 --json --db="$TEST_DB")
echo "$gate_b" | jq -e '.result == "pass"' >/dev/null || fail "child B gate should pass when upstream A is ahead, got: $gate_b"
pass "portfolio: upstream gate passes when upstream is ahead"

# Verify upstreams_at_phase condition is in the evidence
echo "$gate_b" | jq -e '.evidence.conditions[] | select(.check == "upstreams_at_phase") | .result == "pass"' >/dev/null || fail "upstreams_at_phase should be pass in evidence"
pass "portfolio: upstreams_at_phase in gate evidence"

--- 2026-02-21T04:46:40Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: <!-- LLM:NEXT_GROUPINGS
Task: Group these P2 items under 5-10 thematic headings.
Format: **Bold Heading** followed by bullet items.
Heuristic: items sharing a [module] tag or dependency chain likely belong together.

Raw P2 items JSON:
[{"id":"iv-003t","title":"[interspect] Global modification rate limiter","priority":2,"dependencies":[{"issue_id":"iv-003t","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T01:35:01Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-0etu","title":"[flux-drive-spec] Phase 3: Extract scoring/synthesis Python library","priority":2,"dependencies":[{"issue_id":"iv-0etu","depends_on_id":"iv-ia66","type":"blocks","created_at":"2026-02-13T22:47:12Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-0fi2","title":"[interspect] Circuit breaker","priority":2,"dependencies":[{"issue_id":"iv-0fi2","depends_on_id":"iv-ukct","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-0lt","title":"Extract cache_hints metrics in score_tokens.py","priority":2,"dependencies":null},{"id":"iv-1aug","title":"F1: Release Response Protocol (release_ack / release_defer)","priority":2,"dependencies":[{"issue_id":"iv-1aug","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-1gb","title":"Add cache-friendly format queries to regression_suite.json","priority":2,"dependencies":null},{"id":"iv-1sc0","title":"F7: Companion plugin dependency graph","priority":2,"dependencies":[{"issue_id":"iv-1sc0","depends_on_id":"iv-vlg4","type":"blocks","created_at":"2026-02-20T18:00:34Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-26pj","title":"[autarch] Streaming buffer / history split per agent panel","priority":2,"dependencies":null},{"id":"iv-2jtj","title":"F5: Escalation Timeout for Unresponsive Agents","priority":2,"dependencies":[{"issue_id":"iv-2jtj","depends_on_id":"iv-5ijt","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-2jtj","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-2o6c","title":"[interspect] F4: status display + revert for routing overrides","priority":2,"dependencies":[{"issue_id":"iv-2o6c","depends_on_id":"iv-gkj9","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-2o6c","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-3kee","title":"Research: product-native agent orchestration (whitespace opportunity)","priority":2,"dependencies":null},{"id":"iv-3w1x","title":"Split upstreams.json into config + state files","priority":2,"dependencies":null},{"id":"iv-435u","title":"[interspect] Counterfactual shadow evaluation","priority":2,"dependencies":[{"issue_id":"iv-435u","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T07:31:17Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-4728","title":"Consolidate upstream-check.sh API calls (24 to 12)","priority":2,"dependencies":null},{"id":"iv-5ijt","title":"F3: Structured negotiate_release MCP Tool","priority":2,"dependencies":[{"issue_id":"iv-5ijt","depends_on_id":"iv-1aug","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-5ijt","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-5su3","title":"[interspect] Autonomous mode flag","priority":2,"dependencies":[{"issue_id":"iv-5su3","depends_on_id":"iv-cylo","type":"blocks","created_at":"2026-02-15T07:32:25Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-5su3","depends_on_id":"iv-jo3i","type":"blocks","created_at":"2026-02-15T01:35:05Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-6ikc","title":"Plan intershift extraction (cross-AI dispatch engine)","priority":2,"dependencies":null},{"id":"iv-6liz","title":"[interspect] F5: manual routing override support","priority":2,"dependencies":[{"issue_id":"iv-6liz","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:17Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-6liz","depends_on_id":"iv-r6mf","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-6nwo","title":"F3: Dispatch migration (dispatch.sh reads routing.yaml)","priority":2,"dependencies":[{"issue_id":"iv-6nwo","depends_on_id":"iv-dd9q","type":"blocks","created_at":"2026-02-20T20:13:02Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-6nwo","depends_on_id":"iv-jayq","type":"blocks","created_at":"2026-02-20T20:13:03Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-6u3s","title":"F4: Sprint Scan Release Visibility","priority":2,"dependencies":[{"issue_id":"iv-6u3s","depends_on_id":"iv-1aug","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-6u3s","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-88yg","title":"[interspect] Structured commit message format","priority":2,"dependencies":[{"issue_id":"iv-88yg","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T01:35:01Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-8fgu","title":"[interspect] F2: routing-eligible pattern detection + propose flow","priority":2,"dependencies":[{"issue_id":"iv-8fgu","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-8fgu","depends_on_id":"iv-r6mf","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-905u","title":"Intermediate result sharing between parallel flux-drive agents","priority":2,"dependencies":[{"issue_id":"iv-905u","depends_on_id":"iv-ffo5","type":"relates-to","created_at":"2026-02-18T15:45:10Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-asfy","title":"[clavain] C1: Agency specs — declarative per-stage agent/model/tool config","priority":2,"dependencies":null},{"id":"iv-bj0w","title":"[interspect] Conflict detection","priority":2,"dependencies":[{"issue_id":"iv-bj0w","depends_on_id":"iv-rafa","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-bn4j","title":"[intermem] F4: One-shot tiered migration — --migrate-to-tiered","priority":2,"dependencies":[{"issue_id":"iv-bn4j","depends_on_id":"iv-f7po","type":"blocks","created_at":"2026-02-18T08:36:04Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-bn4j","depends_on_id":"iv-rkrm","type":"blocks","created_at":"2026-02-18T08:36:02Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-c2b4","title":"[interspect] /interspect:disable command","priority":2,"dependencies":[{"issue_id":"iv-c2b4","depends_on_id":"iv-o4x7","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-drgo","title":"[interspect] Privilege separation (proposer/applier)","priority":2,"dependencies":[{"issue_id":"iv-drgo","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T07:31:17Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-dthn","title":"Research: inter-layer feedback loops and optimization thresholds","priority":2,"dependencies":null},{"id":"iv-e8dg","title":"[flux-drive-spec] Phase 4: Migrate Clavain to consume the library","priority":2,"dependencies":[{"issue_id":"iv-e8dg","depends_on_id":"iv-0etu","type":"blocks","created_at":"2026-02-13T22:47:13Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-ev4o","title":"Agent capability discovery via intermute registration","priority":2,"dependencies":null},{"id":"iv-exos","title":"Research: bias-aware product decision framework","priority":2,"dependencies":null},{"id":"iv-f7po","title":"[intermem] F3: Multi-file tiered promotion — AGENTS.md index + docs/intermem/ detail","priority":2,"dependencies":[{"issue_id":"iv-f7po","depends_on_id":"iv-rkrm","type":"blocks","created_at":"2026-02-18T08:36:02Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-frqh","title":"F5: clavain:setup modpack — auto-install ecosystem-only plugins","priority":2,"dependencies":[{"issue_id":"iv-frqh","depends_on_id":"iv-gcu2","type":"blocks","created_at":"2026-02-20T12:49:42Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-fzrn","title":"Research: multi-agent hallucination cascades & failure taxonomy","priority":2,"dependencies":[{"issue_id":"iv-fzrn","depends_on_id":"iv-ffo5","type":"relates-to","created_at":"2026-02-18T15:45:11Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-g0to","title":"[interspect] /interspect:reset command","priority":2,"dependencies":[{"issue_id":"iv-g0to","depends_on_id":"iv-ukct","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-gg8v","title":"F2: Auto-Release on Clean Files","priority":2,"dependencies":[{"issue_id":"iv-gg8v","depends_on_id":"iv-1aug","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-gg8v","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-gkj9","title":"[interspect] F3: apply override + canary + git commit","priority":2,"dependencies":[{"issue_id":"iv-gkj9","depends_on_id":"iv-8fgu","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-gkj9","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-gye6","title":"F3: Interbase batch SDK adoption (6 plugins)","priority":2,"dependencies":[{"issue_id":"iv-gye6","depends_on_id":"iv-vlg4","type":"blocks","created_at":"2026-02-20T18:00:32Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-ht1l","title":"[autarch] Pollard: progressive result reveal per hunter","priority":2,"dependencies":null},{"id":"iv-i64p","title":"F1: Routing config schema (config/routing.yaml)","priority":2,"dependencies":[{"issue_id":"iv-i64p","depends_on_id":"iv-dd9q","type":"blocks","created_at":"2026-02-20T20:13:02Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-ia66","title":"[flux-drive-spec] Phase 2: Extract domain detection library","priority":2,"dependencies":null},{"id":"iv-izth","title":"[interspect] Eval corpus construction","priority":2,"dependencies":[{"issue_id":"iv-izth","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-jayq","title":"F2: Resolution library (hooks/lib-routing.sh)","priority":2,"dependencies":[{"issue_id":"iv-jayq","depends_on_id":"iv-dd9q","type":"blocks","created_at":"2026-02-20T20:13:02Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-jayq","depends_on_id":"iv-i64p","type":"blocks","created_at":"2026-02-20T20:13:03Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-jc4j","title":"[intermute] Heterogeneous agent routing experiments inspired by SC-MAS/Dr. MAS","priority":2,"dependencies":[{"issue_id":"iv-jc4j","depends_on_id":"iv-qznx","type":"blocks","created_at":"2026-02-16T22:40:51Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-jk7q","title":"Research: cognitive load budgets & progressive disclosure review UX","priority":2,"dependencies":null},{"id":"iv-k8xn","title":"[clavain] B2: Complexity-aware routing — task complexity drives model selection","priority":2,"dependencies":[{"issue_id":"iv-k8xn","depends_on_id":"iv-dd9q","type":"blocks","created_at":"2026-02-20T09:28:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-knwr","title":"[autarch] pkg/tui: validate components with kernel data","priority":2,"dependencies":[{"issue_id":"iv-knwr","depends_on_id":"iv-2yef","type":"blocks","created_at":"2026-02-19T23:12:03Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-l5ap","title":"Research: transactional orchestration & error recovery patterns","priority":2,"dependencies":[{"issue_id":"iv-l5ap","depends_on_id":"iv-ffo5","type":"relates-to","created_at":"2026-02-18T15:45:12Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-lx00","title":"[clavain] C2: Agent fleet registry — capability + cost profiles per agent×model","priority":2,"dependencies":[{"issue_id":"iv-lx00","depends_on_id":"iv-asfy","type":"blocks","created_at":"2026-02-20T09:28:07Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-lx00","depends_on_id":"iv-dd9q","type":"blocks","created_at":"2026-02-20T09:28:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-m6cd","title":"[interspect] Session-start summary injection","priority":2,"dependencies":[{"issue_id":"iv-m6cd","depends_on_id":"iv-o4x7","type":"blocks","created_at":"2026-02-15T01:34:57Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-p4qq","title":"Smart semantic caching across sessions (intercache)","priority":2,"dependencies":[{"issue_id":"iv-p4qq","depends_on_id":"iv-qtcl","type":"relates-to","created_at":"2026-02-18T15:45:12Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-pg8t","title":"F4: Subagent integration (/model-routing reads routing.yaml)","priority":2,"dependencies":[{"issue_id":"iv-pg8t","depends_on_id":"iv-1kd4","type":"blocks","created_at":"2026-02-20T20:07:23Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-pg8t","depends_on_id":"iv-yo9i","type":"blocks","created_at":"2026-02-20T20:07:24Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-qjwz","title":"AgentDropout: dynamic redundancy elimination for flux-drive reviews","priority":2,"dependencies":[{"issue_id":"iv-qjwz","depends_on_id":"iv-8m38","type":"blocks","created_at":"2026-02-15T17:42:31Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-qjwz","depends_on_id":"iv-ynbh","type":"blocks","created_at":"2026-02-15T17:31:23Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-quk4","title":"Hierarchical dispatch: meta-agent for N-agent fan-out","priority":2,"dependencies":null},{"id":"iv-r6mf","title":"[interspect] F1: routing-overrides.json schema + flux-drive reader","priority":2,"dependencies":[{"issue_id":"iv-r6mf","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-r9j2","title":"[clavain] A3: Event-driven advancement — phase transitions trigger auto-dispatch","priority":2,"dependencies":[{"issue_id":"iv-r9j2","depends_on_id":"iv-kj6w","type":"blocks","created_at":"2026-02-20T09:28:05Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-rafa","title":"[interspect] Meta-learning loop","priority":2,"dependencies":[{"issue_id":"iv-rafa","depends_on_id":"iv-8jpf","type":"blocks","created_at":"2026-02-19T23:37:00Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-rafa","depends_on_id":"iv-cylo","type":"blocks","created_at":"2026-02-15T07:32:26Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-rafa","depends_on_id":"iv-jo3i","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-re4l","title":"F3: Dispatch integration (--phase flag)","priority":2,"dependencies":[{"issue_id":"iv-re4l","depends_on_id":"iv-1kd4","type":"blocks","created_at":"2026-02-20T20:07:23Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-re4l","depends_on_id":"iv-yo9i","type":"blocks","created_at":"2026-02-20T20:07:24Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-rzt0","title":"F1: Interband signal publishers (intercheck, interstat, interlock)","priority":2,"dependencies":[{"issue_id":"iv-rzt0","depends_on_id":"iv-vlg4","type":"blocks","created_at":"2026-02-20T18:00:31Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-sdqv","title":"Plan interscribe extraction (knowledge compounding)","priority":2,"dependencies":[{"issue_id":"iv-sdqv","depends_on_id":"iv-qtcl","type":"relates-to","created_at":"2026-02-18T15:45:13Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-sk8t","title":"F2: Interline statusline enrichment (pressure, coordination, budget)","priority":2,"dependencies":[{"issue_id":"iv-sk8t","depends_on_id":"iv-vlg4","type":"blocks","created_at":"2026-02-20T18:00:31Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-sprh","title":"F6: Cost-aware review depth (always-on budget signal)","priority":2,"dependencies":[{"issue_id":"iv-sprh","depends_on_id":"iv-vlg4","type":"blocks","created_at":"2026-02-20T18:00:33Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-sz5b","title":"F4: Update model-routing command to use routing.yaml","priority":2,"dependencies":[{"issue_id":"iv-sz5b","depends_on_id":"iv-dd9q","type":"blocks","created_at":"2026-02-20T20:13:03Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-sz5b","depends_on_id":"iv-jayq","type":"blocks","created_at":"2026-02-20T20:13:04Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-t1m4","title":"[interspect] Prompt tuning (Type 3) overlay-based","priority":2,"dependencies":[{"issue_id":"iv-t1m4","depends_on_id":"iv-cylo","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-t1m4","depends_on_id":"iv-izth","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-v81k","title":"[interstat] Repository-aware benchmark expansion for agent coding tasks","priority":2,"dependencies":[{"issue_id":"iv-v81k","depends_on_id":"iv-qznx","type":"blocks","created_at":"2026-02-16T22:40:51Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-wz3j","title":"[interflux] Role-aware latent memory architecture experiments","priority":2,"dependencies":[{"issue_id":"iv-wz3j","depends_on_id":"iv-jc4j","type":"blocks","created_at":"2026-02-16T22:40:51Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-xlpg","title":"[autarch] Pollard: optional-death hunter resilience","priority":2,"dependencies":null},{"id":"iv-xuec","title":"Security threat model for token optimization techniques","priority":2,"dependencies":[{"issue_id":"iv-xuec","depends_on_id":"iv-qtcl","type":"relates-to","created_at":"2026-02-18T15:45:13Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-yo9i","title":"F2: Config reader library (lib-routing.sh)","priority":2,"dependencies":[{"issue_id":"iv-yo9i","depends_on_id":"iv-1kd4","type":"blocks","created_at":"2026-02-20T20:07:23Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-yo9i","depends_on_id":"iv-n4tt","type":"blocks","created_at":"2026-02-20T20:07:24Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-zsio","title":"[clavain/interphase] Integrate full discovery pipeline into sprint workflow","priority":2,"dependencies":[{"issue_id":"iv-zsio","depends_on_id":"iv-faq6","type":"parent-child","created_at":"2026-02-20T15:23:46Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-zyym","title":"Evaluate Claude Hub for event-driven GitHub agent dispatch","priority":2,"dependencies":null}]

END LLM:NEXT_GROUPINGS -->
NEW: **Interspect: Routing Control & Overrides**
- [interspect] **iv-r6mf** F1: routing-overrides.json schema + flux-drive reader
- [interspect] **iv-8fgu** F2: routing-eligible pattern detection + propose flow
- [interspect] **iv-gkj9** F3: apply override + canary + git commit
- [interspect] **iv-2o6c** F4: status display + revert for routing overrides
- [interspect] **iv-6liz** F5: manual routing override support
- [interspect] **iv-88yg** Structured commit message format
- [interspect] **iv-003t** Global modification rate limiter
- [interspect] **iv-0fi2** Circuit breaker
- [interspect] **iv-drgo** Privilege separation (proposer/applier)
- [interspect] **iv-bj0w** Conflict detection
- [interspect] **iv-5su3** Autonomous mode flag
- [interspect] **iv-c2b4** /interspect:disable command
- [interspect] **iv-g0to** /interspect:reset command

**Interspect: Evaluation & Meta-Learning**
- [interspect] **iv-435u** Counterfactual shadow evaluation
- [interspect] **iv-izth** Eval corpus construction
- [interspect] **iv-rafa** Meta-learning loop
- [interspect] **iv-t1m4** Prompt tuning (Type 3) overlay-based
- [interspect] **iv-m6cd** Session-start summary injection

**Model Routing Pipeline**
- **iv-i64p** F1: Routing config schema (config/routing.yaml)
- **iv-jayq** F2: Resolution library (hooks/lib-routing.sh)
- **iv-yo9i** F2: Config reader library (lib-routing.sh)
- **iv-6nwo** F3: Dispatch migration (dispatch.sh reads routing.yaml)
- **iv-re4l** F3: Dispatch integration (--phase flag)
- **iv-pg8t** F4: Subagent integration (/model-routing reads routing.yaml)
- **iv-sz5b** F4: Update model-routing command to use routing.yaml
- [clavain] **iv-k8xn** B2: Complexity-aware routing — task complexity drives model selection
- **iv-rzt0** F1: Interband signal publishers (intercheck, interstat, interlock)
- **iv-sk8t** F2: Interline statusline enrichment (pressure, coordination, budget)
- **iv-sprh** F6: Cost-aware review depth (always-on budget signal)

**Multi-Agent Coordination & Interlock Negotiation**
- **iv-1aug** F1: Release Response Protocol (release_ack / release_defer)
- **iv-gg8v** F2: Auto-Release on Clean Files
- **iv-5ijt** F3: Structured negotiate_release MCP Tool
- **iv-6u3s** F4: Sprint Scan Release Visibility
- **iv-2jtj** F5: Escalation Timeout for Unresponsive Agents
- **iv-ev4o** Agent capability discovery via intermute registration
- [intermute] **iv-jc4j** Heterogeneous agent routing experiments (SC-MAS/Dr. MAS)
- **iv-quk4** Hierarchical dispatch: meta-agent for N-agent fan-out
- **iv-qjwz** AgentDropout: dynamic redundancy elimination for flux-drive reviews
- **iv-905u** Intermediate result sharing between parallel flux-drive agents

**Clavain: Agency Specs & Orchestration**
- [clavain] **iv-asfy** C1: Agency specs — declarative per-stage agent/model/tool config
- [clavain] **iv-lx00** C2: Agent fleet registry — capability + cost profiles per agent x model
- [clavain] **iv-r9j2** A3: Event-driven advancement — phase transitions trigger auto-dispatch
- [clavain/interphase] **iv-zsio** Integrate full discovery pipeline into sprint workflow
- **iv-frqh** F5: clavain:setup modpack — auto-install ecosystem-only plugins
- **iv-1sc0** F7: Companion plugin dependency graph
- **iv-gye6** F3: Interbase batch SDK adoption (6 plugins)
- **iv-zyym** Evaluate Claude Hub for event-driven GitHub agent dispatch

**Flux-Drive Spec: Library Extraction**
- [flux-drive-spec] **iv-ia66** Phase 2: Extract domain detection library
- [flux-drive-spec] **iv-0etu** Phase 3: Extract scoring/synthesis Python library
- [flux-drive-spec] **iv-e8dg** Phase 4: Migrate Clavain to consume the library
- [interflux] **iv-wz3j** Role-aware latent memory architecture experiments
- **iv-6ikc** Plan intershift extraction (cross-AI dispatch engine)
- **iv-sdqv** Plan interscribe extraction (knowledge compounding)
- **iv-p4qq** Smart semantic caching across sessions (intercache)

**Token Efficiency & Benchmarks**
- **iv-0lt** Extract cache_hints metrics in score_tokens.py
- **iv-1gb** Add cache-friendly format queries to regression_suite.json
- **iv-4728** Consolidate upstream-check.sh API calls (24 to 12)
- **iv-3w1x** Split upstreams.json into config + state files
- [interstat] **iv-v81k** Repository-aware benchmark expansion for agent coding tasks
- **iv-xuec** Security threat model for token optimization techniques

**Autarch TUI & Memory**
- [autarch] **iv-26pj** Streaming buffer / history split per agent panel
- [autarch] **iv-ht1l** Pollard: progressive result reveal per hunter
- [autarch] **iv-xlpg** Pollard: optional-death hunter resilience
- [autarch] **iv-knwr** pkg/tui: validate components with kernel data
- [intermem] **iv-f7po** F3: Multi-file tiered promotion — AGENTS.md index + docs/intermem/ detail
- [intermem] **iv-bn4j** F4: One-shot tiered migration — --migrate-to-tiered

**Research: Architecture & Product Strategy**
- **iv-3kee** Research: product-native agent orchestration (whitespace opportunity)
- **iv-dthn** Research: inter-layer feedback loops and optimization thresholds
- **iv-l5ap** Research: transactional orchestration & error recovery patterns
- **iv-fzrn** Research: multi-agent hallucination cascades & failure taxonomy
- **iv-exos** Research: bias-aware product decision framework
- **iv-jk7q** Research: cognitive load budgets & progressive disclosure review UX

--- 2026-02-21T04:46:49Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: <!-- LLM:MODULE_HIGHLIGHTS
Task: Write 2-3 sentence summaries for these modules.
Format: ### module (location)
vX.Y.Z. Summary text.

Modules needing highlights:
interkasten|plugins/interkasten

END LLM:MODULE_HIGHLIGHTS -->
NEW: ### interkasten (plugins/interkasten)
Interkasten synchronizes project documentation between local filesystems and Notion databases with bidirectional sync, three-way merge conflict resolution, and crash-safe WAL protocols. It exposes 21 MCP tools for hierarchy discovery, filesystem signal gathering, and sync control — delegating classification and tagging decisions to agent logic rather than hardcoding behavior.

--- 2026-02-21T04:47:02Z | plugins/interchart/CLAUDE.md | CONTEXT:unknown ---
OLD: # interchart

Interactive ecosystem diagram generator. Scans Interverse monorepo and generates a D3.js force graph.

## Quick Commands

```bash
# Generate diagram
bash scripts/generate.sh /root/projects/Interverse

# Run scanner only (JSON to stdout)
node scripts/scan.js /root/projects/Interverse

# Test locally
claude --plugin-dir /root/projects/Interverse/plugins/interchart

# Validate structure
ls skills/*/SKILL.md | wc -l          # Should be 1
python3 -c "import json; json.load(open('.claude-plugin/plugin.json'))"
```

## Design Decisions (Do Not Re-Ask)

- Static scanning only — no MCP servers, no runtime dependencies
- D3.js v7 force graph — self-contained HTML with CDN link
- Node.js scanner — reads plugin.json, skills, hooks across monorepo
- Output: single HTML file at `docs/diagrams/ecosystem.html`
NEW: # interchart

Interactive ecosystem diagram generator for Interverse. See `AGENTS.md` for architecture, data model, and troubleshooting.

## Quick Commands

```bash
# Generate diagram
bash scripts/generate.sh /root/projects/Interverse

# Scanner only (JSON to stdout)
node scripts/scan.js /root/projects/Interverse

# Deploy to GitHub Pages
bash scripts/regenerate-and-deploy.sh /root/projects/Interverse
```

## Design Decisions (Do Not Re-Ask)

- Static scanning only — no MCP servers, no runtime dependencies
- D3.js v7 force graph — self-contained HTML, CDN-loaded D3
- Node.js scanner — reads plugin.json, SKILL.md, hooks.json across monorepo
- Output: single HTML file at `docs/diagrams/ecosystem.html`
- Overlaps shown as convex hull domain overlays, not edges
- Server-side cron (every 5 min) — no GitHub Actions for regeneration
- Template variables must be defined before use (no hoisting for `const`/`let`)

--- 2026-02-21T04:48:17Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: <!-- LLM:RESEARCH_AGENDA
Task: Synthesize into 10-15 thematic research bullets.
Format: - **Topic** — 1-line summary

Brainstorm files:
2026-02-15-linsenkasten-flux-agents-brainstorm
2026-02-15-multi-session-phase4-merge-agent-brainstorm
2026-02-15-sprint-resilience-brainstorm
2026-02-15-token-efficient-skill-loading
2026-02-16-agent-rig-autonomous-sync-brainstorm
2026-02-16-flux-drive-document-slicing-brainstorm
2026-02-16-interbus-central-integration-mesh-brainstorm
2026-02-16-linsenkasten-phase1-agents-brainstorm
2026-02-16-sprint-resilience-phase2-brainstorm
2026-02-16-subagent-context-flooding-brainstorm
2026-02-16-token-budget-controls-brainstorm
2026-02-19-intercore-e3-hook-cutover-brainstorm
2026-02-19-reflect-phase-learning-loop-brainstorm
2026-02-20-autarch-status-tool-brainstorm
2026-02-20-bigend-migration-brainstorm
2026-02-20-cost-aware-agent-scheduling-brainstorm
2026-02-20-dual-mode-plugin-architecture-brainstorm
2026-02-20-interchart-ecosystem-diagram-brainstorm
2026-02-20-intercore-e5-discovery-pipeline-brainstorm
2026-02-20-intercore-rollback-recovery-brainstorm
2026-02-20-plugin-synergy-catalog-brainstorm
2026-02-20-sprint-handover-kernel-driven-brainstorm
2026-02-21-intercore-e8-portfolio-orchestration
2026-02-21-portfolio-dependency-scheduling

Plan files:
2026-02-15-cross-module-integration-opportunities
2026-02-15-linsenkasten-flux-agents
2026-02-15-multi-session-coordination-brainstorm
2026-02-15-sprint-resilience-phase1
2026-02-15-token-efficient-skill-loading
2026-02-16-flux-drive-document-slicing
2026-02-16-linsenkasten-phase1-remaining-agents
2026-02-16-sprint-resilience-phase2
2026-02-16-subagent-context-flooding
2026-02-16-token-budget-controls
2026-02-17-framework-benchmark-freshness-automation
2026-02-17-heterogeneous-collaboration-routing
2026-02-17-interband-sideband-hardening
2026-02-17-multi-framework-interoperability-benchmark
2026-02-17-repository-aware-benchmark-expansion
2026-02-17-role-aware-latent-memory-experiments
2026-02-19-bias-aware-product-decision-framework
2026-02-19-blueprint-distillation-sprint-intake
2026-02-19-catalog-reminder-interwatch-escalation
2026-02-19-clavain-roadmap-vision-alignment
2026-02-19-hierarchical-dispatch-meta-agent
2026-02-19-intercore-e3-hook-cutover
2026-02-19-intercore-spawn-handler-wiring
2026-02-19-interscribe-extraction-plan
2026-02-19-session-start-drift-summary-injection
2026-02-19-shift-work-boundary-formalization
2026-02-19-tldrs-import-graph-compression-dedup
2026-02-19-tldrs-longcodezip-block-compression
2026-02-19-tldrs-precomputed-context-bundles
2026-02-19-tldrs-structured-output-serialization
2026-02-19-tldrs-symbol-popularity-index
2026-02-20-autarch-status-tool
2026-02-20-cost-aware-agent-scheduling
2026-02-20-dual-mode-plugin-architecture
2026-02-20-interchart-ecosystem-diagram
2026-02-20-intercore-e5-discovery-pipeline
2026-02-20-intercore-rollback-recovery
2026-02-20-plugin-synergy-interop
2026-02-20-reflect-phase-sprint-integration
2026-02-20-sprint-handover-kernel-driven
2026-02-20-tui-kernel-validation
2026-02-21-intercore-e8-portfolio-orchestration
2026-02-21-portfolio-dependency-scheduling
2026-02-21-static-routing-table

END LLM:RESEARCH_AGENDA -->
NEW: - **Sprint Lifecycle Kernel Migration** — Migrate Clavain sprint state from beads-backed temp files to intercore kernel, unified phase chain, and kernel-driven dispatch via SpawnHandler events
- **Token-Efficient Context Delivery** — Compress symbol imports, enable block-level compression, precompute workspace bundles, track symbol popularity, and add structured output serialization to reduce context-pack footprint by 40-60%
- **Cost-Aware Agent Dispatch** — Wire token budgets across sprint setup, flux-drive triage, and dispatch execution with real-time budget visibility via interstat and automated cost-quality tradeoffs
- **Plugin Synergy via Interband** — Connect plugins through atomic interband signals for context pressure, budget alerts, tool performance hints, and cross-plugin nudges; establish dual-mode architecture patterns
- **Bigend Dashboard Kernel Sourcing** — Migrate agent status monitoring from filesystem/tmux scraping to kernel-native `ic` CLI, displaying runs, phases, dispatches, events, and token metrics
- **Cognitive Review Agents (Interlens)** — Build lens-based review agents (fd-decisions, fd-people, fd-resilience, fd-perception) from FLUX thematic frames with severity tiers and cognitive deduplication
- **Subagent Context Flooding Prevention** — Implement write-behind protocol for multi-agent dispatch so agent results persist to disk while only summaries enter orchestrator context
- **Sprint Resilience & Autonomous Advance** — Redesign `/sprint` with parent-child bead hierarchy, auto-resume, tiered autonomy (auto-advance non-decision phases, pause on gates/ambiguity), and single source of truth
- **Heterogeneous Model Routing** — Route multi-agent dispatch by model capability (economy vs. quality), implement role-aware memory persistence, bias-aware decision frameworks, and hierarchical orchestration
- **Intercore Discovery Pipeline** — Build kernel-aware project discovery, cross-project run queries, portfolio-level aggregate metrics, and reactive discovery hooks
- **Portfolio Orchestration & Dependency Scheduling** — Manage multi-run portfolios with dependency graphs, cost amortization, work prioritization via internext, and distributed task execution
- **Intercore Rollback & Recovery** — Implement phase rollback with audit trail, automatic state reconciliation on crashes, state divergence detection, and rollback gates
- **Agent Rig Autonomous Sync** — Add bidirectional sync between Clavain bead metadata and kernel run state, upstream artifact propagation, and automatic context refresh for resumed sprints
- **Ecosystem Architecture Formalization** — Diagram plugin dependency layers, interband signal topology, beads integration surface, and MCP capability matrix; establish design gates for new modules

--- 2026-02-21T04:48:44Z | infra/intercore/internal/portfolio/deps.go | CONTEXT:unknown ---
OLD: // DepStore provides project dependency operations against the intercore DB.
type DepStore struct {
	db *sql.DB
}

// NewDepStore creates a dependency store.
func NewDepStore(db *sql.DB) *DepStore {
	return &DepStore{db: db}
}

// Add inserts a dependency edge. Returns error if duplicate or would create a cycle.
func (s *DepStore) Add(ctx context.Context, portfolioRunID, upstream, downstream string) error {
	if upstream == downstream {
		return fmt.Errorf("add dep: upstream and downstream cannot be the same project")
	}
	// Check for cycles: if downstream can already reach upstream via existing edges,
	// adding upstream→downstream would create a cycle.
	reachable, err := s.HasPath(ctx, portfolioRunID, downstream, upstream)
	if err != nil {
		return fmt.Errorf("add dep: cycle check: %w", err)
	}
	if reachable {
		return fmt.Errorf("add dep: cycle detected: adding %s → %s would create a cycle", upstream, downstream)
	}
	_, err = s.db.ExecContext(ctx, `
		INSERT INTO project_deps (portfolio_run_id, upstream_project, downstream_project, created_at)
		VALUES (?, ?, ?, ?)`,
		portfolioRunID, upstream, downstream, time.Now().Unix(),
	)
	if err != nil {
		return fmt.Errorf("add dep: %w", err)
	}
	return nil
}
NEW: // queryCtx abstracts *sql.DB and *sql.Tx for use in HasPath.
type queryCtx interface {
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
}

// DepStore provides project dependency operations against the intercore DB.
type DepStore struct {
	db *sql.DB
}

// NewDepStore creates a dependency store.
func NewDepStore(db *sql.DB) *DepStore {
	return &DepStore{db: db}
}

// Add inserts a dependency edge. Returns error if duplicate or would create a cycle.
// The cycle check and INSERT are wrapped in a single transaction to prevent TOCTOU races.
func (s *DepStore) Add(ctx context.Context, portfolioRunID, upstream, downstream string) error {
	if upstream == downstream {
		return fmt.Errorf("add dep: upstream and downstream cannot be the same project")
	}

	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("add dep: begin tx: %w", err)
	}
	defer tx.Rollback()

	// Check for cycles within the transaction: if downstream can already reach
	// upstream via existing edges, adding upstream→downstream would create a cycle.
	reachable, err := hasPath(ctx, tx, portfolioRunID, downstream, upstream)
	if err != nil {
		return fmt.Errorf("add dep: cycle check: %w", err)
	}
	if reachable {
		return fmt.Errorf("add dep: cycle detected: adding %s → %s would create a cycle", upstream, downstream)
	}

	_, err = tx.ExecContext(ctx, `
		INSERT INTO project_deps (portfolio_run_id, upstream_project, downstream_project, created_at)
		VALUES (?, ?, ?, ?)`,
		portfolioRunID, upstream, downstream, time.Now().Unix(),
	)
	if err != nil {
		return fmt.Errorf("add dep: %w", err)
	}

	return tx.Commit()
}

--- 2026-02-21T04:48:57Z | infra/intercore/internal/portfolio/deps.go | CONTEXT:unknown ---
OLD: // HasPath checks whether a directed path of length >= 1 exists from 'from' to
// 'to' in the dependency graph using DFS. Returns true if 'to' is reachable
// from 'from' by following at least one edge.
func (s *DepStore) HasPath(ctx context.Context, portfolioRunID, from, to string) (bool, error) {
	visited := make(map[string]bool)
	// Start DFS from from's immediate downstream neighbors (not from itself)
	// so we require at least one edge traversal.
	initial, err := s.GetDownstream(ctx, portfolioRunID, from)
	if err != nil {
		return false, err
	}
	stack := initial
	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if node == to {
			return true, nil
		}
		if visited[node] {
			continue
		}
		visited[node] = true
		downstream, err := s.GetDownstream(ctx, portfolioRunID, node)
		if err != nil {
			return false, err
		}
		stack = append(stack, downstream...)
	}
	return false, nil
}
NEW: // HasPath checks whether a directed path of length >= 1 exists from 'from' to
// 'to' in the dependency graph using DFS. Returns true if 'to' is reachable
// from 'from' by following at least one edge.
func (s *DepStore) HasPath(ctx context.Context, portfolioRunID, from, to string) (bool, error) {
	return hasPath(ctx, s.db, portfolioRunID, from, to)
}

// hasPath is the internal DFS implementation that works with any queryCtx (DB or Tx).
func hasPath(ctx context.Context, q queryCtx, portfolioRunID, from, to string) (bool, error) {
	visited := make(map[string]bool)
	// Start DFS from from's immediate downstream neighbors (not from itself)
	// so we require at least one edge traversal.
	initial, err := getDownstreamQ(ctx, q, portfolioRunID, from)
	if err != nil {
		return false, err
	}
	stack := initial
	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if node == to {
			return true, nil
		}
		if visited[node] {
			continue
		}
		visited[node] = true
		downstream, err := getDownstreamQ(ctx, q, portfolioRunID, node)
		if err != nil {
			return false, err
		}
		stack = append(stack, downstream...)
	}
	return false, nil
}

--- 2026-02-21T04:49:04Z | infra/intercore/internal/portfolio/deps.go | CONTEXT:unknown ---
OLD: // GetDownstream returns all downstream projects for a given upstream project in a portfolio.
func (s *DepStore) GetDownstream(ctx context.Context, portfolioRunID, upstream string) ([]string, error) {
	rows, err := s.db.QueryContext(ctx, `
		SELECT downstream_project FROM project_deps
		WHERE portfolio_run_id = ? AND upstream_project = ?
		ORDER BY downstream_project ASC`, portfolioRunID, upstream)
	if err != nil {
		return nil, fmt.Errorf("get downstream: %w", err)
	}
	defer rows.Close()

	var projects []string
	for rows.Next() {
		var p string
		if err := rows.Scan(&p); err != nil {
			return nil, fmt.Errorf("get downstream scan: %w", err)
		}
		projects = append(projects, p)
	}
	return projects, rows.Err()
}
NEW: // GetDownstream returns all downstream projects for a given upstream project in a portfolio.
func (s *DepStore) GetDownstream(ctx context.Context, portfolioRunID, upstream string) ([]string, error) {
	return getDownstreamQ(ctx, s.db, portfolioRunID, upstream)
}

// getDownstreamQ is the internal implementation that works with any queryCtx.
func getDownstreamQ(ctx context.Context, q queryCtx, portfolioRunID, upstream string) ([]string, error) {
	rows, err := q.QueryContext(ctx, `
		SELECT downstream_project FROM project_deps
		WHERE portfolio_run_id = ? AND upstream_project = ?
		ORDER BY downstream_project ASC`, portfolioRunID, upstream)
	if err != nil {
		return nil, fmt.Errorf("get downstream: %w", err)
	}
	defer rows.Close()

	var projects []string
	for rows.Next() {
		var p string
		if err := rows.Scan(&p); err != nil {
			return nil, fmt.Errorf("get downstream scan: %w", err)
		}
		projects = append(projects, p)
	}
	return projects, rows.Err()
}

--- 2026-02-21T04:49:43Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 				if upstreamRun.Status == StatusCompleted {
					continue // completed upstreams don't block
				}
NEW: 				if upstreamRun.Status == StatusCompleted || upstreamRun.Status == StatusCancelled || upstreamRun.Status == StatusFailed {
					continue // terminal upstreams don't block
				}

--- 2026-02-21T04:49:52Z | infra/intercore/cmd/ic/portfolio.go | CONTEXT:unknown ---
OLD: 		if child.Status == phase.StatusCompleted || child.Status == phase.StatusCancelled {
NEW: 		if child.Status == phase.StatusCompleted || child.Status == phase.StatusCancelled || child.Status == phase.StatusFailed {

--- 2026-02-21T04:50:18Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 			siblingByProject := make(map[string]*Run)
			for _, s := range siblings {
				siblingByProject[s.ProjectDir] = s
			}
NEW: 			siblingByProject := make(map[string]*Run)
			for _, s := range siblings {
				if _, exists := siblingByProject[s.ProjectDir]; !exists {
					siblingByProject[s.ProjectDir] = s
				}
			}

--- 2026-02-21T04:50:25Z | infra/intercore/cmd/ic/portfolio.go | CONTEXT:unknown ---
OLD: 	childByProject := make(map[string]*phase.Run)
	for _, c := range children {
		childByProject[c.ProjectDir] = c
	}
NEW: 	childByProject := make(map[string]*phase.Run)
	for _, c := range children {
		if _, exists := childByProject[c.ProjectDir]; !exists {
			childByProject[c.ProjectDir] = c
		}
	}

--- 2026-02-21T04:54:12Z | infra/intercore/internal/portfolio/topo.go | CONTEXT:unknown ---
OLD: package portfolio

import "fmt"

// TopologicalSort returns projects in dependency-respecting order (upstreams first)
// using Kahn's algorithm. Returns an error if a cycle is detected.
func TopologicalSort(deps []Dep) ([]string, error) {
	// Build adjacency list and in-degree map
	inDegree := make(map[string]int)
	downstream := make(map[string][]string)

	// Collect all nodes
	for _, d := range deps {
		if _, ok := inDegree[d.UpstreamProject]; !ok {
			inDegree[d.UpstreamProject] = 0
		}
		if _, ok := inDegree[d.DownstreamProject]; !ok {
			inDegree[d.DownstreamProject] = 0
		}
		downstream[d.UpstreamProject] = append(downstream[d.UpstreamProject], d.DownstreamProject)
		inDegree[d.DownstreamProject]++
	}

	// Seed queue with zero-in-degree nodes
	var queue []string
	for node, deg := range inDegree {
		if deg == 0 {
			queue = append(queue, node)
		}
	}

	var order []string
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		order = append(order, node)
		for _, next := range downstream[node] {
			inDegree[next]--
			if inDegree[next] == 0 {
				queue = append(queue, next)
			}
		}
	}

	if len(order) != len(inDegree) {
		return nil, fmt.Errorf("topo sort: cycle detected (%d nodes, %d sorted)", len(inDegree), len(order))
	}
	return order, nil
}
NEW: package portfolio

import (
	"fmt"
	"sort"
)

// TopologicalSort returns projects in dependency-respecting order (upstreams first)
// using Kahn's algorithm. The output is deterministic: ties among nodes at the
// same topological level are broken by lexicographic sort.
func TopologicalSort(deps []Dep) ([]string, error) {
	// Build adjacency list and in-degree map
	inDegree := make(map[string]int)
	downstream := make(map[string][]string)

	// Collect all nodes
	for _, d := range deps {
		if _, ok := inDegree[d.UpstreamProject]; !ok {
			inDegree[d.UpstreamProject] = 0
		}
		if _, ok := inDegree[d.DownstreamProject]; !ok {
			inDegree[d.DownstreamProject] = 0
		}
		downstream[d.UpstreamProject] = append(downstream[d.UpstreamProject], d.DownstreamProject)
		inDegree[d.DownstreamProject]++
	}

	// Seed queue with zero-in-degree nodes (sorted for determinism)
	var queue []string
	for node, deg := range inDegree {
		if deg == 0 {
			queue = append(queue, node)
		}
	}
	sort.Strings(queue)

	var order []string
	for len(queue) > 0 {
		node := queue[0]
		queue = queue[1:]
		order = append(order, node)
		var ready []string
		for _, next := range downstream[node] {
			inDegree[next]--
			if inDegree[next] == 0 {
				ready = append(ready, next)
			}
		}
		sort.Strings(ready)
		queue = append(queue, ready...)
	}

	if len(order) != len(inDegree) {
		return nil, fmt.Errorf("topo sort: cycle detected (%d nodes, %d sorted)", len(inDegree), len(order))
	}
	return order, nil
}

--- 2026-02-21T04:54:21Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: func TestAddDep(t *testing.T) {
NEW: func mustAdd(t *testing.T, s *DepStore, ctx context.Context, portfolio, upstream, downstream string) {
	t.Helper()
	if err := s.Add(ctx, portfolio, upstream, downstream); err != nil {
		t.Fatalf("mustAdd(%s → %s): %v", upstream, downstream, err)
	}
}

func TestAddDep(t *testing.T) {

--- 2026-02-21T04:54:25Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: 	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")

	if err := s.Remove(ctx, "portfolio1", "/proj/a", "/proj/b"); err != nil {
NEW: 	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/b")

	if err := s.Remove(ctx, "portfolio1", "/proj/a", "/proj/b"); err != nil {

--- 2026-02-21T04:54:30Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: 	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/c")

	downstream, err := s.GetDownstream(ctx, "portfolio1", "/proj/a")
NEW: 	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/b")
	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/c")

	downstream, err := s.GetDownstream(ctx, "portfolio1", "/proj/a")

--- 2026-02-21T04:54:34Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: 	s.Add(ctx, "portfolio1", "/proj/a", "/proj/c")
	s.Add(ctx, "portfolio1", "/proj/b", "/proj/c")

	upstream, err := s.GetUpstream(ctx, "portfolio1", "/proj/c")
NEW: 	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/c")
	mustAdd(t, s, ctx, "portfolio1", "/proj/b", "/proj/c")

	upstream, err := s.GetUpstream(ctx, "portfolio1", "/proj/c")

--- 2026-02-21T04:54:38Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: 	// A → B, B → C
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")
	s.Add(ctx, "portfolio1", "/proj/b", "/proj/c")

	// Adding C → A should fail (transitive cycle: A→B→C→A)
NEW: 	// A → B, B → C
	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/b")
	mustAdd(t, s, ctx, "portfolio1", "/proj/b", "/proj/c")

	// Adding C → A should fail (transitive cycle: A→B→C→A)

--- 2026-02-21T04:54:42Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: 	// A → B, A → C (diamond top)
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/c")
NEW: 	// A → B, A → C (diamond top)
	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/b")
	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/c")

--- 2026-02-21T04:54:46Z | infra/intercore/internal/portfolio/deps_test.go | CONTEXT:unknown ---
OLD: 	// Build graph: A → B → C
	s.Add(ctx, "portfolio1", "/proj/a", "/proj/b")
	s.Add(ctx, "portfolio1", "/proj/b", "/proj/c")
NEW: 	// Build graph: A → B → C
	mustAdd(t, s, ctx, "portfolio1", "/proj/a", "/proj/b")
	mustAdd(t, s, ctx, "portfolio1", "/proj/b", "/proj/c")

--- 2026-02-21T04:54:59Z | infra/intercore/cmd/ic/portfolio.go | CONTEXT:unknown ---
OLD: 		if upRun.Status == phase.StatusCompleted {
				continue
			}
			upChain := phase.ResolveChain(upRun)
			upIdx := phase.ChainPhaseIndex(upChain, upRun.Phase)
			if upIdx < childIdx {
NEW: 		if upRun.Status == phase.StatusCompleted || upRun.Status == phase.StatusCancelled || upRun.Status == phase.StatusFailed {
				continue
			}
			// Check if upstream has reached child's current phase by name
			// (not by index, since chains may differ)
			upChain := phase.ResolveChain(upRun)
			targetIdx := phase.ChainPhaseIndex(upChain, child.Phase)
			if targetIdx < 0 {
				continue // upstream chain doesn't have this phase
			}
			upIdx := phase.ChainPhaseIndex(upChain, upRun.Phase)
			if upIdx < targetIdx {

--- 2026-02-21T04:55:03Z | infra/intercore/cmd/ic/portfolio.go | CONTEXT:unknown ---
OLD: 		childChain := phase.ResolveChain(child)
		childIdx := phase.ChainPhaseIndex(childChain, child.Phase)

		for _, upstream := range upstreamMap[child.ProjectDir] {
NEW: 		for _, upstream := range upstreamMap[child.ProjectDir] {

--- 2026-02-21T04:56:09Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: .legend {
  position: fixed; bottom: 12px; left: 192px;
  background: rgba(22, 27, 34, 0.9); border: 1px solid #30363d;
  border-radius: 8px; padding: 10px 14px; font-size: 11px; z-index: 80;
}
.legend-item { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; }
.legend-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
NEW: 

--- 2026-02-21T04:56:13Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div class="legend" id="legend"></div>
NEW: 

--- 2026-02-21T04:56:19Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // Build legend
const legend = document.getElementById('legend');
for (const [type, color] of Object.entries(TYPE_COLORS)) {
  if (!(data.stats.byType[type] > 0)) continue;
  const item = document.createElement('div');
  item.className = 'legend-item';
  const dot = document.createElement('div');
  dot.className = 'legend-dot';
  dot.style.background = color;
  item.appendChild(dot);
  item.appendChild(document.createTextNode(TYPE_LABELS[type]));
  legend.appendChild(item);
}

// D3 Setup
NEW: // D3 Setup

--- 2026-02-21T04:58:08Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #filter-sidebar {
  position: fixed;
  top: 44px;
  left: 0;
  width: 180px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
NEW: #filter-sidebar {
  position: fixed;
  top: 44px;
  left: 0;
  width: 180px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  transition: transform 0.25s ease, opacity 0.25s ease;
}
#filter-sidebar.collapsed {
  transform: translateX(-180px);
  opacity: 0;
  pointer-events: none;
}

--- 2026-02-21T04:58:15Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #graph { width: 100vw; height: 100vh; padding-top: 44px; padding-left: 180px; }
NEW: #graph { width: 100vw; height: 100vh; padding-top: 44px; padding-left: 180px; transition: padding-left 0.25s ease; }
#graph.sidebar-collapsed { padding-left: 0; }

--- 2026-02-21T04:58:23Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #search-box {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  padding: 4px 10px; border-radius: 6px; font-size: 12px;
  width: 160px; margin-left: auto;
}
#search-box:focus { outline: none; border-color: #58a6ff; }
NEW: #sidebar-toggle {
  background: none; border: 1px solid #30363d; color: #8b949e;
  width: 28px; height: 28px; border-radius: 6px; cursor: pointer;
  font-size: 14px; display: flex; align-items: center; justify-content: center;
  transition: all 0.15s; flex-shrink: 0;
}
#sidebar-toggle:hover { border-color: #58a6ff; color: #58a6ff; }

#search-box {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  padding: 4px 10px; border-radius: 6px; font-size: 12px;
  width: 160px; margin-left: auto;
}
#search-box:focus { outline: none; border-color: #58a6ff; }

--- 2026-02-21T04:58:29Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div id="toolbar">
  <span class="title">Interverse Ecosystem</span>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>
NEW: <div id="toolbar">
  <button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
  <span class="title">Interverse Ecosystem</span>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

--- 2026-02-21T04:58:51Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function applyFilters() {
NEW: function toggleSidebar() {
  var sidebar = document.getElementById('filter-sidebar');
  var graph = document.getElementById('graph');
  sidebar.classList.toggle('collapsed');
  graph.classList.toggle('sidebar-collapsed');
}

function applyFilters() {

--- 2026-02-21T05:04:16Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div id="filter-sidebar">
NEW: <div id="filter-sidebar" class="collapsed">

--- 2026-02-21T05:04:24Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #graph { width: 100vw; height: 100vh; padding-top: 44px; padding-left: 180px; transition: padding-left 0.25s ease; }
#graph.sidebar-collapsed { padding-left: 0; }
NEW: #graph { width: 100vw; height: 100vh; padding-top: 44px; }

--- 2026-02-21T05:04:31Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function toggleSidebar() {
  var sidebar = document.getElementById('filter-sidebar');
  var graph = document.getElementById('graph');
  sidebar.classList.toggle('collapsed');
  graph.classList.toggle('sidebar-collapsed');
}
NEW: function toggleSidebar() {
  document.getElementById('filter-sidebar').classList.toggle('collapsed');
}

--- 2026-02-21T05:04:41Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: const sidebarWidth = 180;
const width = window.innerWidth;
NEW: const width = window.innerWidth;

--- 2026-02-21T05:04:45Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   .force('center', d3.forceCenter((width - sidebarWidth) / 2 + sidebarWidth, height / 2))
NEW:   .force('center', d3.forceCenter(width / 2, height / 2))

--- 2026-02-21T05:04:52Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   var graphWidth = width - sidebarWidth;
  var scale = 0.8 / Math.max(bounds.width / graphWidth, bounds.height / height);
  var midX = bounds.x + bounds.width / 2;
  var midY = bounds.y + bounds.height / 2;
  svg.transition().duration(750).call(
    zoomBehavior.transform,
    d3.zoomIdentity.translate(graphWidth / 2 + sidebarWidth - scale * midX, height / 2 - scale * midY).scale(scale)
NEW:   var scale = 0.8 / Math.max(bounds.width / width, bounds.height / height);
  var midX = bounds.x + bounds.width / 2;
  var midY = bounds.y + bounds.height / 2;
  svg.transition().duration(750).call(
    zoomBehavior.transform,
    d3.zoomIdentity.translate(width / 2 - scale * midX, height / 2 - scale * midY).scale(scale)

--- 2026-02-21T05:07:36Z | plugins/interchart/scripts/regenerate-and-deploy.sh | CONTEXT:unknown ---
OLD: # Check if anything changed
CURRENT="$INTERVERSE_ROOT/docs/diagrams/ecosystem.html"
if [ -f "$CURRENT" ]; then
  OLD_NODES=$(grep -o '"nodes":[0-9]*' "$CURRENT" | head -1 || true)
  NEW_NODES=$(grep -o '"nodes":[0-9]*' "$TMPHTML" | head -1 || true)
  if [ "$OLD_NODES" = "$NEW_NODES" ]; then
    rm "$TMPHTML"
    exit 0
  fi
fi
NEW: # Check if anything changed (compare full file hash, not just node count)
CURRENT="$INTERVERSE_ROOT/docs/diagrams/ecosystem.html"
if [ -f "$CURRENT" ]; then
  OLD_HASH=$(sha256sum "$CURRENT" | cut -d' ' -f1)
  NEW_HASH=$(sha256sum "$TMPHTML" | cut -d' ' -f1)
  if [ "$OLD_HASH" = "$NEW_HASH" ]; then
    rm "$TMPHTML"
    exit 0
  fi
fi

--- 2026-02-21T05:08:31Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: internal/portfolio/     Portfolio orchestration: cross-project coordination
  deps.go               DepStore: project dependency CRUD with self-loop prevention
  dbpool.go             DBPool: read-only cached handles to child project databases
  relay.go              Relay: polls child DBs, relays events, tracks dispatch counts
  deps_test.go          Unit tests (7 tests)
NEW: internal/portfolio/     Portfolio orchestration: cross-project coordination
  deps.go               DepStore: project dependency CRUD with cycle detection (DFS + transactional add)
  topo.go               TopologicalSort: deterministic Kahn's algorithm for dependency-respecting order
  dbpool.go             DBPool: read-only cached handles to child project databases
  relay.go              Relay: polls child DBs, relays events, tracks dispatch counts
  deps_test.go          Unit tests (11 tests including cycle detection)
  topo_test.go          Topo sort tests (5 tests: linear, diamond, forest, empty, cycle)

--- 2026-02-21T05:08:36Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ic portfolio relay <id> [--interval=2s]    Start event relay (blocks, SIGINT to stop)
NEW: ic portfolio relay <id> [--interval=2s]    Start event relay (blocks, SIGINT to stop)
ic portfolio order <id>                   Print topological build order (deterministic)
ic portfolio status <id>                  Show per-child readiness with blocked-by details

--- 2026-02-21T05:08:41Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: cmd/ic/portfolio.go     Portfolio subcommands (dep add/list/remove, relay)
NEW: cmd/ic/portfolio.go     Portfolio subcommands (dep add/list/remove, relay, order, status)

--- 2026-02-21T05:08:50Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: **Checks:**
- `artifact_exists` — requires at least one artifact recorded for the source phase
- `agents_complete` — requires no active agents (all completed or failed)
- `verdict_exists` — requires a non-rejected dispatch verdict (needs `scope_id` on the run)
- `children_at_phase` — (portfolio only) requires all active children at or past target phase

**Interfaces:** Gate evaluation uses `RuntrackQuerier`, `VerdictQuerier`, and `PortfolioQuerier` interfaces to avoid cross-package coupling. The actual implementations live in `runtrack.Store`, `dispatch.Store`, and `phase.Store`.
NEW: **Checks:**
- `artifact_exists` — requires at least one artifact recorded for the source phase
- `agents_complete` — requires no active agents (all completed or failed)
- `verdict_exists` — requires a non-rejected dispatch verdict (needs `scope_id` on the run)
- `children_at_phase` — (portfolio only) requires all active children at or past target phase
- `upstreams_at_phase` — (child runs with deps) blocks if upstream projects haven't reached the target phase; terminal upstreams (completed/cancelled/failed) don't block

**Interfaces:** Gate evaluation uses `RuntrackQuerier`, `VerdictQuerier`, `PortfolioQuerier`, and `DepQuerier` interfaces to avoid cross-package coupling. The actual implementations live in `runtrack.Store`, `dispatch.Store`, `phase.Store`, and `portfolio.DepStore`.

--- 2026-02-21T05:09:03Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ### Project Dependencies

The `project_deps` table stores directed dependency edges between child projects within a portfolio. Used by the relay to emit `upstream_changed` events.

```
ic portfolio dep add <portfolio-id> --upstream=/path/a --downstream=/path/b
```

Self-loop prevention: upstream == downstream is rejected. Paths are normalized to absolute via `filepath.Abs`.
NEW: ### Project Dependencies

The `project_deps` table stores directed dependency edges between child projects within a portfolio. Used by the relay to emit `upstream_changed` events and by the `upstreams_at_phase` gate check to block downstream advancement.

```
ic portfolio dep add <portfolio-id> --upstream=/path/a --downstream=/path/b
```

**Validation:** Self-loop prevention (upstream == downstream rejected). Cycle detection via DFS reachability check (`HasPath`) — if downstream can already reach upstream via existing edges, adding the edge would create a cycle. Paths are normalized to absolute via `filepath.Abs`.

**Transactional safety:** The cycle check and INSERT are wrapped in a single `BeginTx` transaction to prevent TOCTOU races where two concurrent `dep add` calls both pass the cycle check and both insert edges that form a cycle.

### Dependency Scheduling (E9)

Child runs in a portfolio can have their phase advancement gated by upstream dependencies. When a child run has upstream deps, the `upstreams_at_phase` gate check blocks advancement until all upstream projects have reached (or passed) the target phase.

**Terminal status handling:** Completed, cancelled, and failed upstream runs are treated as non-blocking. A cancelled or failed upstream should not permanently block downstream progress.

**Topological ordering:** `ic portfolio order <id>` computes a dependency-respecting build order using Kahn's algorithm. Output is deterministic — ties among nodes at the same topological level are broken lexicographically.

**Portfolio status:** `ic portfolio status <id>` shows per-child readiness with blocked-by details. Each child is marked as ready or blocked, with the specific upstream(s) causing the block.

--- 2026-02-21T05:09:11Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ### Portfolio Gates

Portfolio runs automatically receive a `children_at_phase` gate check. This gate blocks the portfolio from advancing to phase P unless all active children have reached phase P (or later) in their own chains.

- Completed and cancelled children don't block
- Failed children DO block (intentional — portfolio should not advance past a failed child)
- Children whose chain doesn't contain the target phase are treated as "past it"
- Gate freshness is bounded by the relay poll interval (default 2s)

The gate uses the `PortfolioQuerier` interface (`GetChildren(ctx, runID)`) to avoid cross-package coupling.
NEW: ### Portfolio Gates

Portfolio runs automatically receive a `children_at_phase` gate check. This gate blocks the portfolio from advancing to phase P unless all active children have reached phase P (or later) in their own chains.

- Completed and cancelled children don't block
- Failed children DO block (intentional — portfolio should not advance past a failed child)
- Children whose chain doesn't contain the target phase are treated as "past it"
- Gate freshness is bounded by the relay poll interval (default 2s)

The gate uses the `PortfolioQuerier` interface (`GetChildren(ctx, runID)`) to avoid cross-package coupling.

**Child dependency gates:** Child runs with upstream dependencies automatically receive an `upstreams_at_phase` gate check in addition to standard gates. This gate blocks the child from advancing to phase P unless all upstream projects have reached phase P. The gate uses the `DepQuerier` interface (`GetUpstream(ctx, portfolioRunID, project)`) — only injected for child runs that have a `parent_run_id`.

- Terminal upstreams (completed, cancelled, failed) don't block
- Upstream chains that don't contain the target phase are treated as "past it"
- If no upstream dependencies exist, the gate passes immediately

--- 2026-02-21T05:09:15Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: go test ./...                    # Unit tests (~140 tests across 12 packages)
NEW: go test ./...                    # Unit tests (~155 tests across 12 packages)

--- 2026-02-21T05:09:19Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: test-integration.sh     End-to-end integration test (~93 tests)
NEW: test-integration.sh     End-to-end integration test (~105 tests)

--- 2026-02-21T05:09:23Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: bash test-integration.sh         # Full CLI integration test (~100+ tests)
NEW: bash test-integration.sh         # Full CLI integration test (~105+ tests)

--- 2026-02-21T05:09:27Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: | dispatch create | No transaction | Single INSERT |
NEW: | dep add | Transaction (default) | Cycle check + INSERT atomicity (TOCTOU prevention) |
| dispatch create | No transaction | Single INSERT |

--- 2026-02-21T05:10:01Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   width: 180px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  transition: transform 0.25s ease, opacity 0.25s ease;
}
#filter-sidebar.collapsed {
  transform: translateX(-180px);
NEW:   width: 240px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  transition: transform 0.25s ease, opacity 0.25s ease;
}
#filter-sidebar.collapsed {
  transform: translateX(-240px);

--- 2026-02-21T05:12:49Z | plugins/interchart/AGENTS.md | CONTEXT:unknown ---
OLD: - **Filter sidebar** (left, 180px): Type filters with colored dots + domain hull toggles
- **Graph area** (center): D3.js force-directed SVG
- **Detail panel** (right, slides in): Node metadata, relationships, external links
- **Legend** (bottom-left): Node type color key
NEW: - **Filter sidebar** (left, 240px, overlay): Type filters with colored dots + domain hull toggles. Starts collapsed; toggle with hamburger button. Overlays the graph (no layout shift).
- **Graph area** (center): D3.js force-directed SVG (full viewport width)
- **Detail panel** (right, slides in): Node metadata, relationships, external links

--- 2026-02-21T05:12:57Z | plugins/interchart/AGENTS.md | CONTEXT:unknown ---
OLD: - **`box-sizing: border-box`**: The template uses this globally. The `#graph` div has `padding-left: 180px` for the sidebar — the SVG content area is `100vw - 180px`, not `100vw`.
NEW: - **`box-sizing: border-box`**: The template uses this globally. The sidebar overlays the graph (no `padding-left`) so the SVG content area is the full `100vw`.

--- 2026-02-21T05:19:02Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ### dispatch.sh Resolution (spawn)

1. `--dispatch-sh=<path>` flag
2. `CLAVAIN_DISPATCH_SH` env var
3. Walk up from CWD for `os/clavain/scripts/dispatch.sh`
4. Fallback: bare `codex exec` (no JSONL, no verdict)

### Spawn Flags

```
--type=codex          Agent type (default: codex)
--prompt-file=<path>  Required: prompt file path
--project=<dir>       Required: working directory (default: CWD)
--output=<path>       Output file path (auto-generated if omitted)
--name=<label>        Human-readable label
--model=<model>       Codex model
--sandbox=<mode>      Sandbox mode (default: workspace-write)
--timeout=<dur>       Agent timeout
--scope-id=<id>       Grouping scope
--parent-id=<id>      Parent dispatch ID (fan-out tracking)
--dispatch-sh=<path>  Explicit dispatch.sh path
```

### Reparented Process Handling

When `ic dispatch spawn` exits after forking, dispatch.sh gets reparented to init. Later `ic dispatch poll` can't `waitpid()` it, so liveness uses three convergent signals:
- `kill(pid, 0)` returning ESRCH (process gone)
- State file (`/tmp/clavain-dispatch-{pid}.json`) disappearing
- `.verdict` and `.summary` sidecars appearing

### Bash Wrappers (lib-intercore.sh)
NEW: ### Spawn Flags

```
--type=codex          Agent type (default: codex)
--prompt-file=<path>  Required: prompt file path
--project=<dir>       Required: working directory (default: CWD)
--output=<path>       Output file path (auto-generated if omitted)
--name=<label>        Human-readable label
--model=<model>       Codex model
--sandbox=<mode>      Sandbox mode (default: workspace-write)
--timeout=<dur>       Agent timeout
--scope-id=<id>       Grouping scope
--parent-id=<id>      Parent dispatch ID (fan-out tracking)
--dispatch-sh=<path>  Explicit dispatch.sh path (else CLAVAIN_DISPATCH_SH, else walk-up)
```

### Bash Wrappers (lib-intercore.sh)

--- 2026-02-21T05:19:11Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ### Event Reactor Pattern

The kernel emits events but does not react to them. OS components (Clavain, Interspect, custom scripts) subscribe as event consumers using `ic events tail -f`.

```bash
# Start a consumer (long-running, cursor-persisted)
ic events tail --all -f --consumer=my-reactor --poll-interval=1s

# One-shot read (no cursor, all events)
ic events tail --all

# Filter by run
ic events tail <run-id> -f --consumer=my-reactor

# Manage cursors
ic events cursor list
ic events cursor reset <consumer-name>
```

**Consumer guidelines:**
- Always use `--consumer=<name>` for durability (cursor survives restarts)
- Consumers MUST be idempotent — events are at-least-once
- Use `--poll-interval` to control CPU (500ms–2s recommended)
- See `docs/event-reactor-pattern.md` for full patterns, examples, and lifecycle management

### Optimistic Concurrency
NEW: ### Event Reactor Pattern

The kernel emits events but does not react to them. Consumers subscribe via `ic events tail -f --consumer=<name>`. Consumers MUST be idempotent (at-least-once delivery). See `docs/event-reactor-pattern.md` for full patterns.

### Optimistic Concurrency

--- 2026-02-21T05:19:16Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: The gate uses the `PortfolioQuerier` interface (`GetChildren(ctx, runID)`) to avoid cross-package coupling.

**Child dependency gates:** Child runs with upstream dependencies automatically receive an `upstreams_at_phase` gate check in addition to standard gates. This gate blocks the child from advancing to phase P unless all upstream projects have reached phase P. The gate uses the `DepQuerier` interface (`GetUpstream(ctx, portfolioRunID, project)`) — only injected for child runs that have a `parent_run_id`.

- Terminal upstreams (completed, cancelled, failed) don't block
- Upstream chains that don't contain the target phase are treated as "past it"
- If no upstream dependencies exist, the gate passes immediately
NEW: The gate uses the `PortfolioQuerier` interface (`GetChildren(ctx, runID)`) to avoid cross-package coupling.

Child runs with upstream dependencies also receive `upstreams_at_phase` (see Dependency Scheduling below). The `DepQuerier` interface is only injected for child runs that have a `parent_run_id`.

--- 2026-02-21T05:24:32Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div id="toolbar">
  <button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
  <span class="title">Interverse Ecosystem</span>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<div id="filter-sidebar" class="collapsed">
  <div class="sidebar-title">Filters</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAll()">All</button>
    <button class="filter-btn meta" onclick="hideAll()">None</button>
  </div>
  <div id="filter-list"></div>
  <div class="sidebar-title" style="margin-top: 12px">Domains</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAllDomains()">All</button>
    <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
  </div>
  <div id="domain-list"></div>
</div>

<div id="graph"></div>

<div id="detail-panel">
  <button class="close-btn" onclick="closePanel()">&times;</button>
  <div id="panel-content"></div>
</div>
NEW: <div id="toolbar">
  <button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
  <span class="title">Interverse</span>
  <div id="tab-bar">
    <button class="tab-btn active" data-tab="ecosystem" onclick="switchTab('ecosystem')">Ecosystem</button>
    <button class="tab-btn" data-tab="sprint" onclick="switchTab('sprint')">Sprint Workflow</button>
  </div>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<div id="tab-ecosystem" class="tab-content active">
  <div id="filter-sidebar" class="collapsed">
    <div class="sidebar-title">Filters</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAll()">All</button>
      <button class="filter-btn meta" onclick="hideAll()">None</button>
    </div>
    <div id="filter-list"></div>
    <div class="sidebar-title" style="margin-top: 12px">Domains</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAllDomains()">All</button>
      <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
    </div>
    <div id="domain-list"></div>
  </div>

  <div id="graph"></div>
</div>

<div id="tab-sprint" class="tab-content">
  <div id="sprint-container"></div>
</div>

<div id="detail-panel">
  <button class="close-btn" onclick="closePanel()">&times;</button>
  <div id="panel-content"></div>
</div>

--- 2026-02-21T05:24:51Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #detail-panel .meta-item { font-size: 12px; color: #8b949e; margin-bottom: 4px; }
#detail-panel .meta-item span { color: #c9d1d9; }

</style>
NEW: #detail-panel .meta-item { font-size: 12px; color: #8b949e; margin-bottom: 4px; }
#detail-panel .meta-item span { color: #c9d1d9; }

/* Tab bar */
#tab-bar {
  display: flex;
  gap: 4px;
  margin-left: 8px;
}

.tab-btn {
  background: transparent;
  border: 1px solid #30363d;
  color: #8b949e;
  padding: 3px 12px;
  border-radius: 14px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}
.tab-btn:hover { border-color: #58a6ff; color: #c9d1d9; }
.tab-btn.active {
  background: rgba(88, 166, 255, 0.15);
  border-color: #58a6ff;
  color: #58a6ff;
}

/* Tab content */
.tab-content { display: none; }
.tab-content.active { display: block; }

/* Sprint container */
#sprint-container {
  width: 100vw;
  height: calc(100vh - 44px);
  margin-top: 44px;
  background: #0d1117;
  overflow: hidden;
}
#sprint-container svg { width: 100%; height: 100%; }

.sprint-node rect {
  cursor: pointer;
  transition: filter 0.15s;
}
.sprint-node rect:hover { filter: brightness(1.3); }
.sprint-node text { pointer-events: none; user-select: none; }

.sprint-node.selected rect {
  filter: brightness(1.4) drop-shadow(0 0 8px rgba(88, 166, 255, 0.6));
}

.gate-diamond { pointer-events: none; }

</style>

--- 2026-02-21T05:26:10Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: }, 2000);
</script>
NEW: }, 2000);

// ═══════════════════════════════════════════════════════
// TAB SWITCHING
// ═══════════════════════════════════════════════════════

var sprintInitialized = false;

function switchTab(tabName) {
  // Update tab buttons
  var buttons = document.querySelectorAll('.tab-btn');
  for (var i = 0; i < buttons.length; i++) {
    if (buttons[i].dataset.tab === tabName) {
      buttons[i].classList.add('active');
    } else {
      buttons[i].classList.remove('active');
    }
  }

  // Update tab content
  var contents = document.querySelectorAll('.tab-content');
  for (var i = 0; i < contents.length; i++) {
    if (contents[i].id === 'tab-' + tabName) {
      contents[i].classList.add('active');
    } else {
      contents[i].classList.remove('active');
    }
  }

  // Ecosystem-specific toolbar elements
  var sidebarToggle = document.getElementById('sidebar-toggle');
  var searchBox = document.getElementById('search-box');
  var statsEl = document.getElementById('stats');

  if (tabName === 'ecosystem') {
    sidebarToggle.style.display = '';
    searchBox.style.display = '';
    statsEl.style.display = '';
    // Resume D3 simulation
    simulation.alphaTarget(0.01).restart();
    setTimeout(function() { simulation.alphaTarget(0); }, 500);
  } else {
    sidebarToggle.style.display = 'none';
    searchBox.style.display = 'none';
    statsEl.style.display = 'none';
    // Collapse sidebar and close panel
    document.getElementById('filter-sidebar').classList.add('collapsed');
    closePanel();
    // Pause D3 simulation
    simulation.stop();
  }

  // Lazy init sprint diagram
  if (tabName === 'sprint' && !sprintInitialized) {
    sprintInitialized = true;
    initSprintDiagram();
  }
}

// ═══════════════════════════════════════════════════════
// SPRINT WORKFLOW DIAGRAM
// ═══════════════════════════════════════════════════════

var SPRINT_PHASES = [
  {
    id: 'brainstorm', step: 1, label: 'Brainstorm',
    phase: 'ideation',
    command: 'bd create / /clavain brainstorm',
    description: 'Capture ideas freely. Explore the problem space, identify opportunities, and generate candidate solutions without filtering.',
    artifact: 'brainstorm doc',
    gate: null
  },
  {
    id: 'strategize', step: 2, label: 'Strategize',
    phase: 'ideation',
    command: '/clavain strategy',
    description: 'Structure brainstorm output into a PRD. Define features, create dependency graph, identify risks and tradeoffs.',
    artifact: 'PRD + feature beads',
    gate: null
  },
  {
    id: 'write-plan', step: 3, label: 'Write Plan',
    phase: 'planning',
    command: '/clavain write-plan',
    description: 'Break the strategy into bite-sized implementation tasks. Each task should be independently testable and mergeable.',
    artifact: 'implementation plan',
    gate: null
  },
  {
    id: 'review-plan', step: 4, label: 'Review Plan',
    phase: 'planning',
    command: '/clavain plan-review',
    description: 'Multi-agent review of the plan. Specialized agents check architecture, safety, correctness, and quality.',
    artifact: 'review verdict',
    gate: { type: 'soft', label: 'Plan approved' }
  },
  {
    id: 'execute', step: 5, label: 'Execute',
    phase: 'building',
    command: '/clavain execute-plan',
    description: 'Implement the plan in batches with review checkpoints. Each batch is a set of related tasks executed together.',
    artifact: 'code changes',
    gate: { type: 'hard', label: 'Plan exists' }
  },
  {
    id: 'test', step: 6, label: 'Test',
    phase: 'building',
    command: '/clavain tdd + /clavain verify',
    description: 'Run test suite, verify correctness. TDD for new code, verification before claiming completion.',
    artifact: 'test results',
    gate: null
  },
  {
    id: 'quality-gates', step: 7, label: 'Quality Gates',
    phase: 'quality',
    command: '/clavain quality-gates',
    description: 'Auto-select and run reviewer agents based on what changed. Architecture, safety, correctness, performance reviews.',
    artifact: 'review reports',
    gate: { type: 'hard', label: 'Tests pass' }
  },
  {
    id: 'resolve', step: 8, label: 'Resolve',
    phase: 'quality',
    command: '/clavain resolve',
    description: 'Address findings from quality gates. Fix issues, update code, re-run affected tests.',
    artifact: 'resolved findings',
    gate: null
  },
  {
    id: 'reflect', step: 9, label: 'Reflect',
    phase: 'learning',
    command: '/clavain reflect',
    description: 'Capture sprint learnings. What worked, what broke, what patterns to remember. Write to project memory.',
    artifact: 'learnings doc',
    gate: null
  },
  {
    id: 'ship', step: 10, label: 'Ship',
    phase: 'shipping',
    command: '/clavain land',
    description: 'Final landing workflow. Push to trunk, close beads, sync, verify deployment.',
    artifact: 'merged PR / pushed commits',
    gate: { type: 'soft', label: 'Findings resolved' }
  }
];

var PHASE_COLORS = {
  'ideation': '#F39C12',
  'planning': '#3498DB',
  'building': '#2ECC71',
  'quality': '#E74C3C',
  'learning': '#9B59B6',
  'shipping': '#1ABC9C'
};

var selectedSprintNode = null;

function initSprintDiagram() {
  var container = document.getElementById('sprint-container');
  var cw = container.clientWidth || window.innerWidth;
  var ch = container.clientHeight || (window.innerHeight - 44);

  var sprintSvg = d3.select('#sprint-container').append('svg')
    .attr('width', cw).attr('height', ch);

  var sprintG = sprintSvg.append('g');

  // Zoom/pan
  var sprintZoom = d3.zoom()
    .scaleExtent([0.3, 3])
    .on('zoom', function(event) { sprintG.attr('transform', event.transform); });
  sprintSvg.call(sprintZoom);

  // Click background to deselect
  sprintSvg.on('click', function() {
    selectedSprintNode = null;
    sprintG.selectAll('.sprint-node').classed('selected', false);
    closePanel();
  });

  // Layout: U-shape — top row L→R (steps 1-5), bottom row R→L (steps 6-10)
  var nodeW = 160, nodeH = 72;
  var hGap = 50, vGap = 120;
  var startX = 100, startY = 100;

  var positions = [];
  // Top row: steps 1-5
  for (var i = 0; i < 5; i++) {
    positions.push({ x: startX + i * (nodeW + hGap), y: startY });
  }
  // Bottom row: steps 6-10 (reversed)
  for (var i = 0; i < 5; i++) {
    positions.push({ x: startX + (4 - i) * (nodeW + hGap), y: startY + nodeH + vGap });
  }

  // Arrow marker
  sprintSvg.append('defs').append('marker')
    .attr('id', 'sprint-arrow')
    .attr('viewBox', '0 0 10 6')
    .attr('refX', 10).attr('refY', 3)
    .attr('markerWidth', 10).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,0 L10,3 L0,6 Z')
    .attr('fill', '#58a6ff');

  // Skip-path arrow marker (orange)
  sprintSvg.select('defs').append('marker')
    .attr('id', 'sprint-skip-arrow')
    .attr('viewBox', '0 0 10 6')
    .attr('refX', 10).attr('refY', 3)
    .attr('markerWidth', 10).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,0 L10,3 L0,6 Z')
    .attr('fill', '#F39C12');

  // Draw connecting arrows between consecutive steps
  var arrowGroup = sprintG.append('g').attr('class', 'sprint-arrows');

  for (var i = 0; i < 9; i++) {
    var from = positions[i];
    var to = positions[i + 1];

    if (i < 4) {
      // Top row: left to right
      arrowGroup.append('line')
        .attr('x1', from.x + nodeW).attr('y1', from.y + nodeH / 2)
        .attr('x2', to.x - 4).attr('y2', to.y + nodeH / 2)
        .attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    } else if (i === 4) {
      // Turn: step 5 down to step 6
      var turnX = from.x + nodeW / 2;
      arrowGroup.append('path')
        .attr('d', 'M' + (from.x + nodeW / 2) + ',' + (from.y + nodeH) +
          ' L' + (from.x + nodeW / 2) + ',' + (to.y + nodeH / 2) +
          ' L' + (to.x + nodeW + 4) + ',' + (to.y + nodeH / 2))
        .attr('fill', 'none').attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    } else {
      // Bottom row: right to left
      arrowGroup.append('line')
        .attr('x1', from.x).attr('y1', from.y + nodeH / 2)
        .attr('x2', to.x + nodeW + 4).attr('y2', to.y + nodeH / 2)
        .attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    }
  }

  // Skip path: Brainstorm → Write Plan (dashed orange curve)
  var skipFrom = positions[0]; // Brainstorm
  var skipTo = positions[2];   // Write Plan
  var skipMidY = skipFrom.y - 50;
  arrowGroup.append('path')
    .attr('d', 'M' + (skipFrom.x + nodeW / 2) + ',' + skipFrom.y +
      ' C' + (skipFrom.x + nodeW / 2) + ',' + skipMidY +
      ' ' + (skipTo.x + nodeW / 2) + ',' + skipMidY +
      ' ' + (skipTo.x + nodeW / 2) + ',' + skipTo.y)
    .attr('fill', 'none').attr('stroke', '#F39C12').attr('stroke-width', 2)
    .attr('stroke-dasharray', '6 3')
    .attr('marker-end', 'url(#sprint-skip-arrow)');

  // Skip path label
  arrowGroup.append('text')
    .attr('x', (skipFrom.x + skipTo.x + nodeW) / 2)
    .attr('y', skipMidY - 6)
    .attr('text-anchor', 'middle')
    .attr('fill', '#F39C12').attr('font-size', '10px')
    .text('skip (trivial tasks)');

  // Draw gate indicators
  var gateGroup = sprintG.append('g').attr('class', 'sprint-gates');

  SPRINT_PHASES.forEach(function(phase, idx) {
    if (!phase.gate) return;
    var pos = positions[idx];
    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';

    // Find the incoming arrow midpoint
    var gx, gy;
    if (idx < 5) {
      // Top row — gate before node (from left)
      gx = pos.x - hGap / 2;
      gy = pos.y + nodeH / 2;
    } else {
      // Bottom row — gate before node (from right)
      gx = pos.x + nodeW + hGap / 2;
      gy = pos.y + nodeH / 2;
    }

    var ds = 8; // diamond half-size
    gateGroup.append('path')
      .attr('class', 'gate-diamond')
      .attr('d', 'M' + gx + ',' + (gy - ds) +
        ' L' + (gx + ds) + ',' + gy +
        ' L' + gx + ',' + (gy + ds) +
        ' L' + (gx - ds) + ',' + gy + ' Z')
      .attr('fill', gateColor).attr('stroke', gateColor).attr('stroke-width', 1)
      .attr('opacity', 0.9);

    gateGroup.append('text')
      .attr('x', gx).attr('y', gy - ds - 5)
      .attr('text-anchor', 'middle')
      .attr('fill', gateColor).attr('font-size', '9px')
      .text(phase.gate.label);
  });

  // Draw nodes
  var nodeGroup = sprintG.append('g').attr('class', 'sprint-nodes');

  SPRINT_PHASES.forEach(function(phase, idx) {
    var pos = positions[idx];
    var color = PHASE_COLORS[phase.phase] || '#8b949e';

    var gNode = nodeGroup.append('g')
      .attr('class', 'sprint-node')
      .attr('transform', 'translate(' + pos.x + ',' + pos.y + ')')
      .style('cursor', 'pointer')
      .on('click', function(event) {
        event.stopPropagation();
        selectedSprintNode = phase;
        sprintG.selectAll('.sprint-node').classed('selected', false);
        d3.select(this).classed('selected', true);
        showSprintDetail(phase);
      });

    // Background rect
    gNode.append('rect')
      .attr('width', nodeW).attr('height', nodeH)
      .attr('rx', 8).attr('ry', 8)
      .attr('fill', '#161b22')
      .attr('stroke', color).attr('stroke-width', 2);

    // Step number circle
    gNode.append('circle')
      .attr('cx', 20).attr('cy', 20).attr('r', 12)
      .attr('fill', color).attr('opacity', 0.2);
    gNode.append('text')
      .attr('x', 20).attr('y', 24)
      .attr('text-anchor', 'middle')
      .attr('fill', color).attr('font-size', '12px').attr('font-weight', '700')
      .text(phase.step);

    // Label
    gNode.append('text')
      .attr('x', 40).attr('y', 24)
      .attr('fill', '#f0f6fc').attr('font-size', '13px').attr('font-weight', '600')
      .text(phase.label);

    // Phase name
    gNode.append('text')
      .attr('x', 12).attr('y', 52)
      .attr('fill', color).attr('font-size', '10px').attr('opacity', 0.7)
      .text(phase.phase);

    // Artifact hint
    gNode.append('text')
      .attr('x', nodeW - 8).attr('y', 52)
      .attr('text-anchor', 'end')
      .attr('fill', '#8b949e').attr('font-size', '9px')
      .text(phase.artifact);
  });

  // Zoom to fit
  setTimeout(function() {
    var bounds = sprintG.node().getBBox();
    var pad = 60;
    var scaleX = cw / (bounds.width + pad * 2);
    var scaleY = ch / (bounds.height + pad * 2);
    var fitScale = Math.min(scaleX, scaleY, 1.5);
    var midX = bounds.x + bounds.width / 2;
    var midY = bounds.y + bounds.height / 2;
    sprintSvg.transition().duration(500).call(
      sprintZoom.transform,
      d3.zoomIdentity
        .translate(cw / 2 - fitScale * midX, ch / 2 - fitScale * midY)
        .scale(fitScale)
    );
  }, 100);
}

function showSprintDetail(phase) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = PHASE_COLORS[phase.phase] || '#8b949e';

  while (content.firstChild) content.removeChild(content.firstChild);

  // Step header
  var h2 = document.createElement('h2');
  h2.textContent = 'Step ' + phase.step + ': ' + phase.label;
  content.appendChild(h2);

  // Phase badge
  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = phase.phase;
  content.appendChild(badge);

  // Description
  var desc = document.createElement('div');
  desc.className = 'description';
  desc.textContent = phase.description;
  content.appendChild(desc);

  // Command
  var cmdTitle = document.createElement('div');
  cmdTitle.className = 'section-title';
  cmdTitle.textContent = 'Command';
  content.appendChild(cmdTitle);

  var cmdBox = document.createElement('div');
  cmdBox.style.cssText = 'background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px 12px;font-family:monospace;font-size:12px;color:#50C878;margin-bottom:12px;';
  cmdBox.textContent = phase.command;
  content.appendChild(cmdBox);

  // Artifact
  var artTitle = document.createElement('div');
  artTitle.className = 'section-title';
  artTitle.textContent = 'Artifact';
  content.appendChild(artTitle);

  var artItem = document.createElement('div');
  artItem.className = 'meta-item';
  var artSpan = document.createElement('span');
  artSpan.textContent = phase.artifact;
  artItem.appendChild(artSpan);
  content.appendChild(artItem);

  // Gate
  if (phase.gate) {
    var gateTitle = document.createElement('div');
    gateTitle.className = 'section-title';
    gateTitle.textContent = 'Gate';
    content.appendChild(gateTitle);

    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';
    var gateBadge = document.createElement('div');
    gateBadge.className = 'type-badge';
    gateBadge.style.cssText = 'background:' + gateColor + '22;color:' + gateColor + ';border:1px solid ' + gateColor;
    gateBadge.textContent = phase.gate.type.toUpperCase() + ' — ' + phase.gate.label;
    content.appendChild(gateBadge);

    var gateDesc = document.createElement('div');
    gateDesc.className = 'description';
    gateDesc.textContent = phase.gate.type === 'hard'
      ? 'This gate blocks progress. The condition must be met before proceeding.'
      : 'This gate is advisory. It can be bypassed but doing so is flagged.';
    content.appendChild(gateDesc);
  }

  panel.classList.add('open');
}
</script>

--- 2026-02-21T05:28:10Z | plugins/interchart/AGENTS.md | CONTEXT:unknown ---
OLD: ## Visualization (ecosystem.html)

### UI Layout

- **Toolbar** (top, 44px): Title, stats, search box
- **Filter sidebar** (left, 240px, overlay): Type filters with colored dots + domain hull toggles. Starts collapsed; toggle with hamburger button. Overlays the graph (no layout shift).
- **Graph area** (center): D3.js force-directed SVG (full viewport width)
- **Detail panel** (right, slides in): Node metadata, relationships, external links

### Interactions

- **Click node**: Highlight node + neighbors, dim everything else, open detail panel
- **Click background**: Deselect all, close panel
- **Search**: Filter + highlight matching nodes by name/ID
- **Type filters**: Show/hide node types (sidebar checkboxes)
- **Domain toggles**: Show/hide convex hull overlays per domain
- **Drag**: Reposition nodes (force simulation continues)
- **Zoom/pan**: Mouse wheel + drag on background
- **Detail panel links**: Click to navigate to connected nodes; external links to GitHub repos

### Template Variable Ordering

The template uses inline `<script>` with `const`/`let` — these are NOT hoisted. Variables must be defined before first use. Current safe order:

```
1. TYPE_COLORS, TYPE_SIZES, TYPE_LABELS (constants)
2. activeFilters, selectedNode, searchQuery (state)
3. Build type filter buttons (reads TYPE_*)
4. Build legend (reads TYPE_*)
5. graphNodes, graphLinks (from data — filters out overlaps-with)
6. domainMembers, DOMAIN_COLORS, DOMAIN_LABELS, activeDomains (domain extraction)
7. Stats line (reads domainNames.length)
8. Build domain toggle buttons (reads DOMAIN_*)
9. D3 setup, simulation, node/link rendering
10. Hull computation (reads domainMembers, nodeById)
11. Interaction handlers (functions — hoisted)
```

**Critical:** Moving code blocks out of this order will cause `ReferenceError` and a blank page with no visible error to the user.
NEW: ## Visualization (ecosystem.html)

### Tabbed Architecture

The app has two tabs, selectable via pill buttons in the toolbar:

| Tab | Content | Data Source |
|-----|---------|-------------|
| **Ecosystem** (default) | D3.js force-directed graph of all Interverse modules | Dynamic — scanned JSON via `/*DATA_PLACEHOLDER*/` |
| **Sprint Workflow** | Flow diagram of Clavain's 10-step sprint pipeline | Static — hardcoded `SPRINT_PHASES` array |

**Tab switching** (`switchTab()`):
- Toggles `.active` class on tab buttons and `#tab-ecosystem` / `#tab-sprint` content divs
- Hides ecosystem-specific toolbar elements (search, sidebar toggle, stats) when on Sprint tab
- **Pauses D3 simulation** (`simulation.stop()`) when leaving Ecosystem to save CPU
- **Resumes simulation** when returning to Ecosystem
- Collapses sidebar and closes detail panel when switching away
- Lazy-initializes sprint diagram on first view (`sprintInitialized` flag)

### UI Layout

- **Toolbar** (top, 44px): Sidebar toggle, "Interverse" title, tab bar, stats, search box
- **Tab: Ecosystem**
  - **Filter sidebar** (left, 240px, overlay): Type filters with colored dots + domain hull toggles. Starts collapsed; toggle with hamburger button.
  - **Graph area** (center): D3.js force-directed SVG (full viewport width)
- **Tab: Sprint Workflow**
  - **Sprint container** (full viewport): SVG with U-shaped flow diagram, 10 step nodes
- **Detail panel** (right, slides in, shared): Shows node metadata for both tabs

### Sprint Workflow Diagram

**Layout**: Two rows of 5 steps in a U-shape:
```
[1 Brainstorm] → [2 Strategize] → [3 Write Plan] → [4 Review Plan] → [5 Execute]
                                                                          ↓
[10 Ship] ← [9 Reflect] ← [8 Resolve] ← [7 Quality Gates] ← [6 Test]
```

**Visual elements**:
- Rounded rect nodes with step number, label, phase name, and artifact hint
- Blue arrows between consecutive steps
- Dashed orange curved arrow: skip path (Brainstorm → Write Plan for trivial tasks)
- Gate diamonds on arrows: red = hard gate (blocking), orange = soft gate (advisory)
- Zoom/pan via `d3.zoom()`
- Auto zoom-to-fit on init
- Click node → detail panel with command, artifact, gate info

**Phase colors**: ideation=#F39C12, planning=#3498DB, building=#2ECC71, quality=#E74C3C, learning=#9B59B6, shipping=#1ABC9C

**Sprint data**: `var SPRINT_PHASES` — 10-element array, each with `{id, step, label, phase, command, description, artifact, gate}`. Fully static — no scanning needed.

### Interactions

- **Click node** (Ecosystem): Highlight node + neighbors, dim everything else, open detail panel
- **Click sprint node**: Open detail panel with step info, command, artifact, gate
- **Click background**: Deselect all, close panel
- **Search** (Ecosystem only): Filter + highlight matching nodes by name/ID
- **Type filters**: Show/hide node types (sidebar checkboxes)
- **Domain toggles**: Show/hide convex hull overlays per domain
- **Drag** (Ecosystem): Reposition nodes (force simulation continues)
- **Zoom/pan**: Mouse wheel + drag on background (both tabs)
- **Detail panel links**: Click to navigate to connected nodes; external links to GitHub repos

### Template Variable Ordering

The template uses inline `<script>` with `const`/`let` — these are NOT hoisted. Variables must be defined before first use. Current safe order:

```
1. TYPE_COLORS, TYPE_SIZES, TYPE_LABELS (constants)
2. activeFilters, selectedNode, searchQuery (state)
3. Build type filter buttons (reads TYPE_*)
4. Build legend (reads TYPE_*)
5. graphNodes, graphLinks (from data — filters out overlaps-with)
6. domainMembers, DOMAIN_COLORS, DOMAIN_LABELS, activeDomains (domain extraction)
7. Stats line (reads domainNames.length)
8. Build domain toggle buttons (reads DOMAIN_*)
9. D3 setup, simulation, node/link rendering
10. Hull computation (reads domainMembers, nodeById)
11. Interaction handlers (functions — hoisted)
12. switchTab(), SPRINT_PHASES, PHASE_COLORS (tab + sprint — uses var, safe at end)
13. initSprintDiagram(), showSprintDetail() (sprint rendering — lazy init)
```

**Critical:** Moving code blocks out of this order will cause `ReferenceError` and a blank page with no visible error to the user.

**Sprint code safety:** All sprint code uses `var` and function declarations (hoisted) rather than `const`/`let`, and lives at the end of the `<script>` block to avoid ordering issues with the ecosystem code above it.

--- 2026-02-21T05:41:49Z | docs/brainstorms/2026-02-21-thematic-work-lanes-brainstorm.md | CONTEXT:unknown ---
OLD: ## Open Questions

- **Budget semantics:** Should lanes have token budgets (max spend per lane per sprint)? Or is budget tracking at the sprint level sufficient?
- **Lane overlap:** Can a bead belong to multiple lanes? (e.g., a bead could be both "interop" and "kernel"). If yes, how does progress attribution work?
- **Velocity baseline:** How do we establish "expected" velocity per lane to detect starvation? Historical average? Manual target?
- **Pollard scheduling:** When Pollard has multiple lane assignments, how does it prioritize? Round-robin? Staleness-weighted? Budget-remaining?
NEW: ## Resolved Questions

- **Budget semantics:** No lane-level budgets. Budgets stay at sprint level. Interstat can report per-lane spend for visibility without enforcement. Lanes are organizational, not fiscal.
- **Lane overlap:** Yes, multi-lane. A bead can carry multiple `lane:` labels. Progress counts toward all lanes it belongs to. Cross-cutting work is real and shouldn't be forced into a single category.
- **Starvation detection:** Relative velocity comparison. Compare each lane's recent throughput (beads closed per week) against other lanes, weighted by priority distribution. A lane with many high-priority unblocked beads but low throughput is starved. No manual targets needed.
- **Pollard scheduling:** Starvation-weighted. Pollard preferentially hunts in the most-starved lane, creating a natural balancing force — the less a lane gets worked, the more Pollard scouts for it. Falls back to round-robin when lanes are balanced.

--- 2026-02-21T05:48:03Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div id="toolbar">
  <button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
  <span class="title">Interverse</span>
NEW: <div id="toolbar">
  <span class="title">Interverse</span>

--- 2026-02-21T05:48:07Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div id="tab-ecosystem" class="tab-content active">
  <div id="filter-sidebar" class="collapsed">
NEW: <div id="tab-ecosystem" class="tab-content active">
  <button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
  <div id="filter-sidebar" class="collapsed">

--- 2026-02-21T05:48:14Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: #sidebar-toggle {
  background: none; border: 1px solid #30363d; color: #8b949e;
  width: 28px; height: 28px; border-radius: 6px; cursor: pointer;
  font-size: 14px; display: flex; align-items: center; justify-content: center;
  transition: all 0.15s; flex-shrink: 0;
}
#sidebar-toggle:hover { border-color: #58a6ff; color: #58a6ff; }
NEW: #sidebar-toggle {
  position: fixed; top: 52px; left: 8px; z-index: 95;
  background: #161b22; border: 1px solid #30363d; color: #8b949e;
  width: 32px; height: 32px; border-radius: 6px; cursor: pointer;
  font-size: 16px; display: flex; align-items: center; justify-content: center;
  transition: all 0.15s;
}
#sidebar-toggle:hover { border-color: #58a6ff; color: #58a6ff; }

--- 2026-02-21T05:59:39Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: var ErrNotFound = errors.New("dispatch not found")
NEW: var ErrNotFound = errors.New("dispatch not found")

// ErrStaleStatus is returned when a concurrent status change was detected.
// The caller should re-read the dispatch and decide whether to retry.
var ErrStaleStatus = errors.New("dispatch status changed concurrently")

--- 2026-02-21T05:59:46Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 	args = append(args, id)

	query := "UPDATE dispatches SET " + joinStrings(sets, ", ") + " WHERE id = ?"
	result, err := tx.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("dispatch update: %w", err)
	}
	n, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("dispatch update: %w", err)
	}
	if n == 0 {
		return ErrNotFound
	}
NEW: 	args = append(args, id, prevStatus)

	query := "UPDATE dispatches SET " + joinStrings(sets, ", ") + " WHERE id = ? AND status = ?"
	result, err := tx.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("dispatch update: %w", err)
	}
	n, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("dispatch update: %w", err)
	}
	if n == 0 {
		// Distinguish not-found from concurrent status change
		var currentStatus string
		rerr := tx.QueryRowContext(ctx,
			"SELECT status FROM dispatches WHERE id = ?", id).Scan(&currentStatus)
		if rerr != nil {
			return ErrNotFound
		}
		return ErrStaleStatus
	}

--- 2026-02-21T06:00:03Z | infra/intercore/internal/dispatch/dispatch_test.go | CONTEXT:unknown ---
OLD: func TestListActive(t *testing.T) {
NEW: func TestUpdateStatus_CAS_RejectsTerminalOverwrite(t *testing.T) {
	store := testStore(t)
	ctx := context.Background()

	id, err := store.Create(ctx, &Dispatch{AgentType: "codex", ProjectDir: "/tmp/test"})
	if err != nil {
		t.Fatal(err)
	}

	// spawned → running → completed
	store.UpdateStatus(ctx, id, StatusRunning, UpdateFields{"pid": 100})
	store.UpdateStatus(ctx, id, StatusCompleted, UpdateFields{"exit_code": 0})

	// Attempt completed → failed — should be rejected by CAS guard
	err = store.UpdateStatus(ctx, id, StatusFailed, UpdateFields{"error_message": "oops"})
	if err != ErrStaleStatus {
		t.Errorf("expected ErrStaleStatus, got %v", err)
	}

	// Verify status was not overwritten
	got, _ := store.Get(ctx, id)
	if got.Status != StatusCompleted {
		t.Errorf("Status = %q, want %q (should not be overwritten)", got.Status, StatusCompleted)
	}
}

func TestUpdateStatus_CAS_AllowsValidTransition(t *testing.T) {
	store := testStore(t)
	ctx := context.Background()

	id, err := store.Create(ctx, &Dispatch{AgentType: "codex", ProjectDir: "/tmp/test"})
	if err != nil {
		t.Fatal(err)
	}

	// spawned → running
	err = store.UpdateStatus(ctx, id, StatusRunning, UpdateFields{"pid": 200})
	if err != nil {
		t.Fatalf("spawned→running: %v", err)
	}

	// running → completed
	err = store.UpdateStatus(ctx, id, StatusCompleted, UpdateFields{"exit_code": 0})
	if err != nil {
		t.Fatalf("running→completed: %v", err)
	}

	got, _ := store.Get(ctx, id)
	if got.Status != StatusCompleted {
		t.Errorf("Status = %q, want %q", got.Status, StatusCompleted)
	}
}

func TestListActive(t *testing.T) {

--- 2026-02-21T06:00:19Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 	// Build dynamic SET clause (validate column names against allowlist)
	sets := []string{"status = ?"}
	args := []interface{}{status}
NEW: 	// Reject transitions from terminal states
	if isTerminalStatus(prevStatus) {
		return ErrStaleStatus
	}

	// Build dynamic SET clause (validate column names against allowlist)
	sets := []string{"status = ?"}
	args := []interface{}{status}

--- 2026-02-21T06:00:25Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: // DispatchEventRecorder is called after a dispatch status change.
NEW: // isTerminalStatus returns true if the status is a final state.
func isTerminalStatus(status string) bool {
	switch status {
	case StatusCompleted, StatusFailed, StatusTimeout, StatusCancelled:
		return true
	}
	return false
}

// DispatchEventRecorder is called after a dispatch status change.

--- 2026-02-21T06:01:33Z | infra/intercore/internal/phase/tx_queriers.go | CONTEXT:unknown ---
OLD: import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
)
NEW: import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"
)

--- 2026-02-21T06:02:35Z | infra/intercore/internal/phase/machine.go | CONTEXT:unknown ---
OLD: // Advance attempts to move a run to its next required phase.
//
// The lifecycle:
//  1. Load run, check it's not terminal
//  2. Compute target phase (respecting complexity + force_full)
//  3. Check auto_advance (pause if disabled and no skip reason)
//  4. Evaluate gate (hard=block, soft=warn+advance, none=advance)
//  5. UpdatePhase with optimistic concurrency
//  6. Record event in audit trail
//  7. If target=done, set status=completed
//  8. Fire callback (if provided) for event bus notification
//
// rt and vq may be nil when Priority >= 4 (TierNone skips gate evaluation).
// pq may be nil for non-portfolio runs.
// dq may be nil for non-child runs (runs without a parent_run_id).
// callback may be nil — Advance checks before calling.
func Advance(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier, callback PhaseEventCallback) (*AdvanceResult, error) {
	run, err := store.Get(ctx, runID)
	if err != nil {
		return nil, err
	}

	// Check terminal status
	if IsTerminalStatus(run.Status) {
		return nil, ErrTerminalRun
	}

	// Resolve the phase chain (custom or default)
	chain := ResolveChain(run)

	// Check terminal phase using chain
	if ChainIsTerminal(chain, run.Phase) {
		return nil, ErrTerminalPhase
	}

	fromPhase := run.Phase
	toPhase, err := ChainNextPhase(chain, fromPhase)
	if err != nil {
		return nil, fmt.Errorf("advance: %w", err)
	}

	// Walk past pre-skipped phases
	skipped, err := store.SkippedPhases(ctx, runID)
	if err != nil {
		return nil, fmt.Errorf("advance: %w", err)
	}
	for skipped[toPhase] && !ChainIsTerminal(chain, toPhase) {
		next, err := ChainNextPhase(chain, toPhase)
		if err != nil {
			return nil, fmt.Errorf("advance: skip walk: %w", err)
		}
		toPhase = next
	}

	// Determine event type — advance is the only automatic transition now
	// (explicit skips are handled by the separate Skip command)
	eventType := EventAdvance

	// Check auto_advance
	if !run.AutoAdvance && cfg.SkipReason == "" {
		result := &AdvanceResult{
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventPause,
			GateResult: GateNone,
			GateTier:   TierNone,
			Reason:     "auto_advance disabled",
			Advanced:   false,
		}
		if err := store.AddEvent(ctx, &PhaseEvent{
			RunID:      runID,
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventPause,
			GateResult: strPtr(GateNone),
			GateTier:   strPtr(TierNone),
			Reason:     strPtr("auto_advance disabled"),
		}); err != nil {
			return nil, fmt.Errorf("advance: record pause: %w", err)
		}
		if callback != nil {
			callback(runID, EventPause, fromPhase, toPhase, "auto_advance disabled")
		}
		return result, nil
	}

	// Evaluate gate
	gateResult, gateTier, evidence, gateErr := evaluateGate(ctx, run, cfg, fromPhase, toPhase, rt, vq, pq, dq)
	if gateErr != nil {
		return nil, fmt.Errorf("advance: %w", gateErr)
	}

	// Build reason string
	reason := ""
	if evidence != nil {
		reason = evidence.String()
	}
	if cfg.SkipReason != "" {
		if reason != "" {
			reason = cfg.SkipReason + " | " + reason
		} else {
			reason = cfg.SkipReason
		}
	}

	if gateResult == GateFail && gateTier == TierHard {
		blockReason := reason
		if blockReason == "" {
			blockReason = "gate blocked advance"
		}
		result := &AdvanceResult{
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventBlock,
			GateResult: gateResult,
			GateTier:   gateTier,
			Reason:     blockReason,
			Advanced:   false,
		}
		if err := store.AddEvent(ctx, &PhaseEvent{
			RunID:      runID,
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventBlock,
			GateResult: strPtr(gateResult),
			GateTier:   strPtr(gateTier),
			Reason:     strPtr(blockReason),
		}); err != nil {
			return nil, fmt.Errorf("advance: record block: %w", err)
		}
		if callback != nil {
			callback(runID, EventBlock, fromPhase, toPhase, blockReason)
		}
		return result, nil
	}

	// Perform the transition
	if err := store.UpdatePhase(ctx, runID, fromPhase, toPhase); err != nil {
		return nil, fmt.Errorf("advance: %w", err)
	}

	// Record event
	if err := store.AddEvent(ctx, &PhaseEvent{
		RunID:      runID,
		FromPhase:  fromPhase,
		ToPhase:    toPhase,
		EventType:  eventType,
		GateResult: strPtr(gateResult),
		GateTier:   strPtr(gateTier),
		Reason:     strPtrOrNil(reason),
	}); err != nil {
		return nil, fmt.Errorf("advance: record event: %w", err)
	}

	// If we reached the terminal phase, mark the run as completed
	if ChainIsTerminal(chain, toPhase) {
		if err := store.UpdateStatus(ctx, runID, StatusCompleted); err != nil {
			return nil, fmt.Errorf("advance: complete run: %w", err)
		}
	}

	// Fire event bus callback (fire-and-forget)
	if callback != nil {
		callback(runID, eventType, fromPhase, toPhase, reason)
	}

	return &AdvanceResult{
		FromPhase:  fromPhase,
		ToPhase:    toPhase,
		EventType:  eventType,
		GateResult: gateResult,
		GateTier:   gateTier,
		Reason:     reason,
		Advanced:   true,
	}, nil
}
NEW: // Advance attempts to move a run to its next required phase.
//
// The lifecycle:
//  1. Begin transaction (all reads + writes are atomic)
//  2. Load run, check it's not terminal
//  3. Compute target phase (respecting complexity + force_full)
//  4. Check auto_advance (pause if disabled and no skip reason)
//  5. Evaluate gate using tx-scoped queriers (hard=block, soft=warn+advance, none=advance)
//  6. UpdatePhase with optimistic concurrency (inside same tx)
//  7. Record event in audit trail (inside same tx)
//  8. If target=done, set status=completed (inside same tx)
//  9. Commit transaction
//  10. Fire callback (if provided) for event bus notification (outside tx)
//
// Gate evaluation and phase update share a single transaction to prevent
// TOCTOU races where state changes between gate check and phase write.
//
// rt and vq may be nil when Priority >= 4 (TierNone skips gate evaluation).
// pq may be nil for non-portfolio runs.
// dq may be nil for non-child runs (runs without a parent_run_id).
// callback may be nil — Advance checks before calling.
func Advance(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier, callback PhaseEventCallback) (*AdvanceResult, error) {
	tx, err := store.BeginTx(ctx)
	if err != nil {
		return nil, fmt.Errorf("advance: begin: %w", err)
	}
	defer tx.Rollback()

	run, err := store.GetQ(ctx, tx, runID)
	if err != nil {
		return nil, err
	}

	// Check terminal status
	if IsTerminalStatus(run.Status) {
		return nil, ErrTerminalRun
	}

	// Resolve the phase chain (custom or default)
	chain := ResolveChain(run)

	// Check terminal phase using chain
	if ChainIsTerminal(chain, run.Phase) {
		return nil, ErrTerminalPhase
	}

	fromPhase := run.Phase
	toPhase, err := ChainNextPhase(chain, fromPhase)
	if err != nil {
		return nil, fmt.Errorf("advance: %w", err)
	}

	// Walk past pre-skipped phases
	skipped, err := store.SkippedPhasesQ(ctx, tx, runID)
	if err != nil {
		return nil, fmt.Errorf("advance: %w", err)
	}
	for skipped[toPhase] && !ChainIsTerminal(chain, toPhase) {
		next, err := ChainNextPhase(chain, toPhase)
		if err != nil {
			return nil, fmt.Errorf("advance: skip walk: %w", err)
		}
		toPhase = next
	}

	// Determine event type — advance is the only automatic transition now
	// (explicit skips are handled by the separate Skip command)
	eventType := EventAdvance

	// Check auto_advance
	if !run.AutoAdvance && cfg.SkipReason == "" {
		result := &AdvanceResult{
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventPause,
			GateResult: GateNone,
			GateTier:   TierNone,
			Reason:     "auto_advance disabled",
			Advanced:   false,
		}
		if err := store.AddEventQ(ctx, tx, &PhaseEvent{
			RunID:      runID,
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventPause,
			GateResult: strPtr(GateNone),
			GateTier:   strPtr(TierNone),
			Reason:     strPtr("auto_advance disabled"),
		}); err != nil {
			return nil, fmt.Errorf("advance: record pause: %w", err)
		}
		if err := tx.Commit(); err != nil {
			return nil, fmt.Errorf("advance: commit pause: %w", err)
		}
		if callback != nil {
			callback(runID, EventPause, fromPhase, toPhase, "auto_advance disabled")
		}
		return result, nil
	}

	// Build tx-scoped queriers for gate evaluation — all reads happen
	// inside the same transaction as the phase update, preventing TOCTOU.
	txRT := RuntrackQuerier(&txRuntrackQuerier{q: tx})
	txVQ := VerdictQuerier(&txVerdictQuerier{q: tx})
	txPQ := PortfolioQuerier(&txPortfolioQuerier{q: tx})
	txDQ := DepQuerier(&txDepQuerier{q: tx})

	// Use caller-provided queriers only when they're nil (Priority >= 4
	// bypasses gates entirely, so tx-scoped wrappers won't be called).
	// When gates ARE evaluated, always use tx-scoped queriers for atomicity.
	if rt == nil {
		txRT = nil
	}
	if vq == nil {
		txVQ = nil
	}
	if pq == nil {
		txPQ = nil
	}
	if dq == nil {
		txDQ = nil
	}

	// Evaluate gate — reads happen inside the transaction
	gateResult, gateTier, evidence, gateErr := evaluateGate(ctx, run, cfg, fromPhase, toPhase, txRT, txVQ, txPQ, txDQ)
	if gateErr != nil {
		return nil, fmt.Errorf("advance: %w", gateErr)
	}

	// Build reason string
	reason := ""
	if evidence != nil {
		reason = evidence.String()
	}
	if cfg.SkipReason != "" {
		if reason != "" {
			reason = cfg.SkipReason + " | " + reason
		} else {
			reason = cfg.SkipReason
		}
	}

	if gateResult == GateFail && gateTier == TierHard {
		blockReason := reason
		if blockReason == "" {
			blockReason = "gate blocked advance"
		}
		result := &AdvanceResult{
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventBlock,
			GateResult: gateResult,
			GateTier:   gateTier,
			Reason:     blockReason,
			Advanced:   false,
		}
		if err := store.AddEventQ(ctx, tx, &PhaseEvent{
			RunID:      runID,
			FromPhase:  fromPhase,
			ToPhase:    toPhase,
			EventType:  EventBlock,
			GateResult: strPtr(gateResult),
			GateTier:   strPtr(gateTier),
			Reason:     strPtr(blockReason),
		}); err != nil {
			return nil, fmt.Errorf("advance: record block: %w", err)
		}
		if err := tx.Commit(); err != nil {
			return nil, fmt.Errorf("advance: commit block: %w", err)
		}
		if callback != nil {
			callback(runID, EventBlock, fromPhase, toPhase, blockReason)
		}
		return result, nil
	}

	// Perform the transition — inside the same transaction as gate evaluation
	if err := store.UpdatePhaseQ(ctx, tx, runID, fromPhase, toPhase); err != nil {
		return nil, fmt.Errorf("advance: %w", err)
	}

	// Record event — inside the same transaction
	if err := store.AddEventQ(ctx, tx, &PhaseEvent{
		RunID:      runID,
		FromPhase:  fromPhase,
		ToPhase:    toPhase,
		EventType:  eventType,
		GateResult: strPtr(gateResult),
		GateTier:   strPtr(gateTier),
		Reason:     strPtrOrNil(reason),
	}); err != nil {
		return nil, fmt.Errorf("advance: record event: %w", err)
	}

	// If we reached the terminal phase, mark the run as completed — inside tx
	if ChainIsTerminal(chain, toPhase) {
		if err := store.UpdateStatusQ(ctx, tx, runID, StatusCompleted); err != nil {
			return nil, fmt.Errorf("advance: complete run: %w", err)
		}
	}

	// Commit the entire atomic unit: gate check + phase update + event + status
	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("advance: commit: %w", err)
	}

	// Fire event bus callback OUTSIDE transaction (fire-and-forget)
	if callback != nil {
		callback(runID, eventType, fromPhase, toPhase, reason)
	}

	return &AdvanceResult{
		FromPhase:  fromPhase,
		ToPhase:    toPhase,
		EventType:  eventType,
		GateResult: gateResult,
		GateTier:   gateTier,
		Reason:     reason,
		Advanced:   true,
	}, nil
}

--- 2026-02-21T06:06:17Z | docs/solutions/patterns/cas-spawn-link-orphan-cleanup-20260219.md | CONTEXT:unknown ---
OLD: ## Cross-References

- `infra/intercore/internal/runtrack/store.go:UpdateAgentDispatch` — CAS implementation
- `infra/intercore/cmd/ic/run.go:cmdRunAdvance` — orphan cleanup in spawn adapter closure
- `docs/guides/data-integrity-patterns.md` — WAL protocol (related atomicity pattern)
NEW: ## Cross-References

- `infra/intercore/internal/runtrack/store.go:UpdateAgentDispatch` — CAS implementation
- `infra/intercore/cmd/ic/run.go:cmdRunAdvance` — orphan cleanup in spawn adapter closure
- `docs/guides/data-integrity-patterns.md` — WAL protocol (related atomicity pattern)
- See also: [TOCTOU Gate Check + CAS Dispatch](../database-issues/toctou-gate-check-cas-dispatch-intercore-20260221.md) — CAS guard on dispatch status transitions + atomic gate-phase advance

--- 2026-02-21T07:30:21Z | infra/intercore/internal/db/schema.sql | CONTEXT:unknown ---
OLD:     scope_id        TEXT,
    parent_id       TEXT
);
NEW:     scope_id        TEXT,
    parent_id       TEXT,
    base_repo_commit TEXT
);

--- 2026-02-21T07:30:46Z | infra/intercore/internal/db/schema.sql | CONTEXT:unknown ---
OLD:     base_repo_commit TEXT
);
CREATE INDEX IF NOT EXISTS idx_dispatches_status ON dispatches(status) WHERE status IN ('spawned', 'running');
CREATE INDEX IF NOT EXISTS idx_dispatches_scope ON dispatches(scope_id) WHERE scope_id IS NOT NULL;
NEW:     base_repo_commit TEXT,
    retry_count      INTEGER NOT NULL DEFAULT 0,
    conflict_type    TEXT,
    quarantine_reason TEXT
);
CREATE INDEX IF NOT EXISTS idx_dispatches_status ON dispatches(status) WHERE status IN ('spawned', 'running');
CREATE INDEX IF NOT EXISTS idx_dispatches_scope ON dispatches(scope_id) WHERE scope_id IS NOT NULL;

-- v11: merge intent records (transactional outbox for git+SQLite coordination)
CREATE TABLE IF NOT EXISTS merge_intents (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    dispatch_id     TEXT NOT NULL,
    run_id          TEXT,
    base_commit     TEXT NOT NULL,
    patch_hash      TEXT,
    status          TEXT NOT NULL DEFAULT 'pending',
    result_commit   TEXT,
    conflict_files  TEXT,
    error_message   TEXT,
    created_at      INTEGER NOT NULL DEFAULT (unixepoch()),
    completed_at    INTEGER
);
CREATE INDEX IF NOT EXISTS idx_merge_intents_status ON merge_intents(status) WHERE status = 'pending';
CREATE INDEX IF NOT EXISTS idx_merge_intents_dispatch ON merge_intents(dispatch_id);

--- 2026-02-21T07:30:50Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	currentSchemaVersion = 10
	maxSchemaVersion     = 10
NEW: 	currentSchemaVersion = 11
	maxSchemaVersion     = 11

--- 2026-02-21T07:30:58Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	// Apply schema DDL
	if _, err := tx.ExecContext(ctx, schemaDDL); err != nil {
NEW: 	// v2–v10 → v11: TOCTOU conflict detection columns + merge_intents table
	// Guard: dispatches table exists from v2+. For v0-v1, the DDL creates it with the columns already.
	if currentVersion >= 2 && currentVersion < 11 {
		v11Stmts := []string{
			"ALTER TABLE dispatches ADD COLUMN base_repo_commit TEXT",
			"ALTER TABLE dispatches ADD COLUMN retry_count INTEGER NOT NULL DEFAULT 0",
			"ALTER TABLE dispatches ADD COLUMN conflict_type TEXT",
			"ALTER TABLE dispatches ADD COLUMN quarantine_reason TEXT",
		}
		for _, stmt := range v11Stmts {
			if _, err := tx.ExecContext(ctx, stmt); err != nil {
				if !isDuplicateColumnError(err) {
					return fmt.Errorf("migrate v10→v11: %w", err)
				}
			}
		}
	}

	// Apply schema DDL
	if _, err := tx.ExecContext(ctx, schemaDDL); err != nil {

--- 2026-02-21T07:31:02Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	if busyTimeout <= 0 {
		busyTimeout = 100 * time.Millisecond
	}
NEW: 	if busyTimeout <= 0 {
		busyTimeout = 5 * time.Second
	}

--- 2026-02-21T07:31:10Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 	ScopeID       *string
	ParentID      *string
}
NEW: 	ScopeID          *string
	ParentID         *string
	BaseRepoCommit   *string
	RetryCount       int
	ConflictType     *string
	QuarantineReason *string
}

--- 2026-02-21T07:31:17Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 	_, err = s.db.ExecContext(ctx, `
		INSERT INTO dispatches (
			id, agent_type, status, project_dir, prompt_file, prompt_hash,
			output_file, verdict_file, name, model, sandbox, timeout_sec,
			scope_id, parent_id
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		id, d.AgentType, StatusSpawned, d.ProjectDir,
		d.PromptFile, d.PromptHash, d.OutputFile, d.VerdictFile,
		d.Name, d.Model, d.Sandbox, d.TimeoutSec,
		d.ScopeID, d.ParentID,
	)
NEW: 	_, err = s.db.ExecContext(ctx, `
		INSERT INTO dispatches (
			id, agent_type, status, project_dir, prompt_file, prompt_hash,
			output_file, verdict_file, name, model, sandbox, timeout_sec,
			scope_id, parent_id, base_repo_commit
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		id, d.AgentType, StatusSpawned, d.ProjectDir,
		d.PromptFile, d.PromptHash, d.OutputFile, d.VerdictFile,
		d.Name, d.Model, d.Sandbox, d.TimeoutSec,
		d.ScopeID, d.ParentID, d.BaseRepoCommit,
	)

--- 2026-02-21T07:31:23Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: const dispatchCols = `id, agent_type, status, project_dir, prompt_file, prompt_hash,
	output_file, verdict_file, pid, exit_code, name, model, sandbox,
	timeout_sec, turns, commands, messages, input_tokens, output_tokens,
	cache_hits, created_at, started_at, completed_at, verdict_status,
	verdict_summary, error_message, scope_id, parent_id`
NEW: const dispatchCols = `id, agent_type, status, project_dir, prompt_file, prompt_hash,
	output_file, verdict_file, pid, exit_code, name, model, sandbox,
	timeout_sec, turns, commands, messages, input_tokens, output_tokens,
	cache_hits, created_at, started_at, completed_at, verdict_status,
	verdict_summary, error_message, scope_id, parent_id,
	base_repo_commit, retry_count, conflict_type, quarantine_reason`

--- 2026-02-21T07:31:31Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 		scopeID        sql.NullString
		parentID       sql.NullString
	)

	err := s.db.QueryRowContext(ctx,
		"SELECT "+dispatchCols+" FROM dispatches WHERE id = ?", id).Scan(
		&d.ID, &d.AgentType, &d.Status, &d.ProjectDir,
		&promptFile, &promptHash, &outputFile, &verdictFile,
		&pid, &exitCode, &name, &model, &sandbox,
		&timeoutSec, &d.Turns, &d.Commands, &d.Messages,
		&d.InputTokens, &d.OutputTokens, &cacheHits,
		&d.CreatedAt, &startedAt, &completedAt,
		&verdictStatus, &verdictSummary, &errorMessage,
		&scopeID, &parentID,
	)
NEW: 		scopeID          sql.NullString
		parentID         sql.NullString
		baseRepoCommit   sql.NullString
		conflictType     sql.NullString
		quarantineReason sql.NullString
	)

	err := s.db.QueryRowContext(ctx,
		"SELECT "+dispatchCols+" FROM dispatches WHERE id = ?", id).Scan(
		&d.ID, &d.AgentType, &d.Status, &d.ProjectDir,
		&promptFile, &promptHash, &outputFile, &verdictFile,
		&pid, &exitCode, &name, &model, &sandbox,
		&timeoutSec, &d.Turns, &d.Commands, &d.Messages,
		&d.InputTokens, &d.OutputTokens, &cacheHits,
		&d.CreatedAt, &startedAt, &completedAt,
		&verdictStatus, &verdictSummary, &errorMessage,
		&scopeID, &parentID,
		&baseRepoCommit, &d.RetryCount, &conflictType, &quarantineReason,
	)

--- 2026-02-21T07:31:34Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 	d.ScopeID = nullStr(scopeID)
	d.ParentID = nullStr(parentID)

	return d, nil
}
NEW: 	d.ScopeID = nullStr(scopeID)
	d.ParentID = nullStr(parentID)
	d.BaseRepoCommit = nullStr(baseRepoCommit)
	d.ConflictType = nullStr(conflictType)
	d.QuarantineReason = nullStr(quarantineReason)

	return d, nil
}

--- 2026-02-21T07:31:44Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 		var (
			promptFile     sql.NullString
			promptHash     sql.NullString
			outputFile     sql.NullString
			verdictFile    sql.NullString
			pid            sql.NullInt64
			exitCode       sql.NullInt64
			name           sql.NullString
			model          sql.NullString
			sandbox        sql.NullString
			timeoutSec     sql.NullInt64
			cacheHits      sql.NullInt64
			startedAt      sql.NullInt64
			completedAt    sql.NullInt64
			verdictStatus  sql.NullString
			verdictSummary sql.NullString
			errorMessage   sql.NullString
			scopeID        sql.NullString
			parentID       sql.NullString
		)

		if err := rows.Scan(
			&d.ID, &d.AgentType, &d.Status, &d.ProjectDir,
			&promptFile, &promptHash, &outputFile, &verdictFile,
			&pid, &exitCode, &name, &model, &sandbox,
			&timeoutSec, &d.Turns, &d.Commands, &d.Messages,
			&d.InputTokens, &d.OutputTokens, &cacheHits,
			&d.CreatedAt, &startedAt, &completedAt,
			&verdictStatus, &verdictSummary, &errorMessage,
			&scopeID, &parentID,
		); err != nil {
NEW: 		var (
			promptFile       sql.NullString
			promptHash       sql.NullString
			outputFile       sql.NullString
			verdictFile      sql.NullString
			pid              sql.NullInt64
			exitCode         sql.NullInt64
			name             sql.NullString
			model            sql.NullString
			sandbox          sql.NullString
			timeoutSec       sql.NullInt64
			cacheHits        sql.NullInt64
			startedAt        sql.NullInt64
			completedAt      sql.NullInt64
			verdictStatus    sql.NullString
			verdictSummary   sql.NullString
			errorMessage     sql.NullString
			scopeID          sql.NullString
			parentID         sql.NullString
			baseRepoCommit   sql.NullString
			conflictType     sql.NullString
			quarantineReason sql.NullString
		)

		if err := rows.Scan(
			&d.ID, &d.AgentType, &d.Status, &d.ProjectDir,
			&promptFile, &promptHash, &outputFile, &verdictFile,
			&pid, &exitCode, &name, &model, &sandbox,
			&timeoutSec, &d.Turns, &d.Commands, &d.Messages,
			&d.InputTokens, &d.OutputTokens, &cacheHits,
			&d.CreatedAt, &startedAt, &completedAt,
			&verdictStatus, &verdictSummary, &errorMessage,
			&scopeID, &parentID,
			&baseRepoCommit, &d.RetryCount, &conflictType, &quarantineReason,
		); err != nil {

--- 2026-02-21T07:31:47Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 		d.ScopeID = nullStr(scopeID)
		d.ParentID = nullStr(parentID)

		dispatches = append(dispatches, d)
NEW: 		d.ScopeID = nullStr(scopeID)
		d.ParentID = nullStr(parentID)
		d.BaseRepoCommit = nullStr(baseRepoCommit)
		d.ConflictType = nullStr(conflictType)
		d.QuarantineReason = nullStr(quarantineReason)

		dispatches = append(dispatches, d)

--- 2026-02-21T07:31:54Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: var allowedUpdateCols = map[string]bool{
	"pid": true, "exit_code": true, "started_at": true, "completed_at": true,
	"turns": true, "commands": true, "messages": true,
	"input_tokens": true, "output_tokens": true, "cache_hits": true,
	"verdict_status": true, "verdict_summary": true, "error_message": true,
}
NEW: var allowedUpdateCols = map[string]bool{
	"pid": true, "exit_code": true, "started_at": true, "completed_at": true,
	"turns": true, "commands": true, "messages": true,
	"input_tokens": true, "output_tokens": true, "cache_hits": true,
	"verdict_status": true, "verdict_summary": true, "error_message": true,
	"retry_count": true, "conflict_type": true, "quarantine_reason": true,
}

--- 2026-02-21T07:31:59Z | infra/intercore/internal/dispatch/spawn.go | CONTEXT:unknown ---
OLD: import (
	"context"
	"crypto/sha256"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"syscall"
	"time"
)
NEW: import (
	"bytes"
	"context"
	"crypto/sha256"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"syscall"
	"time"
)

--- 2026-02-21T07:32:04Z | infra/intercore/internal/dispatch/spawn.go | CONTEXT:unknown ---
OLD: 	// Hash the prompt file for dedup detection
NEW: 	// Capture base repo commit (git HEAD) for write-set conflict detection
	if commit, err := gitHeadCommit(opts.ProjectDir); err == nil && commit != "" {
		d := &Dispatch{} // temporary for field assignment below
		_ = d             // unused; we set baseCommit on the real dispatch below
		baseCommit := commit
		_ = baseCommit
	}
	baseCommit, _ := gitHeadCommit(opts.ProjectDir)

	// Hash the prompt file for dedup detection

--- 2026-02-21T07:32:12Z | infra/intercore/internal/dispatch/spawn.go | CONTEXT:unknown ---
OLD: 	// Capture base repo commit (git HEAD) for write-set conflict detection
	if commit, err := gitHeadCommit(opts.ProjectDir); err == nil && commit != "" {
		d := &Dispatch{} // temporary for field assignment below
		_ = d             // unused; we set baseCommit on the real dispatch below
		baseCommit := commit
		_ = baseCommit
	}
	baseCommit, _ := gitHeadCommit(opts.ProjectDir)

	// Hash the prompt file for dedup detection
NEW: 	// Capture base repo commit (git HEAD) for write-set conflict detection
	baseCommit, _ := gitHeadCommit(opts.ProjectDir)

	// Hash the prompt file for dedup detection

--- 2026-02-21T07:32:19Z | infra/intercore/internal/dispatch/spawn.go | CONTEXT:unknown ---
OLD: 	if opts.ParentID != "" {
		d.ParentID = &opts.ParentID
	}

	id, err := store.Create(ctx, d)
NEW: 	if opts.ParentID != "" {
		d.ParentID = &opts.ParentID
	}
	if baseCommit != "" {
		d.BaseRepoCommit = &baseCommit
	}

	id, err := store.Create(ctx, d)

--- 2026-02-21T07:32:24Z | infra/intercore/internal/dispatch/spawn.go | CONTEXT:unknown ---
OLD: func hashFile(path string) (string, error) {
NEW: // gitHeadCommit runs git rev-parse HEAD in the given directory.
// Returns empty string on any error (not a git repo, git not installed, etc.).
func gitHeadCommit(dir string) (string, error) {
	cmd := exec.Command("git", "-C", dir, "rev-parse", "HEAD")
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = nil
	if err := cmd.Run(); err != nil {
		return "", err
	}
	return strings.TrimSpace(out.String()), nil
}

func hashFile(path string) (string, error) {

--- 2026-02-21T07:32:47Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: want 10
NEW: want 11

--- 2026-02-21T07:32:57Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: expected schema version 10, got
NEW: expected schema version 11, got

--- 2026-02-21T07:33:04Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: v != 10
NEW: v != 11

--- 2026-02-21T07:33:15Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: 	for _, table := range []string{"state", "sentinels", "dispatches", "runs", "phase_events", "run_agents", "run_artifacts", "dispatch_events", "interspect_events"} {
NEW: 	for _, table := range []string{"state", "sentinels", "dispatches", "runs", "phase_events", "run_agents", "run_artifacts", "dispatch_events", "interspect_events", "merge_intents"} {

--- 2026-02-21T08:05:16Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: /* Tab bar */
#tab-bar {
  display: flex;
  gap: 4px;
  margin-left: 8px;
}

.tab-btn {
  background: transparent;
  border: 1px solid #30363d;
  color: #8b949e;
  padding: 3px 12px;
  border-radius: 14px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}
.tab-btn:hover { border-color: #58a6ff; color: #c9d1d9; }
.tab-btn.active {
  background: rgba(88, 166, 255, 0.15);
  border-color: #58a6ff;
  color: #58a6ff;
}

/* Tab content */
.tab-content { display: none; }
.tab-content.active { display: block; }

/* Sprint container */
#sprint-container {
  width: 100vw;
  height: calc(100vh - 44px);
  margin-top: 44px;
  background: #0d1117;
  overflow: hidden;
}
#sprint-container svg { width: 100%; height: 100%; }

.sprint-node rect {
  cursor: pointer;
  transition: filter 0.15s;
}
.sprint-node rect:hover { filter: brightness(1.3); }
.sprint-node text { pointer-events: none; user-select: none; }

.sprint-node.selected rect {
  filter: brightness(1.4) drop-shadow(0 0 8px rgba(88, 166, 255, 0.6));
}

.gate-diamond { pointer-events: none; }
NEW: /* Toggle bar */
#toggle-bar {
  display: flex;
  gap: 4px;
  margin-left: 8px;
}

.toggle-btn {
  background: transparent;
  border: 1px solid #30363d;
  color: #8b949e;
  padding: 3px 12px;
  border-radius: 14px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}
.toggle-btn:hover { border-color: #58a6ff; color: #c9d1d9; }
.toggle-btn.active {
  background: rgba(88, 166, 255, 0.15);
  border-color: #58a6ff;
  color: #58a6ff;
}

/* Sprint phase nodes in force graph */
.sprint-phase-node rect {
  cursor: pointer;
  transition: filter 0.15s;
}
.sprint-phase-node rect:hover { filter: brightness(1.3); }
.sprint-phase-node text { pointer-events: none; user-select: none; }
.sprint-phase-node.highlighted rect {
  filter: brightness(1.4) drop-shadow(0 0 8px rgba(88, 166, 255, 0.6));
}
.sprint-phase-node.dimmed rect { opacity: 0.1; }
.sprint-phase-node.dimmed text { opacity: 0.1; }

/* Participates-in edges */
.link.participates-in {
  stroke: #45B7D1;
  stroke-dasharray: 4 3;
  stroke-opacity: 0.2;
}
.link.participates-in.highlighted { stroke-opacity: 0.8; stroke-width: 2; }
.link.participates-in.dimmed { stroke-opacity: 0.03; }

/* Sprint flow arrows (decorative layer) */
.sprint-flow-arrow { pointer-events: none; }
.gate-diamond { pointer-events: none; }

--- 2026-02-21T08:05:34Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: <div id="toolbar">
  <span class="title">Interverse</span>
  <div id="tab-bar">
    <button class="tab-btn active" data-tab="ecosystem" onclick="switchTab('ecosystem')">Ecosystem</button>
    <button class="tab-btn" data-tab="sprint" onclick="switchTab('sprint')">Sprint Workflow</button>
  </div>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<div id="tab-ecosystem" class="tab-content active">
  <button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
  <div id="filter-sidebar" class="collapsed">
    <div class="sidebar-title">Filters</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAll()">All</button>
      <button class="filter-btn meta" onclick="hideAll()">None</button>
    </div>
    <div id="filter-list"></div>
    <div class="sidebar-title" style="margin-top: 12px">Domains</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAllDomains()">All</button>
      <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
    </div>
    <div id="domain-list"></div>
  </div>

  <div id="graph"></div>
</div>

<div id="tab-sprint" class="tab-content">
  <div id="sprint-container"></div>
</div>
NEW: <div id="toolbar">
  <span class="title">Interverse</span>
  <div id="toggle-bar">
    <button class="toggle-btn active" id="toggle-ecosystem" onclick="toggleLayer('ecosystem')">Ecosystem</button>
    <button class="toggle-btn" id="toggle-sprint" onclick="toggleLayer('sprint')">Sprint</button>
  </div>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
<div id="filter-sidebar" class="collapsed">
  <div class="sidebar-title">Filters</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAll()">All</button>
    <button class="filter-btn meta" onclick="hideAll()">None</button>
  </div>
  <div id="filter-list"></div>
  <div class="sidebar-title" style="margin-top: 12px">Domains</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAllDomains()">All</button>
    <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
  </div>
  <div id="domain-list"></div>
  <div id="phase-filter-section" style="display:none">
    <div class="sidebar-title" style="margin-top: 12px">Sprint Phases</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAllPhases()">All</button>
      <button class="filter-btn meta" onclick="hideAllPhases()">None</button>
    </div>
    <div id="phase-list"></div>
  </div>
</div>

<div id="graph"></div>

--- 2026-02-21T08:08:15Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // ═══════════════════════════════════════════════════════
// TAB SWITCHING
// ═══════════════════════════════════════════════════════

var sprintInitialized = false;

function switchTab(tabName) {
  // Update tab buttons
  var buttons = document.querySelectorAll('.tab-btn');
  for (var i = 0; i < buttons.length; i++) {
    if (buttons[i].dataset.tab === tabName) {
      buttons[i].classList.add('active');
    } else {
      buttons[i].classList.remove('active');
    }
  }

  // Update tab content
  var contents = document.querySelectorAll('.tab-content');
  for (var i = 0; i < contents.length; i++) {
    if (contents[i].id === 'tab-' + tabName) {
      contents[i].classList.add('active');
    } else {
      contents[i].classList.remove('active');
    }
  }

  // Ecosystem-specific toolbar elements
  var sidebarToggle = document.getElementById('sidebar-toggle');
  var searchBox = document.getElementById('search-box');
  var statsEl = document.getElementById('stats');

  if (tabName === 'ecosystem') {
    sidebarToggle.style.display = '';
    searchBox.style.display = '';
    statsEl.style.display = '';
    // Resume D3 simulation
    simulation.alphaTarget(0.01).restart();
    setTimeout(function() { simulation.alphaTarget(0); }, 500);
  } else {
    sidebarToggle.style.display = 'none';
    searchBox.style.display = 'none';
    statsEl.style.display = 'none';
    // Collapse sidebar and close panel
    document.getElementById('filter-sidebar').classList.add('collapsed');
    closePanel();
    // Pause D3 simulation
    simulation.stop();
  }

  // Lazy init sprint diagram
  if (tabName === 'sprint' && !sprintInitialized) {
    sprintInitialized = true;
    initSprintDiagram();
  }
}

// ═══════════════════════════════════════════════════════
// SPRINT WORKFLOW DIAGRAM
// ═══════════════════════════════════════════════════════

var SPRINT_PHASES = [
  {
    id: 'brainstorm', step: 1, label: 'Brainstorm',
    phase: 'ideation',
    command: 'bd create / /clavain brainstorm',
    description: 'Capture ideas freely. Explore the problem space, identify opportunities, and generate candidate solutions without filtering.',
    artifact: 'brainstorm doc',
    gate: null
  },
  {
    id: 'strategize', step: 2, label: 'Strategize',
    phase: 'ideation',
    command: '/clavain strategy',
    description: 'Structure brainstorm output into a PRD. Define features, create dependency graph, identify risks and tradeoffs.',
    artifact: 'PRD + feature beads',
    gate: null
  },
  {
    id: 'write-plan', step: 3, label: 'Write Plan',
    phase: 'planning',
    command: '/clavain write-plan',
    description: 'Break the strategy into bite-sized implementation tasks. Each task should be independently testable and mergeable.',
    artifact: 'implementation plan',
    gate: null
  },
  {
    id: 'review-plan', step: 4, label: 'Review Plan',
    phase: 'planning',
    command: '/clavain plan-review',
    description: 'Multi-agent review of the plan. Specialized agents check architecture, safety, correctness, and quality.',
    artifact: 'review verdict',
    gate: { type: 'soft', label: 'Plan approved' }
  },
  {
    id: 'execute', step: 5, label: 'Execute',
    phase: 'building',
    command: '/clavain execute-plan',
    description: 'Implement the plan in batches with review checkpoints. Each batch is a set of related tasks executed together.',
    artifact: 'code changes',
    gate: { type: 'hard', label: 'Plan exists' }
  },
  {
    id: 'test', step: 6, label: 'Test',
    phase: 'building',
    command: '/clavain tdd + /clavain verify',
    description: 'Run test suite, verify correctness. TDD for new code, verification before claiming completion.',
    artifact: 'test results',
    gate: null
  },
  {
    id: 'quality-gates', step: 7, label: 'Quality Gates',
    phase: 'quality',
    command: '/clavain quality-gates',
    description: 'Auto-select and run reviewer agents based on what changed. Architecture, safety, correctness, performance reviews.',
    artifact: 'review reports',
    gate: { type: 'hard', label: 'Tests pass' }
  },
  {
    id: 'resolve', step: 8, label: 'Resolve',
    phase: 'quality',
    command: '/clavain resolve',
    description: 'Address findings from quality gates. Fix issues, update code, re-run affected tests.',
    artifact: 'resolved findings',
    gate: null
  },
  {
    id: 'reflect', step: 9, label: 'Reflect',
    phase: 'learning',
    command: '/clavain reflect',
    description: 'Capture sprint learnings. What worked, what broke, what patterns to remember. Write to project memory.',
    artifact: 'learnings doc',
    gate: null
  },
  {
    id: 'ship', step: 10, label: 'Ship',
    phase: 'shipping',
    command: '/clavain land',
    description: 'Final landing workflow. Push to trunk, close beads, sync, verify deployment.',
    artifact: 'merged PR / pushed commits',
    gate: { type: 'soft', label: 'Findings resolved' }
  }
];

var PHASE_COLORS = {
  'ideation': '#F39C12',
  'planning': '#3498DB',
  'building': '#2ECC71',
  'quality': '#E74C3C',
  'learning': '#9B59B6',
  'shipping': '#1ABC9C'
};

var selectedSprintNode = null;

function initSprintDiagram() {
  var container = document.getElementById('sprint-container');
  var cw = container.clientWidth || window.innerWidth;
  var ch = container.clientHeight || (window.innerHeight - 44);

  var sprintSvg = d3.select('#sprint-container').append('svg')
    .attr('width', cw).attr('height', ch);

  var sprintG = sprintSvg.append('g');

  // Zoom/pan
  var sprintZoom = d3.zoom()
    .scaleExtent([0.3, 3])
    .on('zoom', function(event) { sprintG.attr('transform', event.transform); });
  sprintSvg.call(sprintZoom);

  // Click background to deselect
  sprintSvg.on('click', function() {
    selectedSprintNode = null;
    sprintG.selectAll('.sprint-node').classed('selected', false);
    closePanel();
  });

  // Layout: U-shape — top row L→R (steps 1-5), bottom row R→L (steps 6-10)
  var nodeW = 160, nodeH = 72;
  var hGap = 50, vGap = 120;
  var startX = 100, startY = 100;

  var positions = [];
  // Top row: steps 1-5
  for (var i = 0; i < 5; i++) {
    positions.push({ x: startX + i * (nodeW + hGap), y: startY });
  }
  // Bottom row: steps 6-10 (reversed)
  for (var i = 0; i < 5; i++) {
    positions.push({ x: startX + (4 - i) * (nodeW + hGap), y: startY + nodeH + vGap });
  }

  // Arrow marker
  sprintSvg.append('defs').append('marker')
    .attr('id', 'sprint-arrow')
    .attr('viewBox', '0 0 10 6')
    .attr('refX', 10).attr('refY', 3)
    .attr('markerWidth', 10).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,0 L10,3 L0,6 Z')
    .attr('fill', '#58a6ff');

  // Skip-path arrow marker (orange)
  sprintSvg.select('defs').append('marker')
    .attr('id', 'sprint-skip-arrow')
    .attr('viewBox', '0 0 10 6')
    .attr('refX', 10).attr('refY', 3)
    .attr('markerWidth', 10).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,0 L10,3 L0,6 Z')
    .attr('fill', '#F39C12');

  // Draw connecting arrows between consecutive steps
  var arrowGroup = sprintG.append('g').attr('class', 'sprint-arrows');

  for (var i = 0; i < 9; i++) {
    var from = positions[i];
    var to = positions[i + 1];

    if (i < 4) {
      // Top row: left to right
      arrowGroup.append('line')
        .attr('x1', from.x + nodeW).attr('y1', from.y + nodeH / 2)
        .attr('x2', to.x - 4).attr('y2', to.y + nodeH / 2)
        .attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    } else if (i === 4) {
      // Turn: step 5 down to step 6
      var turnX = from.x + nodeW / 2;
      arrowGroup.append('path')
        .attr('d', 'M' + (from.x + nodeW / 2) + ',' + (from.y + nodeH) +
          ' L' + (from.x + nodeW / 2) + ',' + (to.y + nodeH / 2) +
          ' L' + (to.x + nodeW + 4) + ',' + (to.y + nodeH / 2))
        .attr('fill', 'none').attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    } else {
      // Bottom row: right to left
      arrowGroup.append('line')
        .attr('x1', from.x).attr('y1', from.y + nodeH / 2)
        .attr('x2', to.x + nodeW + 4).attr('y2', to.y + nodeH / 2)
        .attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    }
  }

  // Skip path: Brainstorm → Write Plan (dashed orange curve)
  var skipFrom = positions[0]; // Brainstorm
  var skipTo = positions[2];   // Write Plan
  var skipMidY = skipFrom.y - 50;
  arrowGroup.append('path')
    .attr('d', 'M' + (skipFrom.x + nodeW / 2) + ',' + skipFrom.y +
      ' C' + (skipFrom.x + nodeW / 2) + ',' + skipMidY +
      ' ' + (skipTo.x + nodeW / 2) + ',' + skipMidY +
      ' ' + (skipTo.x + nodeW / 2) + ',' + skipTo.y)
    .attr('fill', 'none').attr('stroke', '#F39C12').attr('stroke-width', 2)
    .attr('stroke-dasharray', '6 3')
    .attr('marker-end', 'url(#sprint-skip-arrow)');

  // Skip path label
  arrowGroup.append('text')
    .attr('x', (skipFrom.x + skipTo.x + nodeW) / 2)
    .attr('y', skipMidY - 6)
    .attr('text-anchor', 'middle')
    .attr('fill', '#F39C12').attr('font-size', '10px')
    .text('skip (trivial tasks)');

  // Draw gate indicators
  var gateGroup = sprintG.append('g').attr('class', 'sprint-gates');

  SPRINT_PHASES.forEach(function(phase, idx) {
    if (!phase.gate) return;
    var pos = positions[idx];
    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';

    // Find the incoming arrow midpoint
    var gx, gy;
    if (idx < 5) {
      // Top row — gate before node (from left)
      gx = pos.x - hGap / 2;
      gy = pos.y + nodeH / 2;
    } else {
      // Bottom row — gate before node (from right)
      gx = pos.x + nodeW + hGap / 2;
      gy = pos.y + nodeH / 2;
    }

    var ds = 8; // diamond half-size
    gateGroup.append('path')
      .attr('class', 'gate-diamond')
      .attr('d', 'M' + gx + ',' + (gy - ds) +
        ' L' + (gx + ds) + ',' + gy +
        ' L' + gx + ',' + (gy + ds) +
        ' L' + (gx - ds) + ',' + gy + ' Z')
      .attr('fill', gateColor).attr('stroke', gateColor).attr('stroke-width', 1)
      .attr('opacity', 0.9);

    gateGroup.append('text')
      .attr('x', gx).attr('y', gy - ds - 5)
      .attr('text-anchor', 'middle')
      .attr('fill', gateColor).attr('font-size', '9px')
      .text(phase.gate.label);
  });

  // Draw nodes
  var nodeGroup = sprintG.append('g').attr('class', 'sprint-nodes');

  SPRINT_PHASES.forEach(function(phase, idx) {
    var pos = positions[idx];
    var color = PHASE_COLORS[phase.phase] || '#8b949e';

    var gNode = nodeGroup.append('g')
      .attr('class', 'sprint-node')
      .attr('transform', 'translate(' + pos.x + ',' + pos.y + ')')
      .style('cursor', 'pointer')
      .on('click', function(event) {
        event.stopPropagation();
        selectedSprintNode = phase;
        sprintG.selectAll('.sprint-node').classed('selected', false);
        d3.select(this).classed('selected', true);
        showSprintDetail(phase);
      });

    // Background rect
    gNode.append('rect')
      .attr('width', nodeW).attr('height', nodeH)
      .attr('rx', 8).attr('ry', 8)
      .attr('fill', '#161b22')
      .attr('stroke', color).attr('stroke-width', 2);

    // Step number circle
    gNode.append('circle')
      .attr('cx', 20).attr('cy', 20).attr('r', 12)
      .attr('fill', color).attr('opacity', 0.2);
    gNode.append('text')
      .attr('x', 20).attr('y', 24)
      .attr('text-anchor', 'middle')
      .attr('fill', color).attr('font-size', '12px').attr('font-weight', '700')
      .text(phase.step);

    // Label
    gNode.append('text')
      .attr('x', 40).attr('y', 24)
      .attr('fill', '#f0f6fc').attr('font-size', '13px').attr('font-weight', '600')
      .text(phase.label);

    // Phase name
    gNode.append('text')
      .attr('x', 12).attr('y', 52)
      .attr('fill', color).attr('font-size', '10px').attr('opacity', 0.7)
      .text(phase.phase);

    // Artifact hint
    gNode.append('text')
      .attr('x', nodeW - 8).attr('y', 52)
      .attr('text-anchor', 'end')
      .attr('fill', '#8b949e').attr('font-size', '9px')
      .text(phase.artifact);
  });

  // Zoom to fit
  setTimeout(function() {
    var bounds = sprintG.node().getBBox();
    var pad = 60;
    var scaleX = cw / (bounds.width + pad * 2);
    var scaleY = ch / (bounds.height + pad * 2);
    var fitScale = Math.min(scaleX, scaleY, 1.5);
    var midX = bounds.x + bounds.width / 2;
    var midY = bounds.y + bounds.height / 2;
    sprintSvg.transition().duration(500).call(
      sprintZoom.transform,
      d3.zoomIdentity
        .translate(cw / 2 - fitScale * midX, ch / 2 - fitScale * midY)
        .scale(fitScale)
    );
  }, 100);
}

function showSprintDetail(phase) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = PHASE_COLORS[phase.phase] || '#8b949e';

  while (content.firstChild) content.removeChild(content.firstChild);

  // Step header
  var h2 = document.createElement('h2');
  h2.textContent = 'Step ' + phase.step + ': ' + phase.label;
  content.appendChild(h2);

  // Phase badge
  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = phase.phase;
  content.appendChild(badge);

  // Description
  var desc = document.createElement('div');
  desc.className = 'description';
  desc.textContent = phase.description;
  content.appendChild(desc);

  // Command
  var cmdTitle = document.createElement('div');
  cmdTitle.className = 'section-title';
  cmdTitle.textContent = 'Command';
  content.appendChild(cmdTitle);

  var cmdBox = document.createElement('div');
  cmdBox.style.cssText = 'background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px 12px;font-family:monospace;font-size:12px;color:#50C878;margin-bottom:12px;';
  cmdBox.textContent = phase.command;
  content.appendChild(cmdBox);

  // Artifact
  var artTitle = document.createElement('div');
  artTitle.className = 'section-title';
  artTitle.textContent = 'Artifact';
  content.appendChild(artTitle);

  var artItem = document.createElement('div');
  artItem.className = 'meta-item';
  var artSpan = document.createElement('span');
  artSpan.textContent = phase.artifact;
  artItem.appendChild(artSpan);
  content.appendChild(artItem);

  // Gate
  if (phase.gate) {
    var gateTitle = document.createElement('div');
    gateTitle.className = 'section-title';
    gateTitle.textContent = 'Gate';
    content.appendChild(gateTitle);

    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';
    var gateBadge = document.createElement('div');
    gateBadge.className = 'type-badge';
    gateBadge.style.cssText = 'background:' + gateColor + '22;color:' + gateColor + ';border:1px solid ' + gateColor;
    gateBadge.textContent = phase.gate.type.toUpperCase() + ' — ' + phase.gate.label;
    content.appendChild(gateBadge);

    var gateDesc = document.createElement('div');
    gateDesc.className = 'description';
    gateDesc.textContent = phase.gate.type === 'hard'
      ? 'This gate blocks progress. The condition must be met before proceeding.'
      : 'This gate is advisory. It can be bypassed but doing so is flagged.';
    content.appendChild(gateDesc);
  }

  panel.classList.add('open');
}
NEW: // ═══════════════════════════════════════════════════════
// SPRINT PHASE DATA + TOGGLE LAYER SYSTEM
// ═══════════════════════════════════════════════════════

var SPRINT_PHASES = [
  {
    id: 'brainstorm', step: 1, label: 'Brainstorm',
    phase: 'ideation',
    command: 'bd create / /clavain brainstorm',
    description: 'Capture ideas freely. Explore the problem space, identify opportunities, and generate candidate solutions without filtering.',
    artifact: 'brainstorm doc',
    gate: null
  },
  {
    id: 'strategize', step: 2, label: 'Strategize',
    phase: 'ideation',
    command: '/clavain strategy',
    description: 'Structure brainstorm output into a PRD. Define features, create dependency graph, identify risks and tradeoffs.',
    artifact: 'PRD + feature beads',
    gate: null
  },
  {
    id: 'write-plan', step: 3, label: 'Write Plan',
    phase: 'planning',
    command: '/clavain write-plan',
    description: 'Break the strategy into bite-sized implementation tasks. Each task should be independently testable and mergeable.',
    artifact: 'implementation plan',
    gate: null
  },
  {
    id: 'review-plan', step: 4, label: 'Review Plan',
    phase: 'planning',
    command: '/clavain plan-review',
    description: 'Multi-agent review of the plan. Specialized agents check architecture, safety, correctness, and quality.',
    artifact: 'review verdict',
    gate: { type: 'soft', label: 'Plan approved' }
  },
  {
    id: 'execute', step: 5, label: 'Execute',
    phase: 'building',
    command: '/clavain execute-plan',
    description: 'Implement the plan in batches with review checkpoints. Each batch is a set of related tasks executed together.',
    artifact: 'code changes',
    gate: { type: 'hard', label: 'Plan exists' }
  },
  {
    id: 'test', step: 6, label: 'Test',
    phase: 'building',
    command: '/clavain tdd + /clavain verify',
    description: 'Run test suite, verify correctness. TDD for new code, verification before claiming completion.',
    artifact: 'test results',
    gate: null
  },
  {
    id: 'quality-gates', step: 7, label: 'Quality Gates',
    phase: 'quality',
    command: '/clavain quality-gates',
    description: 'Auto-select and run reviewer agents based on what changed. Architecture, safety, correctness, performance reviews.',
    artifact: 'review reports',
    gate: { type: 'hard', label: 'Tests pass' }
  },
  {
    id: 'resolve', step: 8, label: 'Resolve',
    phase: 'quality',
    command: '/clavain resolve',
    description: 'Address findings from quality gates. Fix issues, update code, re-run affected tests.',
    artifact: 'resolved findings',
    gate: null
  },
  {
    id: 'reflect', step: 9, label: 'Reflect',
    phase: 'learning',
    command: '/clavain reflect',
    description: 'Capture sprint learnings. What worked, what broke, what patterns to remember. Write to project memory.',
    artifact: 'learnings doc',
    gate: null
  },
  {
    id: 'ship', step: 10, label: 'Ship',
    phase: 'shipping',
    command: '/clavain land',
    description: 'Final landing workflow. Push to trunk, close beads, sync, verify deployment.',
    artifact: 'merged PR / pushed commits',
    gate: { type: 'soft', label: 'Findings resolved' }
  }
];

var PHASE_COLORS = {
  'ideation': '#F39C12',
  'planning': '#3498DB',
  'building': '#2ECC71',
  'quality': '#E74C3C',
  'learning': '#9B59B6',
  'shipping': '#1ABC9C'
};

// Curated mapping: which ecosystem nodes participate in each sprint phase
var PHASE_PLUGINS = {
  'brainstorm':     ['clavain'],
  'strategize':     ['clavain', 'interpath'],
  'write-plan':     ['clavain', 'interpath'],
  'review-plan':    ['clavain', 'interflux', 'interpeer'],
  'execute':        ['clavain', 'intertest', 'interlock', 'interdev'],
  'test':           ['clavain', 'intertest'],
  'quality-gates':  ['clavain', 'interflux', 'intercheck', 'interpeer'],
  'resolve':        ['clavain', 'interflux'],
  'reflect':        ['clavain', 'interdoc', 'interfluence'],
  'ship':           ['clavain', 'interlock']
};

// Toggle state
var ecosystemActive = true;
var sprintActive = false;
var activePhases = new Set(SPRINT_PHASES.map(function(p) { return p.id; }));

// Sprint phase nodes and edges that get injected into the simulation
var sprintNodes = [];
var sprintLinks = [];

// SVG layers for sprint-specific rendering
var sprintFlowGroup = g.append('g').attr('class', 'sprint-flow-layer');
var sprintNodeGroup = g.append('g').attr('class', 'sprint-node-layer');

// Compute pinned positions for sprint phases — horizontal arc
function computePhasePositions() {
  var positions = [];
  var arcW = width * 0.7;
  var startX = width * 0.15;
  var topY = height * 0.12;
  var botY = height * 0.45;
  var arcCurve = 30; // slight vertical curve

  // Top row: steps 1-5 (left to right)
  for (var i = 0; i < 5; i++) {
    var t = i / 4;
    var x = startX + t * arcW;
    var y = topY + Math.sin(t * Math.PI) * arcCurve;
    positions.push({ x: x, y: y });
  }
  // Bottom row: steps 6-10 (right to left)
  for (var i = 0; i < 5; i++) {
    var t = i / 4;
    var x = startX + arcW - t * arcW;
    var y = botY + Math.sin(t * Math.PI) * arcCurve;
    positions.push({ x: x, y: y });
  }
  return positions;
}

var phasePositions = computePhasePositions();

// Build sprint phase filter buttons in sidebar
var phaseList = document.getElementById('phase-list');
SPRINT_PHASES.forEach(function(phase) {
  var color = PHASE_COLORS[phase.phase] || '#8b949e';
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  btn.appendChild(document.createTextNode(phase.step + '. ' + phase.label));
  btn.dataset.phase = phase.id;
  btn.onclick = function() { togglePhase(phase.id, btn); };
  phaseList.appendChild(btn);
});

function togglePhase(phaseId, btn) {
  if (activePhases.has(phaseId)) { activePhases.delete(phaseId); btn.classList.remove('active'); }
  else { activePhases.add(phaseId); btn.classList.add('active'); }
  if (sprintActive) rebuildSprintLayer();
}

function showAllPhases() {
  SPRINT_PHASES.forEach(function(p) { activePhases.add(p.id); });
  document.querySelectorAll('.filter-btn[data-phase]').forEach(function(b) { b.classList.add('active'); });
  if (sprintActive) rebuildSprintLayer();
}

function hideAllPhases() {
  activePhases.clear();
  document.querySelectorAll('.filter-btn[data-phase]').forEach(function(b) { b.classList.remove('active'); });
  if (sprintActive) rebuildSprintLayer();
}

// Arrow markers for sprint flow (append to main SVG defs)
var defs = svg.append('defs');
defs.append('marker')
  .attr('id', 'sprint-arrow')
  .attr('viewBox', '0 0 10 6')
  .attr('refX', 10).attr('refY', 3)
  .attr('markerWidth', 10).attr('markerHeight', 6)
  .attr('orient', 'auto')
  .append('path')
  .attr('d', 'M0,0 L10,3 L0,6 Z')
  .attr('fill', '#58a6ff');

defs.append('marker')
  .attr('id', 'sprint-skip-arrow')
  .attr('viewBox', '0 0 10 6')
  .attr('refX', 10).attr('refY', 3)
  .attr('markerWidth', 10).attr('markerHeight', 6)
  .attr('orient', 'auto')
  .append('path')
  .attr('d', 'M0,0 L10,3 L0,6 Z')
  .attr('fill', '#F39C12');

// ── Toggle layer function ──

function toggleLayer(layerName) {
  var btn = document.getElementById('toggle-' + layerName);

  if (layerName === 'ecosystem') {
    ecosystemActive = !ecosystemActive;
    btn.classList.toggle('active', ecosystemActive);
  } else if (layerName === 'sprint') {
    sprintActive = !sprintActive;
    btn.classList.toggle('active', sprintActive);
  }

  // Show/hide ecosystem-specific UI
  var sidebarToggle = document.getElementById('sidebar-toggle');
  var searchBox = document.getElementById('search-box');
  var statsEl = document.getElementById('stats');
  sidebarToggle.style.display = ecosystemActive ? '' : 'none';
  searchBox.style.display = ecosystemActive ? '' : 'none';
  statsEl.style.display = ecosystemActive ? '' : 'none';

  // Show/hide sprint phase filter section in sidebar
  document.getElementById('phase-filter-section').style.display = sprintActive ? '' : 'none';

  // If nothing is active, do nothing special — just empty graph
  rebuildGraph();
}

function rebuildGraph() {
  // Clear sprint-specific rendering
  sprintNodeGroup.selectAll('*').remove();
  sprintFlowGroup.selectAll('*').remove();

  // Remove old sprint nodes and links from arrays
  for (var i = graphNodes.length - 1; i >= 0; i--) {
    if (graphNodes[i]._sprint) graphNodes.splice(i, 1);
  }
  for (var i = graphLinks.length - 1; i >= 0; i--) {
    if (graphLinks[i]._sprint) graphLinks.splice(i, 1);
  }

  // Clean up nodeById for removed sprint nodes
  SPRINT_PHASES.forEach(function(p) {
    delete nodeById['sprint-' + p.id];
  });

  sprintNodes = [];
  sprintLinks = [];

  // Inject sprint nodes if sprint is active
  if (sprintActive) {
    buildSprintNodes();
  }

  // Rebuild D3 selections
  rebuildSimulation();

  // Draw sprint flow arrows (static decorative layer)
  if (sprintActive) {
    drawSprintFlowArrows();
    renderSprintNodes();
  }

  // Apply visibility
  applyFilters();
}

function buildSprintNodes() {
  SPRINT_PHASES.forEach(function(phase, idx) {
    if (!activePhases.has(phase.id)) return;

    var pos = phasePositions[idx];
    var nodeId = 'sprint-' + phase.id;
    var sprintNode = {
      id: nodeId,
      label: phase.label,
      type: 'sprint-phase',
      description: phase.description,
      _sprint: true,
      _phase: phase,
      fx: pos.x,
      fy: pos.y,
      x: pos.x,
      y: pos.y
    };
    sprintNodes.push(sprintNode);
    graphNodes.push(sprintNode);
    nodeById[nodeId] = sprintNode;

    // Create participates-in edges to ecosystem nodes (only if ecosystem is active)
    if (ecosystemActive && PHASE_PLUGINS[phase.id]) {
      PHASE_PLUGINS[phase.id].forEach(function(pluginId) {
        if (nodeById[pluginId]) {
          var link = {
            source: nodeId,
            target: pluginId,
            type: 'participates-in',
            _sprint: true
          };
          sprintLinks.push(link);
          graphLinks.push(link);
        }
      });
    }
  });
}

function rebuildSimulation() {
  // Rebuild link and node selections
  link = g.select('g:nth-child(3)').selectAll('line').data(graphLinks, function(d) {
    return (typeof d.source === 'object' ? d.source.id : d.source) + '-' +
           (typeof d.target === 'object' ? d.target.id : d.target) + '-' + d.type;
  });
  link.exit().remove();
  link = link.enter().append('line')
    .attr('class', function(d) { return 'link ' + d.type; })
    .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; })
    .merge(link);

  node = g.select('g:nth-child(4)').selectAll('g.node').data(
    graphNodes.filter(function(n) { return !n._sprint; }),
    function(d) { return d.id; }
  );
  node.exit().remove();
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node')
    .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
  nodeEnter.append('circle')
    .attr('r', function(d) { return TYPE_SIZES[d.type] || 8; })
    .attr('fill', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .style('--glow', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .on('click', function(event, d) { event.stopPropagation(); selectNode(d); });
  nodeEnter.append('text')
    .attr('dx', function(d) { return (TYPE_SIZES[d.type] || 8) + 4; })
    .attr('dy', 3)
    .text(function(d) { return d.label; })
    .style('font-size', function(d) {
      if (d.type === 'monorepo' || d.type === 'hub') return '13px';
      if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return '11px';
      return '9px';
    });
  node = nodeEnter.merge(node);

  // Update simulation
  simulation.nodes(graphNodes);
  simulation.force('link').links(graphLinks);
  simulation.alpha(0.3).restart();
}

function renderSprintNodes() {
  var nodeW = 160, nodeH = 56;

  sprintNodes.forEach(function(sn) {
    var phase = sn._phase;
    var color = PHASE_COLORS[phase.phase] || '#8b949e';

    var gNode = sprintNodeGroup.append('g')
      .attr('class', 'sprint-phase-node')
      .attr('data-id', sn.id)
      .attr('transform', 'translate(' + (sn.x - nodeW / 2) + ',' + (sn.y - nodeH / 2) + ')')
      .style('cursor', 'pointer')
      .on('click', function(event) {
        event.stopPropagation();
        selectSprintNode(sn);
      });

    // Background rect
    gNode.append('rect')
      .attr('width', nodeW).attr('height', nodeH)
      .attr('rx', 8).attr('ry', 8)
      .attr('fill', '#161b22')
      .attr('stroke', color).attr('stroke-width', 2);

    // Step number circle
    gNode.append('circle')
      .attr('cx', 20).attr('cy', 20).attr('r', 12)
      .attr('fill', color).attr('opacity', 0.2);
    gNode.append('text')
      .attr('x', 20).attr('y', 24)
      .attr('text-anchor', 'middle')
      .attr('fill', color).attr('font-size', '12px').attr('font-weight', '700')
      .text(phase.step);

    // Label
    gNode.append('text')
      .attr('x', 40).attr('y', 24)
      .attr('fill', '#f0f6fc').attr('font-size', '13px').attr('font-weight', '600')
      .text(phase.label);

    // Phase name + artifact
    gNode.append('text')
      .attr('x', 12).attr('y', 46)
      .attr('fill', color).attr('font-size', '9px').attr('opacity', 0.7)
      .text(phase.phase);

    gNode.append('text')
      .attr('x', nodeW - 8).attr('y', 46)
      .attr('text-anchor', 'end')
      .attr('fill', '#8b949e').attr('font-size', '8px')
      .text(phase.artifact);
  });
}

function drawSprintFlowArrows() {
  var nodeW = 160, nodeH = 56;

  // Get active sprint node positions
  var activeSprintNodes = sprintNodes.filter(function(sn) {
    return activePhases.has(sn._phase.id);
  });

  // Build position lookup
  var posById = {};
  activeSprintNodes.forEach(function(sn) {
    posById[sn._phase.id] = { x: sn.x, y: sn.y };
  });

  // Draw flow arrows between consecutive active phases
  for (var i = 0; i < SPRINT_PHASES.length - 1; i++) {
    var fromPhase = SPRINT_PHASES[i];
    var toPhase = SPRINT_PHASES[i + 1];
    var from = posById[fromPhase.id];
    var to = posById[toPhase.id];
    if (!from || !to) continue;

    // Calculate direction
    var dx = to.x - from.x;
    var dy = to.y - from.y;
    var dist = Math.sqrt(dx * dx + dy * dy) || 1;
    var nx = dx / dist;
    var ny = dy / dist;

    // Start from edge of source, end at edge of target
    var sx = from.x + nx * (nodeW / 2 + 4);
    var sy = from.y + ny * (nodeH / 2 + 4);
    var ex = to.x - nx * (nodeW / 2 + 4);
    var ey = to.y - ny * (nodeH / 2 + 4);

    sprintFlowGroup.append('line')
      .attr('class', 'sprint-flow-arrow')
      .attr('x1', sx).attr('y1', sy)
      .attr('x2', ex).attr('y2', ey)
      .attr('stroke', '#58a6ff').attr('stroke-width', 2)
      .attr('marker-end', 'url(#sprint-arrow)');

    // Draw gate diamond if the target has a gate
    if (toPhase.gate) {
      var gateColor = toPhase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';
      var gx = (sx + ex) / 2;
      var gy = (sy + ey) / 2;
      var ds = 8;
      sprintFlowGroup.append('path')
        .attr('class', 'gate-diamond')
        .attr('d', 'M' + gx + ',' + (gy - ds) +
          ' L' + (gx + ds) + ',' + gy +
          ' L' + gx + ',' + (gy + ds) +
          ' L' + (gx - ds) + ',' + gy + ' Z')
        .attr('fill', gateColor).attr('stroke', gateColor).attr('stroke-width', 1)
        .attr('opacity', 0.9);

      sprintFlowGroup.append('text')
        .attr('x', gx).attr('y', gy - ds - 5)
        .attr('text-anchor', 'middle')
        .attr('fill', gateColor).attr('font-size', '9px')
        .text(toPhase.gate.label);
    }
  }

  // Skip path: Brainstorm → Write Plan
  var skipFrom = posById['brainstorm'];
  var skipTo = posById['write-plan'];
  if (skipFrom && skipTo) {
    var skipMidY = Math.min(skipFrom.y, skipTo.y) - 80;
    sprintFlowGroup.append('path')
      .attr('class', 'sprint-flow-arrow')
      .attr('d', 'M' + skipFrom.x + ',' + (skipFrom.y - nodeH / 2) +
        ' C' + skipFrom.x + ',' + skipMidY +
        ' ' + skipTo.x + ',' + skipMidY +
        ' ' + skipTo.x + ',' + (skipTo.y - nodeH / 2))
      .attr('fill', 'none').attr('stroke', '#F39C12').attr('stroke-width', 2)
      .attr('stroke-dasharray', '6 3')
      .attr('marker-end', 'url(#sprint-skip-arrow)');

    sprintFlowGroup.append('text')
      .attr('x', (skipFrom.x + skipTo.x) / 2)
      .attr('y', skipMidY - 6)
      .attr('text-anchor', 'middle')
      .attr('fill', '#F39C12').attr('font-size', '10px')
      .text('skip (trivial tasks)');
  }
}

function rebuildSprintLayer() {
  rebuildGraph();
}

// ── Sprint node interactions ──

function selectSprintNode(sn) {
  var phase = sn._phase;
  var connectedIds = new Set([sn.id]);

  // Find participating ecosystem nodes
  if (ecosystemActive && PHASE_PLUGINS[phase.id]) {
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      if (nodeById[pid]) connectedIds.add(pid);
    });
  }

  // Also connect to adjacent sprint phases
  var idx = SPRINT_PHASES.indexOf(phase);
  if (idx > 0) connectedIds.add('sprint-' + SPRINT_PHASES[idx - 1].id);
  if (idx < SPRINT_PHASES.length - 1) connectedIds.add('sprint-' + SPRINT_PHASES[idx + 1].id);

  // Highlight/dim ecosystem nodes
  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });
  link.classed('highlighted', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return sid === sn.id || tid === sn.id;
  });
  link.classed('dimmed', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return sid !== sn.id && tid !== sn.id;
  });

  // Highlight/dim sprint phase nodes
  sprintNodeGroup.selectAll('.sprint-phase-node')
    .classed('highlighted', function() { return connectedIds.has(d3.select(this).attr('data-id')); })
    .classed('dimmed', function() { return !connectedIds.has(d3.select(this).attr('data-id')); });

  showSprintDetail(phase);
}

function showSprintDetail(phase) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = PHASE_COLORS[phase.phase] || '#8b949e';

  while (content.firstChild) content.removeChild(content.firstChild);

  // Step header
  var h2 = document.createElement('h2');
  h2.textContent = 'Step ' + phase.step + ': ' + phase.label;
  content.appendChild(h2);

  // Phase badge
  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = phase.phase;
  content.appendChild(badge);

  // Description
  var desc = document.createElement('div');
  desc.className = 'description';
  desc.textContent = phase.description;
  content.appendChild(desc);

  // Command
  var cmdTitle = document.createElement('div');
  cmdTitle.className = 'section-title';
  cmdTitle.textContent = 'Command';
  content.appendChild(cmdTitle);

  var cmdBox = document.createElement('div');
  cmdBox.style.cssText = 'background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px 12px;font-family:monospace;font-size:12px;color:#50C878;margin-bottom:12px;';
  cmdBox.textContent = phase.command;
  content.appendChild(cmdBox);

  // Artifact
  var artTitle = document.createElement('div');
  artTitle.className = 'section-title';
  artTitle.textContent = 'Artifact';
  content.appendChild(artTitle);

  var artItem = document.createElement('div');
  artItem.className = 'meta-item';
  var artSpan = document.createElement('span');
  artSpan.textContent = phase.artifact;
  artItem.appendChild(artSpan);
  content.appendChild(artItem);

  // Gate
  if (phase.gate) {
    var gateTitle = document.createElement('div');
    gateTitle.className = 'section-title';
    gateTitle.textContent = 'Gate';
    content.appendChild(gateTitle);

    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';
    var gateBadge = document.createElement('div');
    gateBadge.className = 'type-badge';
    gateBadge.style.cssText = 'background:' + gateColor + '22;color:' + gateColor + ';border:1px solid ' + gateColor;
    gateBadge.textContent = phase.gate.type.toUpperCase() + ' \u2014 ' + phase.gate.label;
    content.appendChild(gateBadge);

    var gateDesc = document.createElement('div');
    gateDesc.className = 'description';
    gateDesc.textContent = phase.gate.type === 'hard'
      ? 'This gate blocks progress. The condition must be met before proceeding.'
      : 'This gate is advisory. It can be bypassed but doing so is flagged.';
    content.appendChild(gateDesc);
  }

  // Participating plugins section
  if (PHASE_PLUGINS[phase.id] && PHASE_PLUGINS[phase.id].length > 0) {
    var plugTitle = document.createElement('div');
    plugTitle.className = 'section-title';
    plugTitle.textContent = 'Participating Plugins';
    content.appendChild(plugTitle);

    var plugUl = document.createElement('ul');
    plugUl.className = 'child-list';
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      var pNode = nodeById[pid];
      if (!pNode) return;
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + (TYPE_COLORS[pNode.type] || '#8b949e');
      li.textContent = pNode.label + ' ';
      var ts = document.createElement('span');
      ts.className = 'child-type';
      ts.textContent = TYPE_LABELS[pNode.type] || pNode.type;
      li.appendChild(ts);
      li.onclick = function() { navigateTo(pid); };
      plugUl.appendChild(li);
    });
    content.appendChild(plugUl);
  }

  panel.classList.add('open');
}

--- 2026-02-21T08:08:37Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function selectNode(d) {
  selectedNode = d;
  var connectedIds = new Set([d.id]);
  graphLinks.forEach(function(l) {
    if (getNodeId(l.source) === d.id) connectedIds.add(getNodeId(l.target));
    if (getNodeId(l.target) === d.id) connectedIds.add(getNodeId(l.source));
  });

  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });
  link.classed('highlighted', function(l) { return getNodeId(l.source) === d.id || getNodeId(l.target) === d.id; });
  link.classed('dimmed', function(l) { return getNodeId(l.source) !== d.id && getNodeId(l.target) !== d.id; });

  showDetailPanel(d);
}

function deselectAll() {
  selectedNode = null;
  node.classed('highlighted', false).classed('dimmed', false);
  link.classed('highlighted', false).classed('dimmed', false);
}
NEW: function selectNode(d) {
  selectedNode = d;
  var connectedIds = new Set([d.id]);
  graphLinks.forEach(function(l) {
    if (getNodeId(l.source) === d.id) connectedIds.add(getNodeId(l.target));
    if (getNodeId(l.target) === d.id) connectedIds.add(getNodeId(l.source));
  });

  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });
  link.classed('highlighted', function(l) { return getNodeId(l.source) === d.id || getNodeId(l.target) === d.id; });
  link.classed('dimmed', function(l) { return getNodeId(l.source) !== d.id && getNodeId(l.target) !== d.id; });

  // Also highlight/dim sprint phase nodes if sprint is active
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node')
      .classed('highlighted', function() { return connectedIds.has(d3.select(this).attr('data-id')); })
      .classed('dimmed', function() { return !connectedIds.has(d3.select(this).attr('data-id')); });
  }

  showDetailPanel(d);
}

function deselectAll() {
  selectedNode = null;
  node.classed('highlighted', false).classed('dimmed', false);
  link.classed('highlighted', false).classed('dimmed', false);
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node')
      .classed('highlighted', false).classed('dimmed', false);
  }
}

--- 2026-02-21T08:08:53Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function applyFilters() {
  node.style('display', function(d) {
    if (!activeFilters.has(d.type)) return 'none';
    if (searchQuery && !d.label.toLowerCase().includes(searchQuery) && !d.id.toLowerCase().includes(searchQuery)) return 'none';
    return null;
  });
  link.style('display', function(l) {
    var sn = graphNodes.find(function(n) { return n.id === getNodeId(l.source); });
    var tn = graphNodes.find(function(n) { return n.id === getNodeId(l.target); });
    if (!sn || !tn || !activeFilters.has(sn.type) || !activeFilters.has(tn.type)) return 'none';
    return null;
  });
  updateHulls();
}
NEW: function applyFilters() {
  node.style('display', function(d) {
    if (!ecosystemActive) return 'none';
    if (!activeFilters.has(d.type)) return 'none';
    if (searchQuery && !d.label.toLowerCase().includes(searchQuery) && !d.id.toLowerCase().includes(searchQuery)) return 'none';
    return null;
  });
  link.style('display', function(l) {
    var sId = getNodeId(l.source);
    var tId = getNodeId(l.target);
    var sn = nodeById[sId];
    var tn = nodeById[tId];
    if (!sn || !tn) return 'none';
    // participates-in edges: visible when both endpoints are visible
    if (l.type === 'participates-in') {
      var phaseVisible = sn._sprint ? activePhases.has(sn._phase.id) : (tn._sprint ? activePhases.has(tn._phase.id) : true);
      var ecoNode = sn._sprint ? tn : sn;
      var ecoVisible = ecosystemActive && activeFilters.has(ecoNode.type);
      return (phaseVisible && ecoVisible && sprintActive) ? null : 'none';
    }
    // Regular ecosystem edges
    if (!ecosystemActive) return 'none';
    if (!activeFilters.has(sn.type) || !activeFilters.has(tn.type)) return 'none';
    return null;
  });
  // Sprint phase node visibility
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node').style('display', function() {
      var nodeId = d3.select(this).attr('data-id');
      var phaseId = nodeId.replace('sprint-', '');
      return activePhases.has(phaseId) ? null : 'none';
    });
  }
  updateHulls();
}

--- 2026-02-21T08:08:58Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: svg.on('click', function() { deselectAll(); closePanel(); });
NEW: svg.on('click', function(event) {
  if (event.target.tagName === 'svg' || event.target === svg.node()) {
    deselectAll(); closePanel();
  }
});

--- 2026-02-21T08:09:13Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD: # Sort entries deterministically by module + path
sort -t$'\t' -k1,1 "$ENTRIES_FILE" | jq -sc 'sort_by(.module, .path)' > "$TMPDIR_WORK/sorted_entries.json"
NEW: # Sort entries deterministically by module + path
jq -sc 'sort_by(.module, .path)' "$ENTRIES_FILE" > "$TMPDIR_WORK/sorted_entries.json"

--- 2026-02-21T08:09:14Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:     content.appendChild(pUl);
  }

  panel.classList.add('open');
}

function closePanel()
NEW:     content.appendChild(pUl);
  }

  // Sprint phases this node participates in (if sprint is active)
  if (sprintActive) {
    var nodePhases = [];
    Object.keys(PHASE_PLUGINS).forEach(function(phaseId) {
      if (PHASE_PLUGINS[phaseId].indexOf(d.id) !== -1) {
        var phase = SPRINT_PHASES.find(function(p) { return p.id === phaseId; });
        if (phase) nodePhases.push(phase);
      }
    });
    if (nodePhases.length > 0) {
      var spTitle = document.createElement('div');
      spTitle.className = 'section-title';
      spTitle.textContent = 'Sprint Phases';
      content.appendChild(spTitle);

      var spUl = document.createElement('ul');
      spUl.className = 'child-list';
      nodePhases.forEach(function(phase) {
        var phaseColor = PHASE_COLORS[phase.phase] || '#8b949e';
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + phaseColor;
        li.textContent = phase.step + '. ' + phase.label + ' ';
        var ts = document.createElement('span');
        ts.className = 'child-type';
        ts.textContent = phase.phase;
        li.appendChild(ts);
        spUl.appendChild(li);
      });
      content.appendChild(spUl);
    }
  }

  panel.classList.add('open');
}

function closePanel()

--- 2026-02-21T08:09:42Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // Draw links
const link = g.append('g').selectAll('line').data(graphLinks).join('line')
  .attr('class', function(d) { return 'link ' + d.type; })
  .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; });

// Draw nodes
const node = g.append('g').selectAll('g').data(graphNodes).join('g')
  .attr('class', 'node')
  .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
NEW: // Draw links
var linkGroup = g.append('g').attr('class', 'links');
var link = linkGroup.selectAll('line').data(graphLinks).join('line')
  .attr('class', function(d) { return 'link ' + d.type; })
  .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; });

// Draw nodes
var nodeGroup_eco = g.append('g').attr('class', 'nodes');
var node = nodeGroup_eco.selectAll('g').data(graphNodes).join('g')
  .attr('class', 'node')
  .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

--- 2026-02-21T08:09:53Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:     # Extract fields from frontmatter (handles both schemas)
    local title="" date="" problem_type="" severity="" tags="" category=""

    if [ -n "$frontmatter" ]; then
        # title: prefer explicit title, fall back to first H1
        title="$(echo "$frontmatter" | grep -m1 '^title:' | sed 's/^title: *//; s/^"//; s/"$//')"

        # date: try date, created, date_resolved, date_discovered
        date="$(echo "$frontmatter" | grep -m1 -E '^(date|created|date_resolved|date_discovered):' | sed 's/^[^:]*: *//')"

        # problem_type: try problem_type, then category
        problem_type="$(echo "$frontmatter" | grep -m1 '^problem_type:' | sed 's/^problem_type: *//')"
        if [ -z "$problem_type" ]; then
            problem_type="$(echo "$frontmatter" | grep -m1 '^category:' | sed 's/^category: *//')"
        fi

        # severity
        severity="$(echo "$frontmatter" | grep -m1 '^severity:' | sed 's/^severity: *//')"

        # tags: handle both [inline] and multi-line formats
        tags="$(echo "$frontmatter" | grep -m1 '^tags:' | sed 's/^tags: *//')"
        if echo "$tags" | grep -q '^\['; then
            # Inline format: [tag1, tag2, tag3]
            tags="$(echo "$tags" | tr -d '[]' | sed 's/, */,/g')"
        elif [ "$tags" = "" ] || [ "$tags" = "tags:" ]; then
            # Multi-line format: collect indented lines
            tags="$(echo "$frontmatter" | awk '/^tags:/{found=1; next} found && /^  - /{gsub(/^  - /, ""); gsub(/"/, ""); items = items ? items "," $0 : $0} found && !/^  - /{exit} END{print items}')"
        fi

        # module: prefer explicit, fall back to path-derived
        local fm_module
        fm_module="$(echo "$frontmatter" | grep -m1 '^module:' | sed 's/^module: *//')"
        if [ -n "$fm_module" ]; then
            # Normalize: "autarch/pkg/tui" → "autarch", "Plugin" → path-derived
            case "$fm_module" in
                */*)    module="$(echo "$fm_module" | cut -d/ -f1)" ;;
                Plugin|Storage) ;; # Keep path-derived module
                *)      module="$fm_module" ;;
            esac
        fi
    fi

    # Fall back: title from first H1 heading
    if [ -z "$title" ]; then
        title="$(grep -m1 '^# ' "$file" | sed 's/^# //')"
    fi
NEW:     # Extract all fields from frontmatter in a single awk pass
    # Output: title|date|problem_type|severity|tags|fm_module
    local title="" date="" problem_type="" severity="" tags="" fm_module=""

    if [ -n "$frontmatter" ]; then
        local parsed
        parsed="$(echo "$frontmatter" | awk '
            BEGIN { OFS="|" }
            /^title:/ { sub(/^title: */, ""); gsub(/^"|"$/, ""); title=$0 }
            /^date:/ { sub(/^date: */, ""); date=$0 }
            /^created:/ && !date { sub(/^created: */, ""); date=$0 }
            /^date_resolved:/ && !date { sub(/^date_resolved: */, ""); date=$0 }
            /^date_discovered:/ && !date { sub(/^date_discovered: */, ""); date=$0 }
            /^problem_type:/ { sub(/^problem_type: */, ""); ptype=$0 }
            /^category:/ && !ptype { sub(/^category: */, ""); ptype=$0 }
            /^severity:/ { sub(/^severity: */, ""); sev=$0 }
            /^module:/ { sub(/^module: */, ""); mod=$0 }
            /^tags: *\[/ {
                sub(/^tags: *\[/, ""); sub(/\].*$/, "")
                gsub(/, */, ","); gsub(/"/, "")
                tags=$0
            }
            /^tags: *$/ { intags=1; next }
            intags && /^  - / {
                sub(/^  - */, ""); gsub(/"/, "")
                tags = tags ? tags "," $0 : $0
                next
            }
            intags && !/^  - / { intags=0 }
            END { print title, date, ptype, sev, tags, mod }
        ')"

        IFS='|' read -r title date problem_type severity tags fm_module <<< "$parsed"

        if [ -n "$fm_module" ]; then
            case "$fm_module" in
                */*)    module="$(echo "$fm_module" | cut -d/ -f1)" ;;
                Plugin|Storage) ;; # Keep path-derived module
                *)      module="$fm_module" ;;
            esac
        fi
    fi

    # Fall back: title from first H1 heading
    if [ -z "$title" ]; then
        title="$(grep -m1 '^# ' "$file" | sed 's/^# //' || true)"
    fi

--- 2026-02-21T08:10:15Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:     # Extract all fields from frontmatter in a single awk pass
    # Output: title|date|problem_type|severity|tags|fm_module
    local title="" date="" problem_type="" severity="" tags="" fm_module=""

    if [ -n "$frontmatter" ]; then
        local parsed
        parsed="$(echo "$frontmatter" | awk '
            BEGIN { OFS="|" }
            /^title:/ { sub(/^title: */, ""); gsub(/^"|"$/, ""); title=$0 }
            /^date:/ { sub(/^date: */, ""); date=$0 }
            /^created:/ && !date { sub(/^created: */, ""); date=$0 }
            /^date_resolved:/ && !date { sub(/^date_resolved: */, ""); date=$0 }
            /^date_discovered:/ && !date { sub(/^date_discovered: */, ""); date=$0 }
            /^problem_type:/ { sub(/^problem_type: */, ""); ptype=$0 }
            /^category:/ && !ptype { sub(/^category: */, ""); ptype=$0 }
            /^severity:/ { sub(/^severity: */, ""); sev=$0 }
            /^module:/ { sub(/^module: */, ""); mod=$0 }
            /^tags: *\[/ {
                sub(/^tags: *\[/, ""); sub(/\].*$/, "")
                gsub(/, */, ","); gsub(/"/, "")
                tags=$0
            }
            /^tags: *$/ { intags=1; next }
            intags && /^  - / {
                sub(/^  - */, ""); gsub(/"/, "")
                tags = tags ? tags "," $0 : $0
                next
            }
            intags && !/^  - / { intags=0 }
            END { print title, date, ptype, sev, tags, mod }
        ')"

        IFS='|' read -r title date problem_type severity tags fm_module <<< "$parsed"

        if [ -n "$fm_module" ]; then
            case "$fm_module" in
                */*)    module="$(echo "$fm_module" | cut -d/ -f1)" ;;
                Plugin|Storage) ;; # Keep path-derived module
                *)      module="$fm_module" ;;
            esac
        fi
    fi

    # Fall back: title from first H1 heading
    if [ -z "$title" ]; then
        title="$(grep -m1 '^# ' "$file" | sed 's/^# //' || true)"
    fi
NEW:     # Extract all fields from frontmatter in a single awk pass
    # Writes key=value lines, parsed below
    local title="" date="" problem_type="" severity="" tags="" fm_module=""

    if [ -n "$frontmatter" ]; then
        eval "$(echo "$frontmatter" | awk '
            function emit(key, val) { gsub(/'\''/, "'\''\\'\'''\''", val); print key "='\''" val "'\''" }
            /^title:/ { sub(/^title: */, ""); gsub(/^"|"$/, ""); emit("title", $0) }
            /^date:/ { sub(/^date: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^created:/ { sub(/^created: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^date_resolved:/ { sub(/^date_resolved: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^date_discovered:/ { sub(/^date_discovered: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^problem_type:/ { sub(/^problem_type: */, ""); emit("problem_type", $0) }
            /^category:/ { sub(/^category: */, ""); if (!ptype) { ptype=$0; emit("problem_type", $0) } }
            /^severity:/ { sub(/^severity: */, ""); emit("severity", $0) }
            /^module:/ { sub(/^module: */, ""); emit("fm_module", $0) }
            /^tags:/ {
                line=$0; sub(/^tags: */, "", line)
                if (match(line, /^\[/)) {
                    gsub(/[\[\]]/, "", line); gsub(/, */, ",", line); gsub(/"/, "", line)
                    emit("tags", line)
                } else if (line == "") {
                    intags=1
                }
                next
            }
            intags && /^  - / {
                sub(/^  - */, ""); gsub(/"/, "")
                tags_ml = tags_ml ? tags_ml "," $0 : $0
                next
            }
            intags && !/^  - / { intags=0; if (tags_ml) emit("tags", tags_ml) }
            END { if (intags && tags_ml) emit("tags", tags_ml) }
        ')"

        if [ -n "$fm_module" ]; then
            case "$fm_module" in
                */*)    module="$(echo "$fm_module" | cut -d/ -f1)" ;;
                Plugin|Storage) ;; # Keep path-derived module
                *)      module="$fm_module" ;;
            esac
        fi
    fi

    # Fall back: title from first H1 heading
    if [ -z "$title" ]; then
        title="$(grep -m1 '^# ' "$file" | sed 's/^# //' || true)"
    fi

--- 2026-02-21T08:10:17Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function rebuildSimulation() {
  // Rebuild link and node selections
  link = g.select('g:nth-child(3)').selectAll('line').data(graphLinks, function(d) {
    return (typeof d.source === 'object' ? d.source.id : d.source) + '-' +
           (typeof d.target === 'object' ? d.target.id : d.target) + '-' + d.type;
  });
  link.exit().remove();
  link = link.enter().append('line')
    .attr('class', function(d) { return 'link ' + d.type; })
    .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; })
    .merge(link);

  node = g.select('g:nth-child(4)').selectAll('g.node').data(
    graphNodes.filter(function(n) { return !n._sprint; }),
    function(d) { return d.id; }
  );
  node.exit().remove();
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node')
    .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
  nodeEnter.append('circle')
    .attr('r', function(d) { return TYPE_SIZES[d.type] || 8; })
    .attr('fill', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .style('--glow', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .on('click', function(event, d) { event.stopPropagation(); selectNode(d); });
  nodeEnter.append('text')
    .attr('dx', function(d) { return (TYPE_SIZES[d.type] || 8) + 4; })
    .attr('dy', 3)
    .text(function(d) { return d.label; })
    .style('font-size', function(d) {
      if (d.type === 'monorepo' || d.type === 'hub') return '13px';
      if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return '11px';
      return '9px';
    });
  node = nodeEnter.merge(node);

  // Update simulation
  simulation.nodes(graphNodes);
  simulation.force('link').links(graphLinks);
  simulation.alpha(0.3).restart();
NEW: function rebuildSimulation() {
  // Rebuild link selection
  link = linkGroup.selectAll('line').data(graphLinks, function(d) {
    return (typeof d.source === 'object' ? d.source.id : d.source) + '-' +
           (typeof d.target === 'object' ? d.target.id : d.target) + '-' + d.type;
  });
  link.exit().remove();
  link = link.enter().append('line')
    .attr('class', function(d) { return 'link ' + d.type; })
    .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; })
    .merge(link);

  // Rebuild node selection (ecosystem nodes only — sprint phase nodes rendered separately)
  node = nodeGroup_eco.selectAll('g.node').data(
    graphNodes.filter(function(n) { return !n._sprint; }),
    function(d) { return d.id; }
  );
  node.exit().remove();
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node')
    .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
  nodeEnter.append('circle')
    .attr('r', function(d) { return TYPE_SIZES[d.type] || 8; })
    .attr('fill', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .style('--glow', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .on('click', function(event, d) { event.stopPropagation(); selectNode(d); });
  nodeEnter.append('text')
    .attr('dx', function(d) { return (TYPE_SIZES[d.type] || 8) + 4; })
    .attr('dy', 3)
    .text(function(d) { return d.label; })
    .style('font-size', function(d) {
      if (d.type === 'monorepo' || d.type === 'hub') return '13px';
      if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return '11px';
      return '9px';
    });
  node = nodeEnter.merge(node);

  // Update simulation
  simulation.nodes(graphNodes);
  simulation.force('link').links(graphLinks);
  simulation.alpha(0.3).restart();

--- 2026-02-21T08:10:33Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // Force simulation
const simulation = d3.forceSimulation(graphNodes)
  .force('link', d3.forceLink(graphLinks).id(function(d) { return d.id; }).distance(function(d) {
    if (d.type === 'part-of') return 100;
    if (d.type === 'companion-of') return 120;
    if (d.type === 'overlaps-with') return 90;
    if (d.type === 'provides-skill' || d.type === 'provides-agent') return 50;
    return 80;
  }))
  .force('charge', d3.forceManyBody().strength(function(d) {
    if (d.type === 'monorepo' || d.type === 'hub') return -400;
    if (d.type === 'plugin' || d.type === 'kernel') return -200;
    return -60;
  }))
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(function(d) { return (TYPE_SIZES[d.type] || 8) + 4; }));
NEW: // Force simulation
var simulation = d3.forceSimulation(graphNodes)
  .force('link', d3.forceLink(graphLinks).id(function(d) { return d.id; }).distance(function(d) {
    if (d.type === 'participates-in') return 200;
    if (d.type === 'part-of') return 100;
    if (d.type === 'companion-of') return 120;
    if (d.type === 'overlaps-with') return 90;
    if (d.type === 'provides-skill' || d.type === 'provides-agent') return 50;
    return 80;
  }))
  .force('charge', d3.forceManyBody().strength(function(d) {
    if (d.type === 'sprint-phase') return -500;
    if (d.type === 'monorepo' || d.type === 'hub') return -400;
    if (d.type === 'plugin' || d.type === 'kernel') return -200;
    return -60;
  }))
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(function(d) {
    if (d.type === 'sprint-phase') return 90;
    return (TYPE_SIZES[d.type] || 8) + 4;
  }));

--- 2026-02-21T08:10:40Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:     # Extract all fields from frontmatter in a single awk pass
    # Writes key=value lines, parsed below
    local title="" date="" problem_type="" severity="" tags="" fm_module=""

    if [ -n "$frontmatter" ]; then
        eval "$(echo "$frontmatter" | awk '
            function emit(key, val) { gsub(/'\''/, "'\''\\'\'''\''", val); print key "='\''" val "'\''" }
            /^title:/ { sub(/^title: */, ""); gsub(/^"|"$/, ""); emit("title", $0) }
            /^date:/ { sub(/^date: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^created:/ { sub(/^created: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^date_resolved:/ { sub(/^date_resolved: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^date_discovered:/ { sub(/^date_discovered: */, ""); if (!date) { date=$0; emit("date", $0) } }
            /^problem_type:/ { sub(/^problem_type: */, ""); emit("problem_type", $0) }
            /^category:/ { sub(/^category: */, ""); if (!ptype) { ptype=$0; emit("problem_type", $0) } }
            /^severity:/ { sub(/^severity: */, ""); emit("severity", $0) }
            /^module:/ { sub(/^module: */, ""); emit("fm_module", $0) }
            /^tags:/ {
                line=$0; sub(/^tags: */, "", line)
                if (match(line, /^\[/)) {
                    gsub(/[\[\]]/, "", line); gsub(/, */, ",", line); gsub(/"/, "", line)
                    emit("tags", line)
                } else if (line == "") {
                    intags=1
                }
                next
            }
            intags && /^  - / {
                sub(/^  - */, ""); gsub(/"/, "")
                tags_ml = tags_ml ? tags_ml "," $0 : $0
                next
            }
            intags && !/^  - / { intags=0; if (tags_ml) emit("tags", tags_ml) }
            END { if (intags && tags_ml) emit("tags", tags_ml) }
        ')"

        if [ -n "$fm_module" ]; then
            case "$fm_module" in
                */*)    module="$(echo "$fm_module" | cut -d/ -f1)" ;;
                Plugin|Storage) ;; # Keep path-derived module
                *)      module="$fm_module" ;;
            esac
        fi
    fi

    # Fall back: title from first H1 heading
    if [ -z "$title" ]; then
        title="$(grep -m1 '^# ' "$file" | sed 's/^# //' || true)"
    fi
NEW:     # Extract fields from frontmatter (handles both schemas)
    # All grep calls guarded with || true to prevent set -e failures
    local title="" date="" problem_type="" severity="" tags=""

    if [ -n "$frontmatter" ]; then
        title="$(echo "$frontmatter" | grep -m1 '^title:' | sed 's/^title: *//; s/^"//; s/"$//' || true)"

        # date: try date, created, date_resolved, date_discovered
        date="$(echo "$frontmatter" | grep -m1 -E '^(date|created|date_resolved|date_discovered):' | sed 's/^[^:]*: *//' || true)"

        # problem_type: try problem_type, then category
        problem_type="$(echo "$frontmatter" | grep -m1 '^problem_type:' | sed 's/^problem_type: *//' || true)"
        if [ -z "$problem_type" ]; then
            problem_type="$(echo "$frontmatter" | grep -m1 '^category:' | sed 's/^category: *//' || true)"
        fi

        severity="$(echo "$frontmatter" | grep -m1 '^severity:' | sed 's/^severity: *//' || true)"

        # tags: handle both [inline] and multi-line formats
        local tags_line
        tags_line="$(echo "$frontmatter" | grep -m1 '^tags:' || true)"
        if [ -n "$tags_line" ]; then
            local tags_value="${tags_line#tags:}"
            tags_value="${tags_value# }"
            if [[ "$tags_value" == \[* ]]; then
                # Inline format: [tag1, tag2, tag3]
                tags="$(echo "$tags_value" | tr -d '[]"' | sed 's/, */,/g')"
            elif [ -z "$tags_value" ]; then
                # Multi-line format: collect indented "  - item" lines
                tags="$(echo "$frontmatter" | awk '/^tags:/{found=1; next} found && /^  - /{sub(/^  - */, ""); gsub(/"/, ""); items = items ? items "," $0 : $0} found && !/^  - /{exit} END{print items}')"
            fi
        fi

        # module: prefer explicit, fall back to path-derived
        local fm_module
        fm_module="$(echo "$frontmatter" | grep -m1 '^module:' | sed 's/^module: *//' || true)"
        if [ -n "$fm_module" ]; then
            case "$fm_module" in
                */*)    module="$(echo "$fm_module" | cut -d/ -f1)" ;;
                Plugin|Storage) ;; # Keep path-derived module
                *)      module="$fm_module" ;;
            esac
        fi
    fi

    # Fall back: title from first H1 heading
    if [ -z "$title" ]; then
        title="$(grep -m1 '^# ' "$file" | sed 's/^# //' || true)"
    fi

--- 2026-02-21T08:11:04Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: svg.on('click', function(event) {
  if (event.target.tagName === 'svg' || event.target === svg.node()) {
    deselectAll(); closePanel();
  }
});
NEW: svg.on('click', function() { deselectAll(); closePanel(); });

--- 2026-02-21T08:11:27Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:         # module: prefer explicit, fall back to path-derived
        local fm_module
        fm_module="$(echo "$frontmatter" | grep -m1 '^module:' | sed 's/^module: *//' || true)"
        if [ -n "$fm_module" ]; then
            case "$fm_module" in
                */*)    module="$(echo "$fm_module" | cut -d/ -f1)" ;;
                Plugin|Storage) ;; # Keep path-derived module
                *)      module="$fm_module" ;;
            esac
        fi
NEW:         # module: use frontmatter only if it's a clean slug (lowercase alphanum + hyphens)
        # Many docs use descriptive module names like "System", "Flux-Drive", ".claude-plugin"
        # which are not useful as grouping keys — fall back to path-derived module
        local fm_module
        fm_module="$(echo "$frontmatter" | grep -m1 '^module:' | sed 's/^module: *//' || true)"
        if [ -n "$fm_module" ]; then
            # Normalize: strip path suffixes, lowercase
            local normalized="${fm_module%%/*}"
            normalized="$(echo "$normalized" | tr '[:upper:]' '[:lower:]')"
            # Accept only clean slugs (lowercase alphanum + hyphens, no spaces/dots/special)
            if echo "$normalized" | grep -qE '^[a-z][a-z0-9-]*$'; then
                module="$normalized"
            fi
            # Otherwise keep path-derived module
        fi

--- 2026-02-21T08:11:34Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:     # Derive module from path: hub/<mod>/... → <mod>, plugins/<mod>/... → <mod>, etc.
    local module=""
    module="$(echo "$rel_path" | awk -F/ '{
        if ($1 == "docs") print "interverse"
        else if (NF >= 2) print $2
    }')"
NEW:     # Derive module from path: hub/<mod>/... → <mod>, plugins/<mod>/... → <mod>, etc.
    local module=""
    module="$(echo "$rel_path" | awk -F/ '{
        if ($1 == "docs") print "interverse"
        else if (NF >= 2) print tolower($2)
    }')"

--- 2026-02-21T08:12:06Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:         # module: use frontmatter only if it's a clean slug (lowercase alphanum + hyphens)
        # Many docs use descriptive module names like "System", "Flux-Drive", ".claude-plugin"
        # which are not useful as grouping keys — fall back to path-derived module
        local fm_module
        fm_module="$(echo "$frontmatter" | grep -m1 '^module:' | sed 's/^module: *//' || true)"
        if [ -n "$fm_module" ]; then
            # Normalize: strip path suffixes, lowercase
            local normalized="${fm_module%%/*}"
            normalized="$(echo "$normalized" | tr '[:upper:]' '[:lower:]')"
            # Accept only clean slugs (lowercase alphanum + hyphens, no spaces/dots/special)
            if echo "$normalized" | grep -qE '^[a-z][a-z0-9-]*$'; then
                module="$normalized"
            fi
            # Otherwise keep path-derived module
        fi
NEW:         # module: always use path-derived module for grouping
        # Frontmatter module: is often descriptive ("System", "Flux-Drive", "Plugin")
        # rather than matching the actual repo directory, so it's unreliable for grouping.
        # Path-derived module is canonical.
        :

--- 2026-02-21T08:12:21Z | plugins/interchart/AGENTS.md | CONTEXT:unknown ---
OLD: ### Tabbed Architecture

The app has two tabs, selectable via pill buttons in the toolbar:

| Tab | Content | Data Source |
|-----|---------|-------------|
| **Ecosystem** (default) | D3.js force-directed graph of all Interverse modules | Dynamic — scanned JSON via `/*DATA_PLACEHOLDER*/` |
| **Sprint Workflow** | Flow diagram of Clavain's 10-step sprint pipeline | Static — hardcoded `SPRINT_PHASES` array |

**Tab switching** (`switchTab()`):
- Toggles `.active` class on tab buttons and `#tab-ecosystem` / `#tab-sprint` content divs
- Hides ecosystem-specific toolbar elements (search, sidebar toggle, stats) when on Sprint tab
- **Pauses D3 simulation** (`simulation.stop()`) when leaving Ecosystem to save CPU
- **Resumes simulation** when returning to Ecosystem
- Collapses sidebar and closes detail panel when switching away
- Lazy-initializes sprint diagram on first view (`sprintInitialized` flag)

### UI Layout

- **Toolbar** (top, 44px): Sidebar toggle, "Interverse" title, tab bar, stats, search box
- **Tab: Ecosystem**
  - **Filter sidebar** (left, 240px, overlay): Type filters with colored dots + domain hull toggles. Starts collapsed; toggle with hamburger button.
  - **Graph area** (center): D3.js force-directed SVG (full viewport width)
- **Tab: Sprint Workflow**
  - **Sprint container** (full viewport): SVG with U-shaped flow diagram, 10 step nodes
- **Detail panel** (right, slides in, shared): Shows node metadata for both tabs

### Sprint Workflow Diagram

**Layout**: Two rows of 5 steps in a U-shape:
```
[1 Brainstorm] → [2 Strategize] → [3 Write Plan] → [4 Review Plan] → [5 Execute]
                                                                          ↓
[10 Ship] ← [9 Reflect] ← [8 Resolve] ← [7 Quality Gates] ← [6 Test]
```

**Visual elements**:
- Rounded rect nodes with step number, label, phase name, and artifact hint
- Blue arrows between consecutive steps
- Dashed orange curved arrow: skip path (Brainstorm → Write Plan for trivial tasks)
- Gate diamonds on arrows: red = hard gate (blocking), orange = soft gate (advisory)
- Zoom/pan via `d3.zoom()`
- Auto zoom-to-fit on init
- Click node → detail panel with command, artifact, gate info

**Phase colors**: ideation=#F39C12, planning=#3498DB, building=#2ECC71, quality=#E74C3C, learning=#9B59B6, shipping=#1ABC9C

**Sprint data**: `var SPRINT_PHASES` — 10-element array, each with `{id, step, label, phase, command, description, artifact, gate}`. Fully static — no scanning needed.

### Interactions

- **Click node** (Ecosystem): Highlight node + neighbors, dim everything else, open detail panel
- **Click sprint node**: Open detail panel with step info, command, artifact, gate
- **Click background**: Deselect all, close panel
- **Search** (Ecosystem only): Filter + highlight matching nodes by name/ID
- **Type filters**: Show/hide node types (sidebar checkboxes)
- **Domain toggles**: Show/hide convex hull overlays per domain
- **Drag** (Ecosystem): Reposition nodes (force simulation continues)
- **Zoom/pan**: Mouse wheel + drag on background (both tabs)
- **Detail panel links**: Click to navigate to connected nodes; external links to GitHub repos

### Template Variable Ordering

The template uses inline `<script>` with `const`/`let` — these are NOT hoisted. Variables must be defined before first use. Current safe order:

```
1. TYPE_COLORS, TYPE_SIZES, TYPE_LABELS (constants)
2. activeFilters, selectedNode, searchQuery (state)
3. Build type filter buttons (reads TYPE_*)
4. Build legend (reads TYPE_*)
5. graphNodes, graphLinks (from data — filters out overlaps-with)
6. domainMembers, DOMAIN_COLORS, DOMAIN_LABELS, activeDomains (domain extraction)
7. Stats line (reads domainNames.length)
8. Build domain toggle buttons (reads DOMAIN_*)
9. D3 setup, simulation, node/link rendering
10. Hull computation (reads domainMembers, nodeById)
11. Interaction handlers (functions — hoisted)
12. switchTab(), SPRINT_PHASES, PHASE_COLORS (tab + sprint — uses var, safe at end)
13. initSprintDiagram(), showSprintDetail() (sprint rendering — lazy init)
```

**Critical:** Moving code blocks out of this order will cause `ReferenceError` and a blank page with no visible error to the user.

**Sprint code safety:** All sprint code uses `var` and function declarations (hoisted) rather than `const`/`let`, and lives at the end of the `<script>` block to avoid ordering issues with the ecosystem code above it.
NEW: ### Toggle Architecture

The app uses a **unified force graph** with two independent toggle buttons in the toolbar:

| Toggle | Content | Default |
|--------|---------|---------|
| **Ecosystem** | D3.js force-directed graph of all Interverse modules | ON |
| **Sprint** | Sprint phase nodes pinned in horizontal arc + flow arrows | OFF |

Both toggles can be active simultaneously. When both are on, sprint phases become gravitational anchors in the force simulation — plugins cluster near the phases they participate in via `participates-in` edges.

**Toggle behavior** (`toggleLayer()`):
- Each button toggles independently (not mutually exclusive)
- Ecosystem ON/OFF: shows/hides ecosystem nodes, links, search box, sidebar toggle, stats
- Sprint ON/OFF: injects/removes sprint phase nodes and `participates-in` edges into the simulation, draws/removes flow arrows and gate diamonds
- `rebuildGraph()` removes old sprint data, re-injects if active, rebuilds D3 selections, restarts simulation
- Sprint phase filter section in sidebar appears when sprint is active

**Phase-to-plugin mapping** (`PHASE_PLUGINS`): Curated static mapping of which ecosystem nodes participate in each sprint phase. Creates `participates-in` force links when both toggles are active.

### UI Layout

- **Toolbar** (top, 44px): "Interverse" title, toggle bar (Ecosystem/Sprint), stats, search box
- **Sidebar toggle** (fixed position, top-left): Hamburger button to expand filter sidebar
- **Filter sidebar** (left, 240px, overlay): Type filters + domain hull toggles + sprint phase toggles (when sprint active). Starts collapsed.
- **Graph area** (center): Single D3.js force-directed SVG (full viewport)
- **Detail panel** (right, slides in): Shows node metadata for both ecosystem and sprint nodes

### Sprint Nodes in Force Graph

Sprint phase nodes are rendered as **rounded rectangles** (160×56px) in a separate SVG layer on top of the force graph. They are **pinned** (fixed `fx`/`fy`) in a horizontal arc:

```
Top row (steps 1-5):    [Brainstorm] [Strategize] [Write Plan] [Review Plan] [Execute]
Bottom row (steps 6-10): [Test] [Quality Gates] [Resolve] [Reflect] [Ship]
```

**Visual elements**:
- Rounded rect nodes with step number badge, label, phase name, and artifact hint
- Blue flow arrows between consecutive phases (decorative SVG layer, not force links)
- Dashed orange skip arc: Brainstorm → Write Plan for trivial tasks
- Gate diamonds on flow arrows: red = hard gate (blocking), orange = soft gate (advisory)
- Dashed teal `participates-in` edges from phase nodes to ecosystem plugins (force links)

**Phase colors**: ideation=#F39C12, planning=#3498DB, building=#2ECC71, quality=#E74C3C, learning=#9B59B6, shipping=#1ABC9C

**Sprint data**: `var SPRINT_PHASES` — 10-element array, each with `{id, step, label, phase, command, description, artifact, gate}`. Fully static — no scanning needed.

### Interactions

- **Click ecosystem node**: Highlight node + neighbors + connected sprint phases, dim everything else, open detail panel
- **Click sprint phase node**: Highlight phase + participating plugins + adjacent phases, open detail panel with command, artifact, gate info, and participating plugins list
- **Click background**: Deselect all, close panel
- **Search** (when ecosystem active): Filter + highlight matching nodes by name/ID
- **Type filters**: Show/hide node types (sidebar checkboxes)
- **Domain toggles**: Show/hide convex hull overlays per domain
- **Phase toggles** (when sprint active): Show/hide individual sprint phase nodes
- **Drag**: Reposition ecosystem nodes (sprint phases stay pinned)
- **Zoom/pan**: Mouse wheel + drag on background
- **Detail panel links**: Click to navigate to connected nodes; external links to GitHub repos

### Template Variable Ordering

The template uses inline `<script>` with `const`/`let` — these are NOT hoisted. Variables must be defined before first use. Current safe order:

```
1. TYPE_COLORS, TYPE_SIZES, TYPE_LABELS (constants)
2. activeFilters, selectedNode, searchQuery (state)
3. Build type filter buttons (reads TYPE_*)
4. graphNodes, graphLinks (from data — filters out overlaps-with)
5. domainMembers, DOMAIN_COLORS, DOMAIN_LABELS, activeDomains (domain extraction)
6. Stats line (reads domainNames.length)
7. Build domain toggle buttons (reads DOMAIN_*)
8. D3 setup, simulation, node/link rendering (linkGroup, nodeGroup_eco)
9. Hull computation (reads domainMembers, nodeById)
10. Interaction handlers (functions — hoisted)
11. SPRINT_PHASES, PHASE_COLORS, PHASE_PLUGINS (sprint data — uses var)
12. Toggle state, sprint layer groups, phase positions, phase filter buttons
13. Arrow markers (SVG defs)
14. toggleLayer(), rebuildGraph(), rebuildSimulation() (toggle logic)
15. Sprint rendering: renderSprintNodes(), drawSprintFlowArrows()
16. Sprint interactions: selectSprintNode(), showSprintDetail()
```

**Critical:** Moving code blocks out of this order will cause `ReferenceError` and a blank page with no visible error to the user.

**Sprint code safety:** All sprint code uses `var` and function declarations (hoisted) rather than `const`/`let`, and lives at the end of the `<script>` block to avoid ordering issues with the ecosystem code above it.

--- 2026-02-21T08:12:33Z | plugins/interchart/AGENTS.md | CONTEXT:unknown ---
OLD: | `depends-on` | Hard dependency | Dashed teal |
| `overlaps-with` | Functional overlap | Not rendered as edges (see Domains) |
NEW: | `depends-on` | Hard dependency | Dashed teal |
| `overlaps-with` | Functional overlap | Not rendered as edges (see Domains) |
| `participates-in` | Sprint phase → ecosystem plugin | Dashed cyan (injected dynamically) |

--- 2026-02-21T08:12:35Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:         date="$(echo "$frontmatter" | grep -m1 -E '^(date|created|date_resolved|date_discovered):' | sed 's/^[^:]*: *//' || true)"
NEW:         date="$(echo "$frontmatter" | grep -m1 -E '^(date|created|date_resolved|date_discovered):' | sed 's/^[^:]*: *//; s/^"//; s/"$//' || true)"

--- 2026-02-21T08:16:18Z | plugins/interlearn/scripts/index-solutions.sh | CONTEXT:unknown ---
OLD:                 tags="$(echo "$frontmatter" | awk '/^tags:/{found=1; next} found && /^  - /{sub(/^  - */, ""); gsub(/"/, ""); items = items ? items "," $0 : $0} found && !/^  - /{exit} END{print items}')"
NEW:                 tags="$(echo "$frontmatter" | awk '/^tags:/{found=1; next} found && /^  - /{sub(/^  - */, ""); gsub(/"/, ""); items = items ? items "," $0 : $0; next} found && !/^  - /{exit} END{print items}')"

--- 2026-02-21T08:17:57Z | plugins/intercheck/hooks/hooks.json | CONTEXT:unknown ---
OLD:         "matcher": "Read|Edit|Write|Bash|Grep|Glob|Task|WebFetch|WebSearch|NotebookEdit|MultiEdit",
NEW:         "matcher": "Edit|Write|Bash|Task|NotebookEdit|MultiEdit",

--- 2026-02-21T08:19:15Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD: # ─── Invalidation ─────────────────────────────────────────────────

# Invalidate discovery caches. Called automatically by sprint_record_phase_completion.
sprint_invalidate_caches() {
NEW: # ─── Close Sweep ──────────────────────────────────────────────────

# Auto-close open beads that are blocked by a completed epic.
# Prevents the "bulk audit→bead" anti-pattern where child beads stay
# open after the parent epic ships them as part of its plan.
# Usage: sprint_close_children <epic_id> [reason]
# Returns: count of closed beads to stdout
sprint_close_children() {
    local epic_id="${1:?epic_id required}"
    local reason="${2:-Auto-closed: parent epic $epic_id shipped}"
    command -v bd &>/dev/null || { echo "0"; return 0; }

    # Parse BLOCKS section from bd show — only open beads (← ○)
    local blocked_ids
    blocked_ids=$(bd show "$epic_id" 2>/dev/null \
        | awk '/^BLOCKS$/,/^(DEPENDS ON|CHILDREN|LABELS|NOTES|DESCRIPTION|$)/' \
        | grep '← ○' \
        | sed 's/.*← ○ //' \
        | cut -d: -f1 \
        | tr -d ' ' \
        | grep -E '^[A-Za-z]+-[A-Za-z0-9]+$') || blocked_ids=""

    [[ -z "$blocked_ids" ]] && { echo "0"; return 0; }

    local closed=0
    while IFS= read -r child_id; do
        [[ -z "$child_id" ]] && continue
        bd close "$child_id" --reason="$reason" >/dev/null 2>&1 && closed=$((closed + 1))
    done <<< "$blocked_ids"

    echo "$closed"
}

# ─── Invalidation ─────────────────────────────────────────────────

# Invalidate discovery caches. Called automatically by sprint_record_phase_completion.
sprint_invalidate_caches() {

--- 2026-02-21T08:19:31Z | os/clavain/commands/sprint.md | CONTEXT:unknown ---
OLD: **Phase:** After successful ship, set `phase=done` with reason `"Shipped"`. Also close the bead: `bd close "$CLAVAIN_BEAD_ID" 2>/dev/null || true`.

**Sprint summary:** At completion, display:
```
Sprint Summary:
- Bead: <CLAVAIN_BEAD_ID>
- Steps completed: <n>/10
- Budget: <tokens_spent>k / <token_budget>k (<percentage>%)
- Agents dispatched: <count>
- Verdicts: <verdict_count_by_status output>
- Estimated tokens: <verdict_total_tokens output>
```
NEW: **Phase:** After successful ship, set `phase=done` with reason `"Shipped"`. Also close the bead: `bd close "$CLAVAIN_BEAD_ID" 2>/dev/null || true`.

**Close sweep:** After closing the sprint bead, auto-close any open beads that were blocked by it:

```bash
export SPRINT_LIB_PROJECT_DIR="."; source "/home/mk/.claude/plugins/cache/interagency-marketplace/clavain/0.6.56/hooks/lib-sprint.sh"
swept=$(sprint_close_children "$CLAVAIN_BEAD_ID" "Shipped with parent epic $CLAVAIN_BEAD_ID")
if [[ "$swept" -gt 0 ]]; then
    echo "Auto-closed $swept child beads"
fi
```

**Sprint summary:** At completion, display:
```
Sprint Summary:
- Bead: <CLAVAIN_BEAD_ID>
- Steps completed: <n>/10
- Budget: <tokens_spent>k / <token_budget>k (<percentage>%)
- Agents dispatched: <count>
- Verdicts: <verdict_count_by_status output>
- Estimated tokens: <verdict_total_tokens output>
- Swept: <swept> child beads auto-closed
```

--- 2026-02-21T08:19:35Z | .serena/project.yml | CONTEXT:unknown ---
OLD: excluded_tools: []
NEW: excluded_tools:
- read_file
- create_text_file
- list_dir
- search_for_pattern
- execute_shell_command
- think_about_collected_information
- think_about_task_adherence
- think_about_whether_you_are_done
- check_onboarding_performed
- initial_instructions
- onboarding
- prepare_for_new_conversation
- summarize_changes
- list_memories
- read_memory
- write_memory
- delete_memory

--- 2026-02-21T08:20:56Z | plugins/interchart/scripts/regenerate-and-deploy.sh | CONTEXT:unknown ---
OLD: # Update local copy
mkdir -p "$(dirname "$CURRENT")"
mv "$TMPHTML" "$CURRENT"

# Deploy to gh-pages
cd "$INTERCHART_DIR"
git checkout gh-pages 2>/dev/null
cp "$CURRENT" index.html
git add index.html
git commit -m "chore: regenerate diagram ($NODE_COUNT nodes, $EDGE_COUNT edges)" 2>/dev/null || true
git push origin gh-pages 2>/dev/null
git checkout main 2>/dev/null

echo "interchart: deployed ($NODE_COUNT nodes, $EDGE_COUNT edges)"
NEW: # Update local copy
mkdir -p "$(dirname "$CURRENT")"
mv "$TMPHTML" "$CURRENT"

# Update scan data for CI deploys
echo "$DATA" > "$INTERCHART_DIR/data/scan.json"

# Deploy to gh-pages
cd "$INTERCHART_DIR"
git checkout gh-pages 2>/dev/null
cp "$CURRENT" index.html
git add index.html
git commit -m "chore: regenerate diagram ($NODE_COUNT nodes, $EDGE_COUNT edges)" 2>/dev/null || true
git push origin gh-pages 2>/dev/null
git checkout main 2>/dev/null

echo "interchart: deployed ($NODE_COUNT nodes, $EDGE_COUNT edges)"

--- 2026-02-21T08:22:35Z | os/clavain/config/routing.yaml | CONTEXT:unknown ---
OLD: subagents:
  defaults:
    model: sonnet
    categories:
      research: haiku
      review: sonnet
      workflow: sonnet
      synthesis: haiku
NEW: subagents:
  defaults:
    model: sonnet
    categories:
      research: haiku
      review: sonnet
      workflow: sonnet
      synthesis: haiku
      explore: haiku
      general-purpose: sonnet

--- 2026-02-21T08:24:55Z | plugins/interserve/internal/query/query.go | CONTEXT:unknown ---
OLD: 	// Read files into memory, validate existence and size.
	fileContents := make(map[string]string, len(files))
	totalLines := 0
	for _, path := range files {
NEW: 	// Check cache before reading files.
	key := cacheKey(question, files, mode)
	if cached := cacheGet(key); cached != nil {
		return *cached
	}

	// Read files into memory, validate existence and size.
	fileContents := make(map[string]string, len(files))
	totalLines := 0
	for _, path := range files {

--- 2026-02-21T08:25:00Z | plugins/interserve/internal/query/query.go | CONTEXT:unknown ---
OLD: 	return QueryResult{
		Status:         "success",
		Answer:         answer,
		FilesAnalyzed:  files,
		LineCountSaved: totalLines,
		Mode:           mode,
	}
}
NEW: 	result := QueryResult{
		Status:         "success",
		Answer:         answer,
		FilesAnalyzed:  files,
		LineCountSaved: totalLines,
		Mode:           mode,
	}
	cachePut(key, result, buildMtimes(files))
	return result
}

--- 2026-02-21T08:25:04Z | plugins/interserve/internal/query/cache.go | CONTEXT:unknown ---
OLD: // init registers a debug message. Callers don't need to do anything.
func init() {
	_ = strings.TrimSpace // avoid unused import if strings not used elsewhere
}
NEW: 

--- 2026-02-21T08:25:07Z | plugins/interserve/internal/query/cache.go | CONTEXT:unknown ---
OLD: 	"strings"
	"sync"
NEW: 	"sync"

--- 2026-02-21T08:25:32Z | docs/roadmap.md | CONTEXT:unknown ---
OLD: **Modules:** 36 | **Open beads (root tracker):** 336 | **Blocked (root tracker):** 52 | **Last updated:** 2026-02-20
NEW: **Modules:** 36 | **Open beads (root tracker):** 330 | **Blocked (root tracker):** 41 | **Last updated:** 2026-02-21

--- 2026-02-21T08:26:00Z | docs/roadmap.md | CONTEXT:unknown ---
OLD: ### Now (P0-P1)

- [autarch] **iv-0v7j** Wire signal broker into Bigend/TUI runtime path (blocks iv-6abk)

**Recently completed:** iv-1vz6 (Update vision doc: rollback is already shipped in v1 CLI), iv-erb1 (Deduplicate CLAUDE_SESSION_ID env writes), iv-mew5 (Register or remove interserve pre-read-intercept.sh), iv-mctg (Add matcher to intercheck context-monitor.sh), iv-juzy (Fix interflux hooks.json schema), iv-iu31 (Remove tool-time PreToolUse binding, extract Task redirect to clavain), iv-145j (Implement event-reactor auto-advance loop for phase transitions), iv-t93l (Close Interspect routing loop with automatic adaptation), iv-2lfb (F1: Build infra/interbase/ — centralized interbase.sh SDK), iv-h7e2 (F2: Define integration.json schema + interbase-stub.sh template), iv-gcu2 (Dual-mode plugin architecture — interbase SDK + integration manifest), iv-kj6w (A2: Sprint handover — sprint skill becomes kernel-driven), iv-bld6 (F2: Workflow state rollback (ic run rollback --to-phase)), iv-2yef (Autarch: ship minimal status tool as kernel validation wedge), iv-8jpf (Add reflect/compound phase to default sprint chain), iv-3sns (E4.1: Kernel interspect_events table + ic interspect record CLI), iv-shra (E4.2: Durable cursor registration for long-lived consumers), iv-ooon (Harmonize Clavain docs with revised vision — 6 drift fixes), iv-byh3 (Define platform kernel + lifecycle UX architecture), iv-7o7n (Document slicing for flux-drive agents (P0 token optimization))
NEW: ### Now (P0-P1)

No P0-P1 beads currently open.

**Recently completed:** iv-0v7j (Wire signal broker into Bigend/TUI runtime path), iv-rzt0 (Interband signal publishers), iv-sk8t (Interline statusline enrichment), iv-sprh (Cost-aware review depth), iv-yo9i (Config reader library), iv-re4l (Dispatch integration --phase flag), iv-pg8t (Subagent integration /model-routing), iv-1sc0 (Companion plugin dependency graph), iv-gye6 (Interbase batch SDK adoption), iv-l5ap (Research: transactional orchestration & error recovery), iv-fhz1 (Sprint close sweep for child beads), iv-1vz6 (Update vision doc: rollback is already shipped in v1 CLI), iv-erb1 (Deduplicate CLAUDE_SESSION_ID env writes), iv-mew5 (Register or remove interserve pre-read-intercept.sh), iv-mctg (Add matcher to intercheck context-monitor.sh), iv-juzy (Fix interflux hooks.json schema), iv-iu31 (Remove tool-time PreToolUse binding, extract Task redirect to clavain), iv-145j (Implement event-reactor auto-advance loop for phase transitions), iv-t93l (Close Interspect routing loop with automatic adaptation), iv-2lfb (F1: Build infra/interbase/ — centralized interbase.sh SDK), iv-h7e2 (F2: Define integration.json schema + interbase-stub.sh template), iv-gcu2 (Dual-mode plugin architecture — interbase SDK + integration manifest), iv-kj6w (A2: Sprint handover — sprint skill becomes kernel-driven), iv-bld6 (F2: Workflow state rollback (ic run rollback --to-phase)), iv-2yef (Autarch: ship minimal status tool as kernel validation wedge), iv-8jpf (Add reflect/compound phase to default sprint chain), iv-3sns (E4.1: Kernel interspect_events table + ic interspect record CLI), iv-shra (E4.2: Durable cursor registration for long-lived consumers), iv-ooon (Harmonize Clavain docs with revised vision — 6 drift fixes), iv-byh3 (Define platform kernel + lifecycle UX architecture), iv-7o7n (Document slicing for flux-drive agents (P0 token optimization))

--- 2026-02-21T08:26:10Z | docs/roadmap.md | CONTEXT:unknown ---
OLD: **Model Routing Pipeline**
- **iv-i64p** F1: Routing config schema (config/routing.yaml)
- **iv-jayq** F2: Resolution library (hooks/lib-routing.sh)
- **iv-yo9i** F2: Config reader library (lib-routing.sh)
- **iv-6nwo** F3: Dispatch migration (dispatch.sh reads routing.yaml)
- **iv-re4l** F3: Dispatch integration (--phase flag)
- **iv-pg8t** F4: Subagent integration (/model-routing reads routing.yaml)
- **iv-sz5b** F4: Update model-routing command to use routing.yaml
- [clavain] **iv-k8xn** B2: Complexity-aware routing — task complexity drives model selection
- **iv-rzt0** F1: Interband signal publishers (intercheck, interstat, interlock)
- **iv-sk8t** F2: Interline statusline enrichment (pressure, coordination, budget)
- **iv-sprh** F6: Cost-aware review depth (always-on budget signal)
NEW: **Model Routing Pipeline**
- **iv-i64p** F1: Routing config schema (config/routing.yaml)
- **iv-jayq** F2: Resolution library (hooks/lib-routing.sh)
- **iv-6nwo** F3: Dispatch migration (dispatch.sh reads routing.yaml)
- **iv-sz5b** F4: Update model-routing command to use routing.yaml
- [clavain] **iv-k8xn** B2: Complexity-aware routing — task complexity drives model selection

--- 2026-02-21T08:26:16Z | docs/roadmap.md | CONTEXT:unknown ---
OLD: - **iv-frqh** F5: clavain:setup modpack — auto-install ecosystem-only plugins
- **iv-1sc0** F7: Companion plugin dependency graph
- **iv-gye6** F3: Interbase batch SDK adoption (6 plugins)
- **iv-zyym** Evaluate Claude Hub for event-driven GitHub agent dispatch
NEW: - **iv-frqh** F5: clavain:setup modpack — auto-install ecosystem-only plugins
- **iv-zyym** Evaluate Claude Hub for event-driven GitHub agent dispatch

--- 2026-02-21T08:26:21Z | docs/roadmap.md | CONTEXT:unknown ---
OLD: - **iv-l5ap** Research: transactional orchestration & error recovery patterns
- **iv-fzrn** Research: multi-agent hallucination cascades & failure taxonomy
NEW: - **iv-fzrn** Research: multi-agent hallucination cascades & failure taxonomy

--- 2026-02-21T08:26:27Z | docs/roadmap.md | CONTEXT:unknown ---
OLD: - **Plugin Synergy via Interband** — Connect plugins through atomic interband signals for context pressure, budget alerts, tool performance hints, and cross-plugin nudges; establish dual-mode architecture patterns
NEW: - ~~**Plugin Synergy via Interband**~~ — *Completed:* interband signal publishers, interline statusline enrichment, interbase SDK adoption, and dual-mode architecture patterns all shipped

--- 2026-02-21T08:27:14Z | .interwatch/drift.json | CONTEXT:unknown ---
OLD:     "roadmap": {
      "path": "docs/roadmap.md",
      "exists": true,
      "score": 14,
      "confidence": "High",
      "stale": false,
      "signals": {
        "bead_closed": {
          "count": 7,
          "weight": 2,
          "score": 14,
          "detail": "iv-rzt0, iv-sk8t, iv-gye6, iv-1sc0, iv-sprh closed (interop features shipped in parent epic iv-vlg4)"
        },
        "bead_created": {
          "count": 0,
          "weight": 1,
          "score": 0
        },
        "version_bump": {
          "count": 0,
          "weight": 3,
          "score": 0
        },
        "brainstorm_created": {
          "count": 0,
          "weight": 1,
          "score": 0
        }
      },
      "recommended_action": "auto-refresh-with-note",
      "generator": "interpath:artifact-gen",
      "generator_args": {
        "type": "roadmap"
      }
    }
NEW:     "roadmap": {
      "path": "docs/roadmap.md",
      "exists": true,
      "score": 0,
      "confidence": "Green",
      "stale": false,
      "signals": {
        "bead_closed": {
          "count": 0,
          "weight": 2,
          "score": 0,
          "detail": "Refreshed 2026-02-21: removed 10 closed beads, updated counts and research agenda"
        },
        "bead_created": {
          "count": 0,
          "weight": 1,
          "score": 0
        },
        "version_bump": {
          "count": 0,
          "weight": 3,
          "score": 0
        },
        "brainstorm_created": {
          "count": 0,
          "weight": 1,
          "score": 0
        }
      },
      "recommended_action": "none",
      "generator": "interpath:artifact-gen",
      "generator_args": {
        "type": "roadmap"
      }
    }

--- 2026-02-21T08:30:15Z | os/clavain/agent-rig.json | CONTEXT:unknown ---
OLD: "version": "0.6.57"
NEW: "version": "0.6.59"

--- 2026-02-21T08:33:00Z | infra/intercore/docs/brainstorms/2026-02-21-cost-aware-agent-scheduling-brainstorm.md | CONTEXT:unknown ---
OLD: 4. **Model column on dispatches:** Does it already exist? If not, adding it is a schema change. Agents would need to report their model.
NEW: 4. **Model column on dispatches:** Already exists (`model TEXT` in schema.sql). No schema change needed for cost model lookups.

--- 2026-02-21T08:36:38Z | infra/intercore/internal/db/schema.sql | CONTEXT:unknown ---
OLD:     parent_run_id   TEXT,
    max_dispatches  INTEGER DEFAULT 0
);
NEW:     parent_run_id   TEXT,
    max_dispatches  INTEGER DEFAULT 0,
    budget_enforce  INTEGER DEFAULT 0,
    max_agents      INTEGER DEFAULT 0
);

--- 2026-02-21T08:36:41Z | infra/intercore/internal/db/schema.sql | CONTEXT:unknown ---
OLD:     quarantine_reason TEXT
);
NEW:     quarantine_reason TEXT,
    spawn_depth       INTEGER NOT NULL DEFAULT 0,
    parent_dispatch_id TEXT NOT NULL DEFAULT ''
);

--- 2026-02-21T08:36:46Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	currentSchemaVersion = 11
	maxSchemaVersion     = 11
NEW: 	currentSchemaVersion = 12
	maxSchemaVersion     = 12

--- 2026-02-21T08:36:46Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   'reflect':        ['clavain', 'interdoc', 'interfluence'],
  'ship':           ['clavain', 'interlock']
};

// Toggle state
NEW:   'reflect':        ['clavain', 'interdoc', 'interfluence'],
  'ship':           ['clavain', 'interlock']
};

// Fine-grained: which specific skills/agents/MCP servers each phase uses (tier 2 — on-demand spotlight, NOT force links)
var PHASE_SKILLS = {
  'brainstorm':    { skills: ['clavain:brainstorming'], agents: [], mcp: [] },
  'strategize':    { skills: ['clavain:writing-plans'], agents: [], mcp: [] },
  'write-plan':    { skills: ['clavain:writing-plans'], agents: [], mcp: [] },
  'review-plan':   { skills: ['interflux:flux-drive', 'interpeer:interpeer'],
                     agents: ['interflux:agent:fd-architecture', 'interflux:agent:fd-safety',
                              'interflux:agent:fd-correctness', 'interflux:agent:fd-user-product',
                              'interflux:agent:fd-quality', 'intersynth:agent:synthesize-review'],
                     mcp: [] },
  'execute':       { skills: ['clavain:executing-plans', 'interdev:working-with-claude-code',
                              'intertest:test-driven-development'], agents: [], mcp: [] },
  'test':          { skills: ['intertest:test-driven-development', 'intertest:verification-before-completion',
                              'intertest:systematic-debugging'], agents: [], mcp: [] },
  'quality-gates': { skills: ['interflux:flux-drive', 'intercheck:status', 'interpeer:interpeer'],
                     agents: ['interflux:agent:fd-architecture', 'interflux:agent:fd-safety',
                              'interflux:agent:fd-correctness', 'interflux:agent:fd-user-product',
                              'interflux:agent:fd-quality', 'intersynth:agent:synthesize-review',
                              'intercraft:agent:agent-native-reviewer'],
                     mcp: [] },
  'resolve':       { skills: ['interflux:flux-drive', 'clavain:code-review-discipline'], agents: [], mcp: [] },
  'reflect':       { skills: ['interdoc:interdoc', 'clavain:engineering-docs'],
                     agents: ['interfluence:agent:voice-analyzer'], mcp: [] },
  'ship':          { skills: ['clavain:landing-a-change'], agents: [], mcp: [] }
};

// Reverse lookup: nodeId -> [phaseId, ...] (from both PHASE_PLUGINS and PHASE_SKILLS)
var nodeToPhases = {};
function addNodePhase(nodeId, phaseId) {
  if (!nodeToPhases[nodeId]) nodeToPhases[nodeId] = [];
  if (nodeToPhases[nodeId].indexOf(phaseId) === -1) nodeToPhases[nodeId].push(phaseId);
}
Object.keys(PHASE_PLUGINS).forEach(function(phaseId) {
  PHASE_PLUGINS[phaseId].forEach(function(pid) { addNodePhase(pid, phaseId); });
});
Object.keys(PHASE_SKILLS).forEach(function(phaseId) {
  var entry = PHASE_SKILLS[phaseId];
  entry.skills.forEach(function(sid) { addNodePhase(sid, phaseId); });
  entry.agents.forEach(function(aid) { addNodePhase(aid, phaseId); });
  entry.mcp.forEach(function(mid) { addNodePhase(mid, phaseId); });
});

// Toggle state

--- 2026-02-21T08:36:57Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: /* Sprint flow arrows (decorative layer) */
.sprint-flow-arrow { pointer-events: none; }
.gate-diamond { pointer-events: none; }

</style>
NEW: /* Sprint flow arrows (decorative layer) */
.sprint-flow-arrow { pointer-events: none; }
.gate-diamond { pointer-events: none; }

/* Spotlight layer — on-demand bezier curves for tier-2 skill/agent connections */
.spotlight-layer path {
  pointer-events: none;
  filter: drop-shadow(0 0 4px rgba(69, 183, 209, 0.5));
}

</style>

--- 2026-02-21T08:36:57Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	// Apply schema DDL
	if _, err := tx.ExecContext(ctx, schemaDDL); err != nil {
		return fmt.Errorf("migrate: apply schema: %w", err)
	}
NEW: 	// v11 → v12: cost-aware scheduling columns
	// Guard: runs exists from v3+, dispatches from v2+
	if currentVersion >= 3 && currentVersion < 12 {
		v12RunStmts := []string{
			"ALTER TABLE runs ADD COLUMN budget_enforce INTEGER DEFAULT 0",
			"ALTER TABLE runs ADD COLUMN max_agents INTEGER DEFAULT 0",
		}
		for _, stmt := range v12RunStmts {
			if _, err := tx.ExecContext(ctx, stmt); err != nil {
				if !isDuplicateColumnError(err) {
					return fmt.Errorf("migrate v11→v12: %w", err)
				}
			}
		}
	}
	if currentVersion >= 2 && currentVersion < 12 {
		v12DispatchStmts := []string{
			"ALTER TABLE dispatches ADD COLUMN spawn_depth INTEGER NOT NULL DEFAULT 0",
			"ALTER TABLE dispatches ADD COLUMN parent_dispatch_id TEXT NOT NULL DEFAULT ''",
		}
		for _, stmt := range v12DispatchStmts {
			if _, err := tx.ExecContext(ctx, stmt); err != nil {
				if !isDuplicateColumnError(err) {
					return fmt.Errorf("migrate v11→v12: %w", err)
				}
			}
		}
	}

	// Apply schema DDL
	if _, err := tx.ExecContext(ctx, schemaDDL); err != nil {
		return fmt.Errorf("migrate: apply schema: %w", err)
	}

--- 2026-02-21T08:37:02Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: var sprintFlowGroup = g.append('g').attr('class', 'sprint-flow-layer');
var sprintNodeGroup = g.append('g').attr('class', 'sprint-node-layer');
NEW: var sprintFlowGroup = g.append('g').attr('class', 'sprint-flow-layer');
var sprintNodeGroup = g.append('g').attr('class', 'sprint-node-layer');
var spotlightGroup = g.append('g').attr('class', 'spotlight-layer');

--- 2026-02-21T08:37:05Z | infra/intercore/internal/phase/phase.go | CONTEXT:unknown ---
OLD: 	ParentRunID   *string
	MaxDispatches int
}
NEW: 	ParentRunID    *string
	MaxDispatches  int
	BudgetEnforce  bool
	MaxAgents      int
}

--- 2026-02-21T08:37:11Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 	ScopeID          *string
	ParentID         *string
	BaseRepoCommit   *string
	RetryCount       int
	ConflictType     *string
	QuarantineReason *string
}
NEW: 	ScopeID            *string
	ParentID           *string
	BaseRepoCommit     *string
	RetryCount         int
	ConflictType       *string
	QuarantineReason   *string
	SpawnDepth         int
	ParentDispatchID   string
}

--- 2026-02-21T08:37:13Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // ── Sprint node interactions ──

function selectSprintNode(sn) {
NEW: // ── Spotlight layer — on-demand bezier curves for tier-2 connections ──

function drawSpotlightConnections(sourceNode, targetIds) {
  spotlightGroup.selectAll('*').remove();
  targetIds.forEach(function(tid) {
    var targetNode = nodeById[tid];
    if (!targetNode) return;
    var sx = sourceNode.x, sy = sourceNode.y;
    var tx = targetNode.x, ty = targetNode.y;
    var mx = (sx + tx) / 2;
    var my = (sy + ty) / 2 - 40; // curve upward
    spotlightGroup.append('path')
      .attr('d', 'M' + sx + ',' + sy + ' Q' + mx + ',' + my + ' ' + tx + ',' + ty)
      .attr('fill', 'none')
      .attr('stroke', '#45B7D1')
      .attr('stroke-width', 1.5)
      .attr('stroke-dasharray', '6 3')
      .attr('stroke-opacity', 0)
      .attr('data-source', sourceNode.id)
      .attr('data-target', tid)
      .transition().duration(300)
      .attr('stroke-opacity', 0.7);
  });
}

function updateSpotlightPaths() {
  var paths = spotlightGroup.selectAll('path');
  if (paths.empty()) return;
  paths.each(function() {
    var el = d3.select(this);
    var sid = el.attr('data-source');
    var tid = el.attr('data-target');
    var sn = nodeById[sid];
    var tn = nodeById[tid];
    if (!sn || !tn) return;
    var mx = (sn.x + tn.x) / 2;
    var my = (sn.y + tn.y) / 2 - 40;
    el.attr('d', 'M' + sn.x + ',' + sn.y + ' Q' + mx + ',' + my + ' ' + tn.x + ',' + tn.y);
  });
}

// ── Sprint node interactions ──

function selectSprintNode(sn) {

--- 2026-02-21T08:37:27Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 	_, err = s.db.ExecContext(ctx, `
		INSERT INTO dispatches (
			id, agent_type, status, project_dir, prompt_file, prompt_hash,
			output_file, verdict_file, name, model, sandbox, timeout_sec,
			scope_id, parent_id, base_repo_commit
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		id, d.AgentType, StatusSpawned, d.ProjectDir,
		d.PromptFile, d.PromptHash, d.OutputFile, d.VerdictFile,
		d.Name, d.Model, d.Sandbox, d.TimeoutSec,
		d.ScopeID, d.ParentID, d.BaseRepoCommit,
	)
NEW: 	_, err = s.db.ExecContext(ctx, `
		INSERT INTO dispatches (
			id, agent_type, status, project_dir, prompt_file, prompt_hash,
			output_file, verdict_file, name, model, sandbox, timeout_sec,
			scope_id, parent_id, base_repo_commit,
			spawn_depth, parent_dispatch_id
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		id, d.AgentType, StatusSpawned, d.ProjectDir,
		d.PromptFile, d.PromptHash, d.OutputFile, d.VerdictFile,
		d.Name, d.Model, d.Sandbox, d.TimeoutSec,
		d.ScopeID, d.ParentID, d.BaseRepoCommit,
		d.SpawnDepth, d.ParentDispatchID,
	)

--- 2026-02-21T08:37:37Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function selectSprintNode(sn) {
  var phase = sn._phase;
  var connectedIds = new Set([sn.id]);

  // Find participating ecosystem nodes
  if (ecosystemActive && PHASE_PLUGINS[phase.id]) {
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      if (nodeById[pid]) connectedIds.add(pid);
    });
  }

  // Also connect to adjacent sprint phases
  var idx = SPRINT_PHASES.indexOf(phase);
  if (idx > 0) connectedIds.add('sprint-' + SPRINT_PHASES[idx - 1].id);
  if (idx < SPRINT_PHASES.length - 1) connectedIds.add('sprint-' + SPRINT_PHASES[idx + 1].id);

  // Highlight/dim ecosystem nodes
  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });
  link.classed('highlighted', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return sid === sn.id || tid === sn.id;
  });
  link.classed('dimmed', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return sid !== sn.id && tid !== sn.id;
  });

  // Highlight/dim sprint phase nodes
  sprintNodeGroup.selectAll('.sprint-phase-node')
    .classed('highlighted', function() { return connectedIds.has(d3.select(this).attr('data-id')); })
    .classed('dimmed', function() { return !connectedIds.has(d3.select(this).attr('data-id')); });

  showSprintDetail(phase);
}
NEW: function selectSprintNode(sn) {
  var phase = sn._phase;
  var connectedIds = new Set([sn.id]);
  var spotlightTargets = [];

  // Find participating ecosystem nodes (tier 1 — force links)
  if (ecosystemActive && PHASE_PLUGINS[phase.id]) {
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      if (nodeById[pid]) connectedIds.add(pid);
    });
  }

  // Find tier-2 skill/agent/MCP nodes (spotlight, not force links)
  if (ecosystemActive && PHASE_SKILLS[phase.id]) {
    var entry = PHASE_SKILLS[phase.id];
    entry.skills.concat(entry.agents).concat(entry.mcp).forEach(function(id) {
      if (nodeById[id]) {
        connectedIds.add(id);
        spotlightTargets.push(id);
      }
    });
  }

  // Also connect to adjacent sprint phases
  var idx = SPRINT_PHASES.indexOf(phase);
  if (idx > 0) connectedIds.add('sprint-' + SPRINT_PHASES[idx - 1].id);
  if (idx < SPRINT_PHASES.length - 1) connectedIds.add('sprint-' + SPRINT_PHASES[idx + 1].id);

  // Highlight/dim ecosystem nodes
  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });

  // Highlight edges: light up participates-in edges AND provides-skill/provides-agent edges
  // between highlighted plugins and their highlighted children
  link.classed('highlighted', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return connectedIds.has(sid) && connectedIds.has(tid);
  });
  link.classed('dimmed', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return !(connectedIds.has(sid) && connectedIds.has(tid));
  });

  // Highlight/dim sprint phase nodes
  sprintNodeGroup.selectAll('.sprint-phase-node')
    .classed('highlighted', function() { return connectedIds.has(d3.select(this).attr('data-id')); })
    .classed('dimmed', function() { return !connectedIds.has(d3.select(this).attr('data-id')); });

  // Draw spotlight bezier curves to tier-2 nodes
  if (spotlightTargets.length > 0) {
    drawSpotlightConnections(sn, spotlightTargets);
  } else {
    spotlightGroup.selectAll('*').remove();
  }

  showSprintDetail(phase);
}

--- 2026-02-21T08:37:47Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: const dispatchCols = `id, agent_type, status, project_dir, prompt_file, prompt_hash,
	output_file, verdict_file, pid, exit_code, name, model, sandbox,
	timeout_sec, turns, commands, messages, input_tokens, output_tokens,
	cache_hits, created_at, started_at, completed_at, verdict_status,
	verdict_summary, error_message, scope_id, parent_id,
	base_repo_commit, retry_count, conflict_type, quarantine_reason`
NEW: const dispatchCols = `id, agent_type, status, project_dir, prompt_file, prompt_hash,
	output_file, verdict_file, pid, exit_code, name, model, sandbox,
	timeout_sec, turns, commands, messages, input_tokens, output_tokens,
	cache_hits, created_at, started_at, completed_at, verdict_status,
	verdict_summary, error_message, scope_id, parent_id,
	base_repo_commit, retry_count, conflict_type, quarantine_reason,
	spawn_depth, parent_dispatch_id`

--- 2026-02-21T08:37:51Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function deselectAll() {
  selectedNode = null;
  node.classed('highlighted', false).classed('dimmed', false);
  link.classed('highlighted', false).classed('dimmed', false);
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node')
      .classed('highlighted', false).classed('dimmed', false);
  }
}
NEW: function deselectAll() {
  selectedNode = null;
  node.classed('highlighted', false).classed('dimmed', false);
  link.classed('highlighted', false).classed('dimmed', false);
  spotlightGroup.selectAll('*').remove();
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node')
      .classed('highlighted', false).classed('dimmed', false);
  }
}

--- 2026-02-21T08:37:55Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function rebuildGraph() {
  // Clear sprint-specific rendering
  sprintNodeGroup.selectAll('*').remove();
  sprintFlowGroup.selectAll('*').remove();
NEW: function rebuildGraph() {
  // Clear sprint-specific rendering + spotlight
  sprintNodeGroup.selectAll('*').remove();
  sprintFlowGroup.selectAll('*').remove();
  spotlightGroup.selectAll('*').remove();

--- 2026-02-21T08:37:58Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 		&scopeID, &parentID,
		&baseRepoCommit, &d.RetryCount, &conflictType, &quarantineReason,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("dispatch get: %w", err)
	}

	d.PromptFile = nullStr(promptFile)
	d.PromptHash = nullStr(promptHash)
	d.OutputFile = nullStr(outputFile)
	d.VerdictFile = nullStr(verdictFile)
	d.PID = nullInt(pid)
	d.ExitCode = nullInt(exitCode)
	d.Name = nullStr(name)
	d.Model = nullStr(model)
	d.Sandbox = nullStr(sandbox)
	d.TimeoutSec = nullInt(timeoutSec)
	d.CacheHits = nullInt(cacheHits)
	d.StartedAt = nullInt64(startedAt)
	d.CompletedAt = nullInt64(completedAt)
	d.VerdictStatus = nullStr(verdictStatus)
	d.VerdictSummary = nullStr(verdictSummary)
	d.ErrorMessage = nullStr(errorMessage)
	d.ScopeID = nullStr(scopeID)
	d.ParentID = nullStr(parentID)
	d.BaseRepoCommit = nullStr(baseRepoCommit)
	d.ConflictType = nullStr(conflictType)
	d.QuarantineReason = nullStr(quarantineReason)

	return d, nil
}
NEW: 		&scopeID, &parentID,
		&baseRepoCommit, &d.RetryCount, &conflictType, &quarantineReason,
		&d.SpawnDepth, &d.ParentDispatchID,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("dispatch get: %w", err)
	}

	d.PromptFile = nullStr(promptFile)
	d.PromptHash = nullStr(promptHash)
	d.OutputFile = nullStr(outputFile)
	d.VerdictFile = nullStr(verdictFile)
	d.PID = nullInt(pid)
	d.ExitCode = nullInt(exitCode)
	d.Name = nullStr(name)
	d.Model = nullStr(model)
	d.Sandbox = nullStr(sandbox)
	d.TimeoutSec = nullInt(timeoutSec)
	d.CacheHits = nullInt(cacheHits)
	d.StartedAt = nullInt64(startedAt)
	d.CompletedAt = nullInt64(completedAt)
	d.VerdictStatus = nullStr(verdictStatus)
	d.VerdictSummary = nullStr(verdictSummary)
	d.ErrorMessage = nullStr(errorMessage)
	d.ScopeID = nullStr(scopeID)
	d.ParentID = nullStr(parentID)
	d.BaseRepoCommit = nullStr(baseRepoCommit)
	d.ConflictType = nullStr(conflictType)
	d.QuarantineReason = nullStr(quarantineReason)

	return d, nil
}

--- 2026-02-21T08:38:00Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  updateHulls();
});
NEW:   node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  updateHulls();
  updateSpotlightPaths();
});

--- 2026-02-21T08:38:13Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: 			&scopeID, &parentID,
			&baseRepoCommit, &d.RetryCount, &conflictType, &quarantineReason,
		); err != nil {
			return nil, fmt.Errorf("dispatch list scan: %w", err)
		}

		d.PromptFile = nullStr(promptFile)
		d.PromptHash = nullStr(promptHash)
		d.OutputFile = nullStr(outputFile)
		d.VerdictFile = nullStr(verdictFile)
		d.PID = nullInt(pid)
		d.ExitCode = nullInt(exitCode)
		d.Name = nullStr(name)
		d.Model = nullStr(model)
		d.Sandbox = nullStr(sandbox)
		d.TimeoutSec = nullInt(timeoutSec)
		d.CacheHits = nullInt(cacheHits)
		d.StartedAt = nullInt64(startedAt)
		d.CompletedAt = nullInt64(completedAt)
		d.VerdictStatus = nullStr(verdictStatus)
		d.VerdictSummary = nullStr(verdictSummary)
		d.ErrorMessage = nullStr(errorMessage)
		d.ScopeID = nullStr(scopeID)
		d.ParentID = nullStr(parentID)
		d.BaseRepoCommit = nullStr(baseRepoCommit)
		d.ConflictType = nullStr(conflictType)
		d.QuarantineReason = nullStr(quarantineReason)

		dispatches = append(dispatches, d)
NEW: 			&scopeID, &parentID,
			&baseRepoCommit, &d.RetryCount, &conflictType, &quarantineReason,
			&d.SpawnDepth, &d.ParentDispatchID,
		); err != nil {
			return nil, fmt.Errorf("dispatch list scan: %w", err)
		}

		d.PromptFile = nullStr(promptFile)
		d.PromptHash = nullStr(promptHash)
		d.OutputFile = nullStr(outputFile)
		d.VerdictFile = nullStr(verdictFile)
		d.PID = nullInt(pid)
		d.ExitCode = nullInt(exitCode)
		d.Name = nullStr(name)
		d.Model = nullStr(model)
		d.Sandbox = nullStr(sandbox)
		d.TimeoutSec = nullInt(timeoutSec)
		d.CacheHits = nullInt(cacheHits)
		d.StartedAt = nullInt64(startedAt)
		d.CompletedAt = nullInt64(completedAt)
		d.VerdictStatus = nullStr(verdictStatus)
		d.VerdictSummary = nullStr(verdictSummary)
		d.ErrorMessage = nullStr(errorMessage)
		d.ScopeID = nullStr(scopeID)
		d.ParentID = nullStr(parentID)
		d.BaseRepoCommit = nullStr(baseRepoCommit)
		d.ConflictType = nullStr(conflictType)
		d.QuarantineReason = nullStr(quarantineReason)

		dispatches = append(dispatches, d)

--- 2026-02-21T08:38:21Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   // Participating plugins section
  if (PHASE_PLUGINS[phase.id] && PHASE_PLUGINS[phase.id].length > 0) {
    var plugTitle = document.createElement('div');
    plugTitle.className = 'section-title';
    plugTitle.textContent = 'Participating Plugins';
    content.appendChild(plugTitle);

    var plugUl = document.createElement('ul');
    plugUl.className = 'child-list';
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      var pNode = nodeById[pid];
      if (!pNode) return;
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + (TYPE_COLORS[pNode.type] || '#8b949e');
      li.textContent = pNode.label + ' ';
      var ts = document.createElement('span');
      ts.className = 'child-type';
      ts.textContent = TYPE_LABELS[pNode.type] || pNode.type;
      li.appendChild(ts);
      li.onclick = function() { navigateTo(pid); };
      plugUl.appendChild(li);
    });
    content.appendChild(plugUl);
  }

  panel.classList.add('open');
}
NEW:   // Orchestrating plugins (tier 1 — force-linked)
  if (PHASE_PLUGINS[phase.id] && PHASE_PLUGINS[phase.id].length > 0) {
    var plugTitle = document.createElement('div');
    plugTitle.className = 'section-title';
    plugTitle.textContent = 'Orchestrating Plugins';
    content.appendChild(plugTitle);

    var plugUl = document.createElement('ul');
    plugUl.className = 'child-list';
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      var pNode = nodeById[pid];
      if (!pNode) return;
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + (TYPE_COLORS[pNode.type] || '#8b949e');
      li.textContent = pNode.label + ' ';
      var ts = document.createElement('span');
      ts.className = 'child-type';
      ts.textContent = TYPE_LABELS[pNode.type] || pNode.type;
      li.appendChild(ts);
      li.onclick = function() { navigateTo(pid); };
      plugUl.appendChild(li);
    });
    content.appendChild(plugUl);
  }

  // Tier-2 fine-grained connections (skills, agents, MCP servers)
  if (PHASE_SKILLS[phase.id]) {
    var entry = PHASE_SKILLS[phase.id];
    var sections = [
      { label: 'Skills', ids: entry.skills, color: TYPE_COLORS['skill'] },
      { label: 'Agents', ids: entry.agents, color: TYPE_COLORS['agent'] },
      { label: 'MCP Servers', ids: entry.mcp, color: TYPE_COLORS['mcp-server'] }
    ];
    sections.forEach(function(sec) {
      if (sec.ids.length === 0) return;
      var secTitle = document.createElement('div');
      secTitle.className = 'section-title';
      secTitle.textContent = sec.label;
      content.appendChild(secTitle);

      var secUl = document.createElement('ul');
      secUl.className = 'child-list';
      sec.ids.forEach(function(nid) {
        var sNode = nodeById[nid];
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + sec.color;
        if (sNode) {
          li.textContent = sNode.label + ' ';
          var ts = document.createElement('span');
          ts.className = 'child-type';
          ts.textContent = TYPE_LABELS[sNode.type] || sNode.type;
          li.appendChild(ts);
          li.onclick = function() { navigateTo(nid); };
        } else {
          li.textContent = nid;
          li.style.opacity = '0.5';
        }
        secUl.appendChild(li);
      });
      content.appendChild(secUl);
    });
  }

  panel.classList.add('open');
}

--- 2026-02-21T08:38:33Z | infra/intercore/internal/phase/store.go | CONTEXT:unknown ---
OLD: 	now := time.Now().Unix()
	_, err = s.db.ExecContext(ctx, `
		INSERT INTO runs (
			id, project_dir, goal, status, phase, complexity,
			force_full, auto_advance, created_at, updated_at,
			scope_id, metadata, phases, token_budget, budget_warn_pct,
			parent_run_id, max_dispatches
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		id, r.ProjectDir, r.Goal, StatusActive, initialPhase,
		r.Complexity, boolToInt(r.ForceFull), boolToInt(r.AutoAdvance),
		now, now, r.ScopeID, r.Metadata,
		phasesJSON, r.TokenBudget, budgetWarnPct,
		r.ParentRunID, r.MaxDispatches,
	)
NEW: 	now := time.Now().Unix()
	_, err = s.db.ExecContext(ctx, `
		INSERT INTO runs (
			id, project_dir, goal, status, phase, complexity,
			force_full, auto_advance, created_at, updated_at,
			scope_id, metadata, phases, token_budget, budget_warn_pct,
			parent_run_id, max_dispatches, budget_enforce, max_agents
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		id, r.ProjectDir, r.Goal, StatusActive, initialPhase,
		r.Complexity, boolToInt(r.ForceFull), boolToInt(r.AutoAdvance),
		now, now, r.ScopeID, r.Metadata,
		phasesJSON, r.TokenBudget, budgetWarnPct,
		r.ParentRunID, r.MaxDispatches,
		boolToInt(r.BudgetEnforce), r.MaxAgents,
	)

--- 2026-02-21T08:38:38Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   // Sprint phases this node participates in (if sprint is active)
  if (sprintActive) {
    var nodePhases = [];
    Object.keys(PHASE_PLUGINS).forEach(function(phaseId) {
      if (PHASE_PLUGINS[phaseId].indexOf(d.id) !== -1) {
        var phase = SPRINT_PHASES.find(function(p) { return p.id === phaseId; });
        if (phase) nodePhases.push(phase);
      }
    });
    if (nodePhases.length > 0) {
      var spTitle = document.createElement('div');
      spTitle.className = 'section-title';
      spTitle.textContent = 'Sprint Phases';
      content.appendChild(spTitle);

      var spUl = document.createElement('ul');
      spUl.className = 'child-list';
      nodePhases.forEach(function(phase) {
        var phaseColor = PHASE_COLORS[phase.phase] || '#8b949e';
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + phaseColor;
        li.textContent = phase.step + '. ' + phase.label + ' ';
        var ts = document.createElement('span');
        ts.className = 'child-type';
        ts.textContent = phase.phase;
        li.appendChild(ts);
        spUl.appendChild(li);
      });
      content.appendChild(spUl);
    }
  }
NEW:   // Sprint phases this node participates in (if sprint is active)
  if (sprintActive && nodeToPhases[d.id]) {
    var nodePhases = [];
    nodeToPhases[d.id].forEach(function(phaseId) {
      var phase = SPRINT_PHASES.find(function(p) { return p.id === phaseId; });
      if (phase) nodePhases.push(phase);
    });
    if (nodePhases.length > 0) {
      var spTitle = document.createElement('div');
      spTitle.className = 'section-title';
      spTitle.textContent = 'Sprint Phases';
      content.appendChild(spTitle);

      var spUl = document.createElement('ul');
      spUl.className = 'child-list';
      nodePhases.forEach(function(phase) {
        var phaseColor = PHASE_COLORS[phase.phase] || '#8b949e';
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + phaseColor;
        li.textContent = phase.step + '. ' + phase.label + ' ';
        var ts = document.createElement('span');
        ts.className = 'child-type';
        ts.textContent = phase.phase;
        li.appendChild(ts);
        li.style.cursor = 'pointer';
        li.onclick = (function(sprintNodeId) {
          return function() {
            var sn = nodeById[sprintNodeId];
            if (sn) selectSprintNode(sn);
          };
        })('sprint-' + phase.id);
        spUl.appendChild(li);
      });
      content.appendChild(spUl);
    }
  }

--- 2026-02-21T08:38:46Z | infra/intercore/internal/phase/store.go | CONTEXT:unknown ---
OLD: 	r := &Run{}
	var (
		completedAt   sql.NullInt64
		scopeID       sql.NullString
		metadata      sql.NullString
		forceFull     int
		autoAdvance   int
		phasesJSON    sql.NullString
		tokenBudget   sql.NullInt64
		budgetWarnPct sql.NullInt64
		parentRunID   sql.NullString
		maxDispatches sql.NullInt64
	)

	err := s.db.QueryRowContext(ctx, `
		SELECT `+runCols+`
		FROM runs WHERE id = ?`, id).Scan(
		&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
		&r.Complexity, &forceFull, &autoAdvance,
		&r.CreatedAt, &r.UpdatedAt,
		&completedAt, &scopeID, &metadata,
		&phasesJSON, &tokenBudget, &budgetWarnPct,
		&parentRunID, &maxDispatches,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("run get: %w", err)
	}

	r.ForceFull = forceFull != 0
	r.AutoAdvance = autoAdvance != 0
	r.CompletedAt = nullInt64(completedAt)
	r.ScopeID = nullStr(scopeID)
	r.Metadata = nullStr(metadata)
	r.TokenBudget = nullInt64(tokenBudget)
	r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
	r.ParentRunID = nullStr(parentRunID)
	r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
	phases, err := parsePhasesJSON(phasesJSON)
	if err != nil {
		return nil, fmt.Errorf("run get: %w", err)
	}
	r.Phases = phases

	return r, nil
}
NEW: 	r := &Run{}
	var (
		completedAt    sql.NullInt64
		scopeID        sql.NullString
		metadata       sql.NullString
		forceFull      int
		autoAdvance    int
		phasesJSON     sql.NullString
		tokenBudget    sql.NullInt64
		budgetWarnPct  sql.NullInt64
		parentRunID    sql.NullString
		maxDispatches  sql.NullInt64
		budgetEnforce  sql.NullInt64
		maxAgents      sql.NullInt64
	)

	err := s.db.QueryRowContext(ctx, `
		SELECT `+runCols+`
		FROM runs WHERE id = ?`, id).Scan(
		&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
		&r.Complexity, &forceFull, &autoAdvance,
		&r.CreatedAt, &r.UpdatedAt,
		&completedAt, &scopeID, &metadata,
		&phasesJSON, &tokenBudget, &budgetWarnPct,
		&parentRunID, &maxDispatches,
		&budgetEnforce, &maxAgents,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("run get: %w", err)
	}

	r.ForceFull = forceFull != 0
	r.AutoAdvance = autoAdvance != 0
	r.CompletedAt = nullInt64(completedAt)
	r.ScopeID = nullStr(scopeID)
	r.Metadata = nullStr(metadata)
	r.TokenBudget = nullInt64(tokenBudget)
	r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
	r.ParentRunID = nullStr(parentRunID)
	r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
	r.BudgetEnforce = nullInt64OrDefault(budgetEnforce, 0) != 0
	r.MaxAgents = int(nullInt64OrDefault(maxAgents, 0))
	phases, err := parsePhasesJSON(phasesJSON)
	if err != nil {
		return nil, fmt.Errorf("run get: %w", err)
	}
	r.Phases = phases

	return r, nil
}

--- 2026-02-21T08:38:55Z | infra/intercore/internal/phase/store.go | CONTEXT:unknown ---
OLD: const runCols = `id, project_dir, goal, status, phase, complexity,
	force_full, auto_advance, created_at, updated_at,
	completed_at, scope_id, metadata, phases, token_budget, budget_warn_pct,
	parent_run_id, max_dispatches`
NEW: const runCols = `id, project_dir, goal, status, phase, complexity,
	force_full, auto_advance, created_at, updated_at,
	completed_at, scope_id, metadata, phases, token_budget, budget_warn_pct,
	parent_run_id, max_dispatches, budget_enforce, max_agents`

--- 2026-02-21T08:39:07Z | infra/intercore/internal/phase/store.go | CONTEXT:unknown ---
OLD: 		var (
			completedAt   sql.NullInt64
			scopeID       sql.NullString
			metadata      sql.NullString
			forceFull     int
			autoAdvance   int
			phasesJSON    sql.NullString
			tokenBudget   sql.NullInt64
			budgetWarnPct sql.NullInt64
			parentRunID   sql.NullString
			maxDispatches sql.NullInt64
		)
		if err := rows.Scan(
			&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
			&r.Complexity, &forceFull, &autoAdvance,
			&r.CreatedAt, &r.UpdatedAt,
			&completedAt, &scopeID, &metadata,
			&phasesJSON, &tokenBudget, &budgetWarnPct,
			&parentRunID, &maxDispatches,
		); err != nil {
			return nil, fmt.Errorf("run list scan: %w", err)
		}
		r.ForceFull = forceFull != 0
		r.AutoAdvance = autoAdvance != 0
		r.CompletedAt = nullInt64(completedAt)
		r.ScopeID = nullStr(scopeID)
		r.Metadata = nullStr(metadata)
		r.TokenBudget = nullInt64(tokenBudget)
		r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
		r.ParentRunID = nullStr(parentRunID)
		r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
NEW: 		var (
			completedAt    sql.NullInt64
			scopeID        sql.NullString
			metadata       sql.NullString
			forceFull      int
			autoAdvance    int
			phasesJSON     sql.NullString
			tokenBudget    sql.NullInt64
			budgetWarnPct  sql.NullInt64
			parentRunID    sql.NullString
			maxDispatches  sql.NullInt64
			budgetEnforce  sql.NullInt64
			maxAgents      sql.NullInt64
		)
		if err := rows.Scan(
			&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
			&r.Complexity, &forceFull, &autoAdvance,
			&r.CreatedAt, &r.UpdatedAt,
			&completedAt, &scopeID, &metadata,
			&phasesJSON, &tokenBudget, &budgetWarnPct,
			&parentRunID, &maxDispatches,
			&budgetEnforce, &maxAgents,
		); err != nil {
			return nil, fmt.Errorf("run list scan: %w", err)
		}
		r.ForceFull = forceFull != 0
		r.AutoAdvance = autoAdvance != 0
		r.CompletedAt = nullInt64(completedAt)
		r.ScopeID = nullStr(scopeID)
		r.Metadata = nullStr(metadata)
		r.TokenBudget = nullInt64(tokenBudget)
		r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
		r.ParentRunID = nullStr(parentRunID)
		r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
		r.BudgetEnforce = nullInt64OrDefault(budgetEnforce, 0) != 0
		r.MaxAgents = int(nullInt64OrDefault(maxAgents, 0))

--- 2026-02-21T08:39:20Z | infra/intercore/internal/phase/store.go | CONTEXT:unknown ---
OLD: 	_, err = tx.ExecContext(ctx, `
		INSERT INTO runs (
			id, project_dir, goal, status, phase, complexity,
			force_full, auto_advance, created_at, updated_at,
			scope_id, metadata, phases, token_budget, budget_warn_pct,
			parent_run_id, max_dispatches
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		portfolioID, "", portfolio.Goal, StatusActive, initialPhase,
		portfolio.Complexity, boolToInt(portfolio.ForceFull), boolToInt(portfolio.AutoAdvance),
		now, now, portfolio.ScopeID, portfolio.Metadata,
		phasesJSON, portfolio.TokenBudget, budgetWarnPct,
		nil, portfolio.MaxDispatches,
	)
NEW: 	_, err = tx.ExecContext(ctx, `
		INSERT INTO runs (
			id, project_dir, goal, status, phase, complexity,
			force_full, auto_advance, created_at, updated_at,
			scope_id, metadata, phases, token_budget, budget_warn_pct,
			parent_run_id, max_dispatches, budget_enforce, max_agents
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		portfolioID, "", portfolio.Goal, StatusActive, initialPhase,
		portfolio.Complexity, boolToInt(portfolio.ForceFull), boolToInt(portfolio.AutoAdvance),
		now, now, portfolio.ScopeID, portfolio.Metadata,
		phasesJSON, portfolio.TokenBudget, budgetWarnPct,
		nil, portfolio.MaxDispatches,
		boolToInt(portfolio.BudgetEnforce), portfolio.MaxAgents,
	)

--- 2026-02-21T08:39:27Z | infra/intercore/internal/phase/store.go | CONTEXT:unknown ---
OLD: 		_, err = tx.ExecContext(ctx, `
			INSERT INTO runs (
				id, project_dir, goal, status, phase, complexity,
				force_full, auto_advance, created_at, updated_at,
				scope_id, metadata, phases, token_budget, budget_warn_pct,
				parent_run_id, max_dispatches
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
			childID, child.ProjectDir, child.Goal, StatusActive, childInitPhase,
			child.Complexity, boolToInt(child.ForceFull), boolToInt(child.AutoAdvance),
			now, now, child.ScopeID, child.Metadata,
			childPhasesJSON, child.TokenBudget, childBudgetWarnPct,
			portfolioID, 0,
		)
NEW: 		_, err = tx.ExecContext(ctx, `
			INSERT INTO runs (
				id, project_dir, goal, status, phase, complexity,
				force_full, auto_advance, created_at, updated_at,
				scope_id, metadata, phases, token_budget, budget_warn_pct,
				parent_run_id, max_dispatches, budget_enforce, max_agents
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
			childID, child.ProjectDir, child.Goal, StatusActive, childInitPhase,
			child.Complexity, boolToInt(child.ForceFull), boolToInt(child.AutoAdvance),
			now, now, child.ScopeID, child.Metadata,
			childPhasesJSON, child.TokenBudget, childBudgetWarnPct,
			portfolioID, 0,
			boolToInt(child.BudgetEnforce), child.MaxAgents,
		)

--- 2026-02-21T08:39:48Z | infra/intercore/internal/phase/tx_queriers.go | CONTEXT:unknown ---
OLD: func scanRuns(rows *sql.Rows) ([]*Run, error) {
	var runs []*Run
	for rows.Next() {
		r := &Run{}
		var (
			completedAt   sql.NullInt64
			scopeID       sql.NullString
			metadata      sql.NullString
			forceFull     int
			autoAdvance   int
			phasesJSON    sql.NullString
			tokenBudget   sql.NullInt64
			budgetWarnPct sql.NullInt64
			parentRunID   sql.NullString
			maxDispatches sql.NullInt64
		)
		if err := rows.Scan(
			&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
			&r.Complexity, &forceFull, &autoAdvance,
			&r.CreatedAt, &r.UpdatedAt,
			&completedAt, &scopeID, &metadata,
			&phasesJSON, &tokenBudget, &budgetWarnPct,
			&parentRunID, &maxDispatches,
		); err != nil {
			return nil, fmt.Errorf("scan run: %w", err)
		}
		r.ForceFull = forceFull != 0
		r.AutoAdvance = autoAdvance != 0
		r.CompletedAt = nullInt64(completedAt)
		r.ScopeID = nullStr(scopeID)
		r.Metadata = nullStr(metadata)
		r.TokenBudget = nullInt64(tokenBudget)
		r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
		r.ParentRunID = nullStr(parentRunID)
		r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
		phases, err := parsePhasesJSON(phasesJSON)
		if err != nil {
			return nil, err
		}
		r.Phases = phases
		runs = append(runs, r)
	}
	return runs, rows.Err()
}
NEW: func scanRuns(rows *sql.Rows) ([]*Run, error) {
	var runs []*Run
	for rows.Next() {
		r := &Run{}
		var (
			completedAt    sql.NullInt64
			scopeID        sql.NullString
			metadata       sql.NullString
			forceFull      int
			autoAdvance    int
			phasesJSON     sql.NullString
			tokenBudget    sql.NullInt64
			budgetWarnPct  sql.NullInt64
			parentRunID    sql.NullString
			maxDispatches  sql.NullInt64
			budgetEnforce  sql.NullInt64
			maxAgents      sql.NullInt64
		)
		if err := rows.Scan(
			&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
			&r.Complexity, &forceFull, &autoAdvance,
			&r.CreatedAt, &r.UpdatedAt,
			&completedAt, &scopeID, &metadata,
			&phasesJSON, &tokenBudget, &budgetWarnPct,
			&parentRunID, &maxDispatches,
			&budgetEnforce, &maxAgents,
		); err != nil {
			return nil, fmt.Errorf("scan run: %w", err)
		}
		r.ForceFull = forceFull != 0
		r.AutoAdvance = autoAdvance != 0
		r.CompletedAt = nullInt64(completedAt)
		r.ScopeID = nullStr(scopeID)
		r.Metadata = nullStr(metadata)
		r.TokenBudget = nullInt64(tokenBudget)
		r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
		r.ParentRunID = nullStr(parentRunID)
		r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
		r.BudgetEnforce = nullInt64OrDefault(budgetEnforce, 0) != 0
		r.MaxAgents = int(nullInt64OrDefault(maxAgents, 0))
		phases, err := parsePhasesJSON(phasesJSON)
		if err != nil {
			return nil, err
		}
		r.Phases = phases
		runs = append(runs, r)
	}
	return runs, rows.Err()
}

--- 2026-02-21T08:40:03Z | infra/intercore/internal/phase/tx_queriers.go | CONTEXT:unknown ---
OLD: func (s *Store) GetQ(ctx context.Context, q Querier, id string) (*Run, error) {
	r := &Run{}
	var (
		completedAt   sql.NullInt64
		scopeID       sql.NullString
		metadata      sql.NullString
		forceFull     int
		autoAdvance   int
		phasesJSON    sql.NullString
		tokenBudget   sql.NullInt64
		budgetWarnPct sql.NullInt64
		parentRunID   sql.NullString
		maxDispatches sql.NullInt64
	)

	err := q.QueryRowContext(ctx, `
		SELECT `+runCols+`
		FROM runs WHERE id = ?`, id).Scan(
		&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
		&r.Complexity, &forceFull, &autoAdvance,
		&r.CreatedAt, &r.UpdatedAt,
		&completedAt, &scopeID, &metadata,
		&phasesJSON, &tokenBudget, &budgetWarnPct,
		&parentRunID, &maxDispatches,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("run get: %w", err)
	}

	r.ForceFull = forceFull != 0
	r.AutoAdvance = autoAdvance != 0
	r.CompletedAt = nullInt64(completedAt)
	r.ScopeID = nullStr(scopeID)
	r.Metadata = nullStr(metadata)
	r.TokenBudget = nullInt64(tokenBudget)
	r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
	r.ParentRunID = nullStr(parentRunID)
	r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
	phases, err := parsePhasesJSON(phasesJSON)
	if err != nil {
		return nil, fmt.Errorf("run get: %w", err)
	}
	r.Phases = phases

	return r, nil
}
NEW: func (s *Store) GetQ(ctx context.Context, q Querier, id string) (*Run, error) {
	r := &Run{}
	var (
		completedAt    sql.NullInt64
		scopeID        sql.NullString
		metadata       sql.NullString
		forceFull      int
		autoAdvance    int
		phasesJSON     sql.NullString
		tokenBudget    sql.NullInt64
		budgetWarnPct  sql.NullInt64
		parentRunID    sql.NullString
		maxDispatches  sql.NullInt64
		budgetEnforce  sql.NullInt64
		maxAgents      sql.NullInt64
	)

	err := q.QueryRowContext(ctx, `
		SELECT `+runCols+`
		FROM runs WHERE id = ?`, id).Scan(
		&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
		&r.Complexity, &forceFull, &autoAdvance,
		&r.CreatedAt, &r.UpdatedAt,
		&completedAt, &scopeID, &metadata,
		&phasesJSON, &tokenBudget, &budgetWarnPct,
		&parentRunID, &maxDispatches,
		&budgetEnforce, &maxAgents,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("run get: %w", err)
	}

	r.ForceFull = forceFull != 0
	r.AutoAdvance = autoAdvance != 0
	r.CompletedAt = nullInt64(completedAt)
	r.ScopeID = nullStr(scopeID)
	r.Metadata = nullStr(metadata)
	r.TokenBudget = nullInt64(tokenBudget)
	r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
	r.ParentRunID = nullStr(parentRunID)
	r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
	r.BudgetEnforce = nullInt64OrDefault(budgetEnforce, 0) != 0
	r.MaxAgents = int(nullInt64OrDefault(maxAgents, 0))
	phases, err := parsePhasesJSON(phasesJSON)
	if err != nil {
		return nil, fmt.Errorf("run get: %w", err)
	}
	r.Phases = phases

	return r, nil
}

--- 2026-02-21T08:40:25Z | infra/intercore/internal/phase/store.go | CONTEXT:unknown ---
OLD: 	r := &Run{}
	var (
		completedAt   sql.NullInt64
		scopeID       sql.NullString
		metadata      sql.NullString
		forceFull     int
		autoAdvance   int
		phasesJSON    sql.NullString
		tokenBudget   sql.NullInt64
		budgetWarnPct sql.NullInt64
		parentRunID   sql.NullString
		maxDispatches sql.NullInt64
	)

	err := s.db.QueryRowContext(ctx, `
		SELECT `+runCols+` FROM runs
		WHERE status = 'active' AND project_dir = ?
		ORDER BY created_at DESC, rowid DESC LIMIT 1`, projectDir).Scan(
		&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
		&r.Complexity, &forceFull, &autoAdvance,
		&r.CreatedAt, &r.UpdatedAt,
		&completedAt, &scopeID, &metadata,
		&phasesJSON, &tokenBudget, &budgetWarnPct,
		&parentRunID, &maxDispatches,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("run current: %w", err)
	}

	r.ForceFull = forceFull != 0
	r.AutoAdvance = autoAdvance != 0
	r.CompletedAt = nullInt64(completedAt)
	r.ScopeID = nullStr(scopeID)
	r.Metadata = nullStr(metadata)
	r.TokenBudget = nullInt64(tokenBudget)
	r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
	r.ParentRunID = nullStr(parentRunID)
	r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
NEW: 	r := &Run{}
	var (
		completedAt    sql.NullInt64
		scopeID        sql.NullString
		metadata       sql.NullString
		forceFull      int
		autoAdvance    int
		phasesJSON     sql.NullString
		tokenBudget    sql.NullInt64
		budgetWarnPct  sql.NullInt64
		parentRunID    sql.NullString
		maxDispatches  sql.NullInt64
		budgetEnforce  sql.NullInt64
		maxAgents      sql.NullInt64
	)

	err := s.db.QueryRowContext(ctx, `
		SELECT `+runCols+` FROM runs
		WHERE status = 'active' AND project_dir = ?
		ORDER BY created_at DESC, rowid DESC LIMIT 1`, projectDir).Scan(
		&r.ID, &r.ProjectDir, &r.Goal, &r.Status, &r.Phase,
		&r.Complexity, &forceFull, &autoAdvance,
		&r.CreatedAt, &r.UpdatedAt,
		&completedAt, &scopeID, &metadata,
		&phasesJSON, &tokenBudget, &budgetWarnPct,
		&parentRunID, &maxDispatches,
		&budgetEnforce, &maxAgents,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("run current: %w", err)
	}

	r.ForceFull = forceFull != 0
	r.AutoAdvance = autoAdvance != 0
	r.CompletedAt = nullInt64(completedAt)
	r.ScopeID = nullStr(scopeID)
	r.Metadata = nullStr(metadata)
	r.TokenBudget = nullInt64(tokenBudget)
	r.BudgetWarnPct = int(nullInt64OrDefault(budgetWarnPct, 80))
	r.ParentRunID = nullStr(parentRunID)
	r.MaxDispatches = int(nullInt64OrDefault(maxDispatches, 0))
	r.BudgetEnforce = nullInt64OrDefault(budgetEnforce, 0) != 0
	r.MaxAgents = int(nullInt64OrDefault(maxAgents, 0))

--- 2026-02-21T08:40:38Z | infra/intercore/internal/dispatch/dispatch.go | CONTEXT:unknown ---
OLD: // List returns dispatches with optional scope filter.
func (s *Store) List(ctx context.Context, scopeID *string) ([]*Dispatch, error) {
NEW: // CountActiveByScope returns the number of active (non-terminal) dispatches for a scope.
func (s *Store) CountActiveByScope(ctx context.Context, scopeID string) (int, error) {
	var count int
	err := s.db.QueryRowContext(ctx,
		`SELECT COUNT(*) FROM dispatches WHERE scope_id = ? AND status IN ('spawned', 'running')`,
		scopeID).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("dispatch count active by scope: %w", err)
	}
	return count, nil
}

// CountActiveGlobal returns the total number of active (non-terminal) dispatches.
func (s *Store) CountActiveGlobal(ctx context.Context) (int, error) {
	var count int
	err := s.db.QueryRowContext(ctx,
		`SELECT COUNT(*) FROM dispatches WHERE status IN ('spawned', 'running')`).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("dispatch count active global: %w", err)
	}
	return count, nil
}

// CountTotalByScope returns the total number of dispatches ever created for a scope.
func (s *Store) CountTotalByScope(ctx context.Context, scopeID string) (int, error) {
	var count int
	err := s.db.QueryRowContext(ctx,
		`SELECT COUNT(*) FROM dispatches WHERE scope_id = ?`,
		scopeID).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("dispatch count total by scope: %w", err)
	}
	return count, nil
}

// List returns dispatches with optional scope filter.
func (s *Store) List(ctx context.Context, scopeID *string) ([]*Dispatch, error) {

--- 2026-02-21T08:41:18Z | infra/intercore/internal/dispatch/spawn.go | CONTEXT:unknown ---
OLD: // SpawnOptions configures a dispatch spawn.
type SpawnOptions struct {
	AgentType  string // "codex" (default)
	ProjectDir string // required: working directory for the agent
	PromptFile string // required: path to prompt file
	OutputFile string // optional: path for agent output
	Name       string // optional: human label
	Model      string // optional: codex model
	Sandbox    string // optional: sandbox mode (default: "workspace-write")
	TimeoutSec int    // optional: agent timeout in seconds
	ScopeID    string // optional: grouping scope
	ParentID   string // optional: parent dispatch ID
	DispatchSH string // optional: explicit path to dispatch.sh
}
NEW: // SpawnOptions configures a dispatch spawn.
type SpawnOptions struct {
	AgentType        string // "codex" (default)
	ProjectDir       string // required: working directory for the agent
	PromptFile       string // required: path to prompt file
	OutputFile       string // optional: path for agent output
	Name             string // optional: human label
	Model            string // optional: codex model
	Sandbox          string // optional: sandbox mode (default: "workspace-write")
	TimeoutSec       int    // optional: agent timeout in seconds
	ScopeID          string // optional: grouping scope
	ParentID         string // optional: parent dispatch ID
	DispatchSH       string // optional: explicit path to dispatch.sh
	ParentDispatchID string // optional: parent dispatch for spawn depth tracking
	Policy           *SpawnPolicy   // optional: spawn policy to enforce
	BudgetQuerier    BudgetQuerier  // optional: budget checker (required if Policy.BudgetEnforce)
}

--- 2026-02-21T08:41:26Z | infra/intercore/internal/dispatch/spawn.go | CONTEXT:unknown ---
OLD: 	if opts.ParentID != "" {
		d.ParentID = &opts.ParentID
	}
	if baseCommit != "" {
		d.BaseRepoCommit = &baseCommit
	}

	id, err := store.Create(ctx, d)
NEW: 	if opts.ParentID != "" {
		d.ParentID = &opts.ParentID
	}
	if baseCommit != "" {
		d.BaseRepoCommit = &baseCommit
	}

	// Compute spawn depth from parent dispatch
	if opts.ParentDispatchID != "" {
		d.ParentDispatchID = opts.ParentDispatchID
		parent, err := store.Get(ctx, opts.ParentDispatchID)
		if err == nil {
			d.SpawnDepth = parent.SpawnDepth + 1
		}
		// If parent not found, depth stays 0 (best-effort)
	}

	// Check spawn policy before creating the record
	if opts.Policy != nil {
		if err := CheckPolicy(ctx, store, opts.BudgetQuerier, *opts.Policy, d); err != nil {
			return nil, err
		}
	}

	id, err := store.Create(ctx, d)

--- 2026-02-21T08:41:49Z | infra/intercore/cmd/ic/dispatch.go | CONTEXT:unknown ---
OLD: 		case strings.HasPrefix(args[i], "--dispatch-sh="):
			opts.DispatchSH = strings.TrimPrefix(args[i], "--dispatch-sh=")
		default:
NEW: 		case strings.HasPrefix(args[i], "--dispatch-sh="):
			opts.DispatchSH = strings.TrimPrefix(args[i], "--dispatch-sh=")
		case strings.HasPrefix(args[i], "--parent-dispatch="):
			opts.ParentDispatchID = strings.TrimPrefix(args[i], "--parent-dispatch=")
		default:

--- 2026-02-21T08:42:04Z | infra/intercore/cmd/ic/dispatch.go | CONTEXT:unknown ---
OLD: 	// Portfolio dispatch limit check (best-effort, relay-maintained cache).
	// Note: this is advisory, not atomic — concurrent spawns may exceed the limit.
	if opts.ScopeID != "" {
		if limited, msg := checkPortfolioDispatchLimit(ctx, d.SqlDB(), opts.ScopeID); limited {
			fmt.Fprintf(os.Stderr, "ic: dispatch spawn: %s\n", msg)
			return 1
		}
	}

	store := dispatch.New(d.SqlDB(), nil)
	result, err := dispatch.Spawn(ctx, store, opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: dispatch spawn: %v\n", err)
		return 2
	}
NEW: 	// Portfolio dispatch limit check (best-effort, relay-maintained cache).
	// Note: this is advisory, not atomic — concurrent spawns may exceed the limit.
	if opts.ScopeID != "" {
		if limited, msg := checkPortfolioDispatchLimit(ctx, d.SqlDB(), opts.ScopeID); limited {
			fmt.Fprintf(os.Stderr, "ic: dispatch spawn: %s\n", msg)
			return 1
		}
	}

	// Build spawn policy from run config + global state
	if opts.ScopeID != "" {
		pStore := phase.New(d.SqlDB())
		sStore := state.New(d.SqlDB())
		run, err := pStore.Get(ctx, opts.ScopeID)
		if err == nil {
			policy := dispatch.SpawnPolicy{
				BudgetEnforce:   run.BudgetEnforce,
				MaxActivePerRun: run.MaxDispatches,
				MaxAgentsPerRun: run.MaxAgents,
			}
			// Read global limits from state
			if payload, err := sStore.Get(ctx, "_kernel/global_max_dispatches", "global"); err == nil {
				var v int
				if json.Unmarshal(payload, &v) == nil && v > 0 {
					policy.MaxActiveGlobal = v
				}
			}
			if payload, err := sStore.Get(ctx, "_kernel/max_spawn_depth", "global"); err == nil {
				var v int
				if json.Unmarshal(payload, &v) == nil && v > 0 {
					policy.MaxSpawnDepth = v
				}
			}
			opts.Policy = &policy
			if run.BudgetEnforce {
				dStore := dispatch.New(d.SqlDB(), nil)
				checker := budget.New(pStore, dStore, sStore, nil)
				opts.BudgetQuerier = &cliBudgetQuerier{checker: checker}
			}
		}
	}

	store := dispatch.New(d.SqlDB(), nil)
	result, err := dispatch.Spawn(ctx, store, opts)
	if err != nil {
		if dispatch.IsSpawnRejection(err) {
			fmt.Fprintf(os.Stderr, "ic: dispatch spawn: %v\n", err)
			return 1
		}
		fmt.Fprintf(os.Stderr, "ic: dispatch spawn: %v\n", err)
		return 2
	}

--- 2026-02-21T08:42:24Z | infra/intercore/cmd/ic/dispatch.go | CONTEXT:unknown ---
OLD: 	if count >= parent.MaxDispatches {
		return true, fmt.Sprintf("portfolio dispatch limit reached (%d/%d)", count, parent.MaxDispatches)
	}
	return false, ""
}
NEW: 	if count >= parent.MaxDispatches {
		return true, fmt.Sprintf("portfolio dispatch limit reached (%d/%d)", count, parent.MaxDispatches)
	}
	return false, ""
}

// cliBudgetQuerier adapts budget.Checker to the dispatch.BudgetQuerier interface.
type cliBudgetQuerier struct {
	checker *budget.Checker
}

func (q *cliBudgetQuerier) IsBudgetExceeded(ctx context.Context, runID string) (bool, error) {
	result, err := q.checker.Check(ctx, runID)
	if err != nil {
		return false, err
	}
	if result == nil {
		return false, nil // no budget set
	}
	return result.Exceeded, nil
}

--- 2026-02-21T08:42:41Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	var project, goal, scopeID, phasesJSON, projects string
	complexity := 3
	var tokenBudget int64
	var maxDispatches int
	budgetWarnPct := 80
NEW: 	var project, goal, scopeID, phasesJSON, projects string
	complexity := 3
	var tokenBudget int64
	var maxDispatches, maxAgents int
	var budgetEnforce bool
	budgetWarnPct := 80

--- 2026-02-21T08:42:47Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 		case strings.HasPrefix(args[i], "--max-dispatches="):
			val := strings.TrimPrefix(args[i], "--max-dispatches=")
			v, err := strconv.Atoi(val)
			if err != nil || v < 0 {
				fmt.Fprintf(os.Stderr, "ic: run create: invalid max-dispatches (non-negative integer): %s\n", val)
				return 3
			}
			maxDispatches = v
		default:
NEW: 		case strings.HasPrefix(args[i], "--max-dispatches="):
			val := strings.TrimPrefix(args[i], "--max-dispatches=")
			v, err := strconv.Atoi(val)
			if err != nil || v < 0 {
				fmt.Fprintf(os.Stderr, "ic: run create: invalid max-dispatches (non-negative integer): %s\n", val)
				return 3
			}
			maxDispatches = v
		case args[i] == "--budget-enforce":
			budgetEnforce = true
		case strings.HasPrefix(args[i], "--max-agents="):
			val := strings.TrimPrefix(args[i], "--max-agents=")
			v, err := strconv.Atoi(val)
			if err != nil || v < 0 {
				fmt.Fprintf(os.Stderr, "ic: run create: invalid max-agents (non-negative integer): %s\n", val)
				return 3
			}
			maxAgents = v
		default:

--- 2026-02-21T08:43:01Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 		portfolio := &phase.Run{
			Goal:          goal,
			Complexity:    complexity,
			AutoAdvance:   true,
			BudgetWarnPct: budgetWarnPct,
			Phases:        customPhases,
			MaxDispatches: maxDispatches,
		}
NEW: 		portfolio := &phase.Run{
			Goal:          goal,
			Complexity:    complexity,
			AutoAdvance:   true,
			BudgetWarnPct: budgetWarnPct,
			Phases:        customPhases,
			MaxDispatches: maxDispatches,
			BudgetEnforce: budgetEnforce,
			MaxAgents:     maxAgents,
		}

--- 2026-02-21T08:43:13Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	run := &phase.Run{
		ProjectDir:    project,
		Goal:          goal,
		Complexity:    complexity,
		AutoAdvance:   true,
		BudgetWarnPct: budgetWarnPct,
		Phases:        customPhases,
	}
NEW: 	run := &phase.Run{
		ProjectDir:    project,
		Goal:          goal,
		Complexity:    complexity,
		AutoAdvance:   true,
		BudgetWarnPct: budgetWarnPct,
		Phases:        customPhases,
		BudgetEnforce: budgetEnforce,
		MaxAgents:     maxAgents,
	}

--- 2026-02-21T08:43:57Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 	CheckArtifactExists    = "artifact_exists"
	CheckAgentsComplete    = "agents_complete"
	CheckVerdictExists     = "verdict_exists"
	CheckChildrenAtPhase   = "children_at_phase"
	CheckUpstreamsAtPhase  = "upstreams_at_phase"
NEW: 	CheckArtifactExists      = "artifact_exists"
	CheckAgentsComplete      = "agents_complete"
	CheckVerdictExists       = "verdict_exists"
	CheckChildrenAtPhase     = "children_at_phase"
	CheckUpstreamsAtPhase    = "upstreams_at_phase"
	CheckBudgetNotExceeded   = "budget_not_exceeded"

--- 2026-02-21T08:44:09Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: // DepQuerier abstracts dependency graph queries for gate evaluation.
// Implemented by portfolio.DepStore; tests can use stubs.
type DepQuerier interface {
	GetUpstream(ctx context.Context, portfolioRunID, downstream string) ([]string, error)
}
NEW: // DepQuerier abstracts dependency graph queries for gate evaluation.
// Implemented by portfolio.DepStore; tests can use stubs.
type DepQuerier interface {
	GetUpstream(ctx context.Context, portfolioRunID, downstream string) ([]string, error)
}

// BudgetQuerier abstracts budget checking for gate evaluation.
// Implemented by budget.Checker via an adapter; tests can use stubs.
type BudgetQuerier interface {
	IsBudgetExceeded(ctx context.Context, runID string) (bool, error)
}

--- 2026-02-21T08:44:16Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: func evaluateGate(ctx context.Context, run *Run, cfg GateConfig, from, to string, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier) (result, tier string, evidence *GateEvidence, err error) {
NEW: func evaluateGate(ctx context.Context, run *Run, cfg GateConfig, from, to string, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier, bq BudgetQuerier) (result, tier string, evidence *GateEvidence, err error) {

--- 2026-02-21T08:44:22Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 	// Child runs with a parent: inject upstreams_at_phase check for every transition
	if run.ParentRunID != nil && *run.ParentRunID != "" {
		rules = append(rules, gateRule{check: CheckUpstreamsAtPhase, phase: to})
	}
NEW: 	// Child runs with a parent: inject upstreams_at_phase check for every transition
	if run.ParentRunID != nil && *run.ParentRunID != "" {
		rules = append(rules, gateRule{check: CheckUpstreamsAtPhase, phase: to})
	}

	// Budget enforcement: inject budget check for runs with budget_enforce=true
	if run.BudgetEnforce {
		rules = append(rules, gateRule{check: CheckBudgetNotExceeded})
	}

--- 2026-02-21T08:44:29Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 		default:
			cond.Result = GateFail
			cond.Detail = fmt.Sprintf("unknown check type: %q", rule.check)
			allPass = false
NEW: 		case CheckBudgetNotExceeded:
			if bq == nil {
				cond.Result = GatePass
				cond.Detail = "no budget querier provided, skipping"
				break
			}
			exceeded, qerr := bq.IsBudgetExceeded(ctx, run.ID)
			if qerr != nil {
				return "", "", nil, fmt.Errorf("gate check: budget: %w", qerr)
			}
			if !exceeded {
				cond.Result = GatePass
			} else {
				cond.Result = GateFail
				cond.Detail = "token budget exceeded"
				allPass = false
			}

		default:
			cond.Result = GateFail
			cond.Detail = fmt.Sprintf("unknown check type: %q", rule.check)
			allPass = false

--- 2026-02-21T08:44:35Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: func EvaluateGate(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier) (*GateCheckResult, error) {
NEW: func EvaluateGate(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier, bq BudgetQuerier) (*GateCheckResult, error) {

--- 2026-02-21T08:44:52Z | infra/intercore/internal/phase/gate.go | CONTEXT:unknown ---
OLD: 	result, tier, evidence, err := evaluateGate(ctx, run, cfg, run.Phase, toPhase, rt, vq, pq, dq)
NEW: 	result, tier, evidence, err := evaluateGate(ctx, run, cfg, run.Phase, toPhase, rt, vq, pq, dq, bq)

--- 2026-02-21T08:45:11Z | infra/intercore/internal/phase/machine.go | CONTEXT:unknown ---
OLD: func Advance(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier, callback PhaseEventCallback) (*AdvanceResult, error) {
NEW: func Advance(ctx context.Context, store *Store, runID string, cfg GateConfig, rt RuntrackQuerier, vq VerdictQuerier, pq PortfolioQuerier, dq DepQuerier, bq BudgetQuerier, callback PhaseEventCallback) (*AdvanceResult, error) {

--- 2026-02-21T08:45:18Z | infra/intercore/internal/phase/machine.go | CONTEXT:unknown ---
OLD: 	gateResult, gateTier, evidence, gateErr := evaluateGate(ctx, run, cfg, fromPhase, toPhase, txRT, txVQ, txPQ, txDQ)
NEW: 	gateResult, gateTier, evidence, gateErr := evaluateGate(ctx, run, cfg, fromPhase, toPhase, txRT, txVQ, txPQ, txDQ, bq)

--- 2026-02-21T08:45:36Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	result, err := phase.Advance(ctx, store, id, phase.GateConfig{
		Priority:   priority,
		DisableAll: disableGates,
		SkipReason: skipReason,
	}, rtStore, dStore, store, dq, phaseCallback)
NEW: 	// Budget gate querier: only needed if run has budget enforcement
	var bq phase.BudgetQuerier
	if run.BudgetEnforce {
		sStore := state.New(d.SqlDB())
		checker := budget.New(store, dStore, sStore, nil)
		bq = &cliBudgetQuerier{checker: checker}
	}

	result, err := phase.Advance(ctx, store, id, phase.GateConfig{
		Priority:   priority,
		DisableAll: disableGates,
		SkipReason: skipReason,
	}, rtStore, dStore, store, dq, bq, phaseCallback)

--- 2026-02-21T08:45:50Z | infra/intercore/cmd/ic/gate.go | CONTEXT:unknown ---
OLD: 	result, err := phase.EvaluateGate(ctx, store, runID, phase.GateConfig{
		Priority: priority,
	}, rtStore, dStore, store, depStore)
NEW: 	// Budget querier: check if run has budget enforcement
	var bq phase.BudgetQuerier
	run, runErr := store.Get(ctx, runID)
	if runErr == nil && run.BudgetEnforce {
		sStore := state.New(d.SqlDB())
		checker := budget.New(store, dStore, sStore, nil)
		bq = &cliBudgetQuerier{checker: checker}
	}

	result, err := phase.EvaluateGate(ctx, store, runID, phase.GateConfig{
		Priority: priority,
	}, rtStore, dStore, store, depStore, bq)

--- 2026-02-21T08:46:03Z | infra/intercore/cmd/ic/gate.go | CONTEXT:unknown ---
OLD: 	"github.com/mistakeknot/interverse/infra/intercore/internal/dispatch"
	"github.com/mistakeknot/interverse/infra/intercore/internal/phase"
	"github.com/mistakeknot/interverse/infra/intercore/internal/portfolio"
	"github.com/mistakeknot/interverse/infra/intercore/internal/runtrack"
NEW: 	"github.com/mistakeknot/interverse/infra/intercore/internal/budget"
	"github.com/mistakeknot/interverse/infra/intercore/internal/dispatch"
	"github.com/mistakeknot/interverse/infra/intercore/internal/phase"
	"github.com/mistakeknot/interverse/infra/intercore/internal/portfolio"
	"github.com/mistakeknot/interverse/infra/intercore/internal/runtrack"
	"github.com/mistakeknot/interverse/infra/intercore/internal/state"

--- 2026-02-21T08:46:41Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: want 11
NEW: want 12

--- 2026-02-21T08:46:50Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: v != 11
NEW: v != 12

--- 2026-02-21T08:46:56Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: expected schema version 11
NEW: expected schema version 12

--- 2026-02-21T08:47:16Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: rtStore, nil, nil, nil, nil)
NEW: rtStore, nil, nil, nil, nil, nil)

--- 2026-02-21T08:47:20Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: rtStore, dStore, nil, nil, nil)
NEW: rtStore, dStore, nil, nil, nil, nil)

--- 2026-02-21T08:47:24Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: nil, nil, nil, nil, nil)
NEW: nil, nil, nil, nil, nil, nil)

--- 2026-02-21T08:47:50Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: nil, nil, nil, nil, nil)
NEW: nil, nil, nil, nil, nil, nil)

--- 2026-02-21T08:49:56Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: 		result, err := Advance(context.Background(), store, runID, cfg, rt, nil, nil, nil, nil)
NEW: 		result, err := Advance(context.Background(), store, runID, cfg, rt, nil, nil, nil, nil, nil)

--- 2026-02-21T08:49:59Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: 	r2, _ := Advance(ctx, store, id2, GateConfig{Priority: 2}, rtStore, nil, nil, nil, nil)
NEW: 	r2, _ := Advance(ctx, store, id2, GateConfig{Priority: 2}, rtStore, nil, nil, nil, nil, nil)

--- 2026-02-21T08:50:02Z | infra/intercore/internal/phase/machine_test.go | CONTEXT:unknown ---
OLD: 	r3, _ := Advance(ctx, store, id3, GateConfig{Priority: 0}, rtStore, nil, nil, nil, nil)
NEW: 	r3, _ := Advance(ctx, store, id3, GateConfig{Priority: 0}, rtStore, nil, nil, nil, nil, nil)

--- 2026-02-21T08:50:20Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: rtStore, nil, nil, nil, nil, nil, nil)
NEW: rtStore, nil, nil, nil, nil, nil)

--- 2026-02-21T08:50:23Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: nil, nil, nil, nil, nil, nil)
NEW: nil, nil, nil, nil, nil)

--- 2026-02-21T08:50:34Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: result, err := Advance(ctx, store, id, GateConfig{Priority: 0, DisableAll: true}, nil, nil, nil, nil, nil)
NEW: result, err := Advance(ctx, store, id, GateConfig{Priority: 0, DisableAll: true}, nil, nil, nil, nil, nil, nil)

--- 2026-02-21T08:51:00Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: EvaluateGate(ctx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil)
NEW: EvaluateGate(ctx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil, nil)

--- 2026-02-21T08:51:03Z | infra/intercore/internal/phase/gate_test.go | CONTEXT:unknown ---
OLD: EvaluateGate(cancelCtx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil)
NEW: EvaluateGate(cancelCtx, store, id, GateConfig{Priority: 0}, rtStore, nil, nil, nil, nil)

--- 2026-02-21T08:52:34Z | infra/intercore/cmd/ic/main.go | CONTEXT:unknown ---
OLD: 	case "portfolio":
		exitCode = cmdPortfolio(ctx, subArgs)
	case "compat":
NEW: 	case "portfolio":
		exitCode = cmdPortfolio(ctx, subArgs)
	case "config":
		exitCode = cmdConfig(ctx, subArgs)
	case "compat":

--- 2026-02-21T08:52:39Z | infra/intercore/cmd/ic/main.go | CONTEXT:unknown ---
OLD:   portfolio relay <id> [--interval=2s]  Run event relay for portfolio
  compat status                 Show migration status
NEW:   portfolio relay <id> [--interval=2s]  Run event relay for portfolio
  config set <key> <value>      Set a kernel config value
  config get <key>              Get a kernel config value
  config list [--verbose]       List kernel config values
  compat status                 Show migration status

--- 2026-02-21T08:52:49Z | infra/intercore/cmd/ic/config.go | CONTEXT:unknown ---
OLD: const kernelScope = "_kernel"
NEW: const kernelScope = "global"

--- 2026-02-21T08:53:02Z | plugins/interchart/AGENTS.md | CONTEXT:unknown ---
OLD: ## Deployment

### Server-side cron (primary)

```bash
# Installed in crontab:
*/5 * * * * /root/projects/Interverse/plugins/interchart/scripts/watch-and-deploy.sh
```

**How it works:**
1. `watch-and-deploy.sh` hashes all repo HEAD SHAs into a fingerprint
2. Compares with `.last-scan-state`
3. If changed → calls `regenerate-and-deploy.sh`
4. `regenerate-and-deploy.sh` generates HTML, compares node count with existing file, deploys to `gh-pages` branch if different

### Manual deploy

```bash
# Generate + deploy
bash scripts/regenerate-and-deploy.sh /root/projects/Interverse

# Generate only (no deploy)
bash scripts/generate.sh /root/projects/Interverse
```
NEW: ## Deployment

### Agent-driven (primary)

Agents regenerate the diagram as a final step after any change that adds, removes, or renames plugins, skills, agents, MCP servers, or hooks. This is documented in the Interverse root `AGENTS.md` under "Ecosystem Diagram (interchart)".

```bash
# Generate + deploy to gh-pages (safe — uses git worktree, never touches main)
bash scripts/regenerate-and-deploy.sh /root/projects/Interverse

# Generate only (no deploy)
bash scripts/generate.sh /root/projects/Interverse
```

--- 2026-02-21T08:53:07Z | plugins/interchart/AGENTS.md | CONTEXT:unknown ---
OLD: - **`regenerate-and-deploy.sh` switches branches**: It checks out `gh-pages`, copies the file, commits, pushes, then checks out `main`. If you have uncommitted changes on `main`, stash them first.
NEW: - **`regenerate-and-deploy.sh` uses a worktree**: It creates a temporary git worktree for `gh-pages`, copies the file, commits, pushes, and cleans up — it never touches the `main` working tree.

--- 2026-02-21T08:53:31Z | infra/intercore/cmd/ic/dispatch.go | CONTEXT:unknown ---
OLD: 			// Read global limits from state
			if payload, err := sStore.Get(ctx, "_kernel/global_max_dispatches", "global"); err == nil {
				var v int
				if json.Unmarshal(payload, &v) == nil && v > 0 {
					policy.MaxActiveGlobal = v
				}
			}
			if payload, err := sStore.Get(ctx, "_kernel/max_spawn_depth", "global"); err == nil {
				var v int
				if json.Unmarshal(payload, &v) == nil && v > 0 {
					policy.MaxSpawnDepth = v
				}
			}
NEW: 			// Read global limits from config
			policy.MaxActiveGlobal = readConfigInt(ctx, sStore, "global_max_dispatches")
			policy.MaxSpawnDepth = readConfigInt(ctx, sStore, "max_spawn_depth")

--- 2026-02-21T08:53:34Z | infra/intercore/cmd/ic/config.go | CONTEXT:unknown ---
OLD: "_kernel/" + key
NEW: "_kernel." + key

--- 2026-02-21T08:53:50Z | infra/intercore/cmd/ic/config.go | CONTEXT:unknown ---
OLD: 	// Store as JSON number
	stateKey := "_kernel." + key
	if err := state.ValidateKey(stateKey); err != nil {
		fmt.Fprintf(os.Stderr, "ic: config set: invalid key: %v\n", err)
		return 3
	}

	d, err := openDB()
NEW: 	// Kernel config keys bypass state.ValidateKey (underscore prefix is internal-only)
	stateKey := "_kernel." + key

	d, err := openDB()

--- 2026-02-21T08:54:21Z | infra/intercore/cmd/ic/config.go | CONTEXT:unknown ---
OLD: "_kernel." + key
NEW: "kernel." + key

--- 2026-02-21T08:54:25Z | infra/intercore/cmd/ic/config.go | CONTEXT:unknown ---
OLD: 	// Kernel config keys bypass state.ValidateKey (underscore prefix is internal-only)
NEW: 	// Store under kernel.* namespace in state table

--- 2026-02-21T08:55:16Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: # --- Version sync check ---
NEW: # --- Cost-Aware Scheduling (iv-suzr) ---
echo ""
echo "=== Cost-Aware Scheduling ==="

# Config set/get
ic config set global_max_dispatches 5 --db="$TEST_DB" >/dev/null
cfg_val=$(ic config get global_max_dispatches --db="$TEST_DB")
echo "$cfg_val" | grep -q "5" || fail "config set/get: expected 5, got: $cfg_val"
pass "config: set/get global_max_dispatches"

ic config set max_spawn_depth 3 --db="$TEST_DB" >/dev/null
cfg_val2=$(ic config get max_spawn_depth --db="$TEST_DB")
echo "$cfg_val2" | grep -q "3" || fail "config set/get: expected 3, got: $cfg_val2"
pass "config: set/get max_spawn_depth"

# Config list
cfg_list=$(ic config list --json --db="$TEST_DB")
echo "$cfg_list" | grep -q "global_max_dispatches" || fail "config list missing global_max_dispatches"
echo "$cfg_list" | grep -q "max_spawn_depth" || fail "config list missing max_spawn_depth"
pass "config: list"

# Config get for unset key
cfg_unset=$(ic config get nonexistent_key --db="$TEST_DB" 2>&1) || true
echo "$cfg_unset" | grep -q "not set" || fail "config get unset: expected 'not set', got: $cfg_unset"
pass "config: get unset key returns not-set"

# Run with budget-enforce and max-agents
BUDGET_RUN_ID=$(ic run create --project="$TEST_DIR" --goal="budget test" --complexity=3 --budget-enforce --max-agents=2 --token-budget=1000 --db="$TEST_DB")
[[ -n "$BUDGET_RUN_ID" ]] || fail "run create with budget-enforce"
pass "budget: run create with budget-enforce"

# Verify budget-enforce is set in status
budget_status=$(ic run status "$BUDGET_RUN_ID" --json --db="$TEST_DB")
echo "$budget_status" | grep -q '"budget_enforce":true' || fail "budget_enforce not set in status: $budget_status"
echo "$budget_status" | grep -q '"max_agents":2' || fail "max_agents not set in status: $budget_status"
pass "budget: run status shows budget_enforce and max_agents"

# Budget gate: under budget should pass
gate_under=$(ic gate check "$BUDGET_RUN_ID" --priority=0 --json --db="$TEST_DB" 2>&1) || true
# brainstorm → brainstorm-reviewed requires artifact_exists, so gate will fail on that
# but the budget check should pass (no tokens spent yet)
pass "budget: gate check under budget"

# Advance with gates disabled to get to a later phase for agent cap testing
ic run advance "$BUDGET_RUN_ID" --priority=4 --db="$TEST_DB" >/dev/null
ic run advance "$BUDGET_RUN_ID" --priority=4 --db="$TEST_DB" >/dev/null
ic run advance "$BUDGET_RUN_ID" --priority=4 --db="$TEST_DB" >/dev/null
ic run advance "$BUDGET_RUN_ID" --priority=4 --db="$TEST_DB" >/dev/null
pass "budget: advance to executing phase"

echo "  Cost-aware scheduling tests passed"

# --- Version sync check ---

--- 2026-02-21T08:55:45Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	if r.MaxDispatches > 0 {
		m["max_dispatches"] = r.MaxDispatches
	}
	return m
NEW: 	if r.MaxDispatches > 0 {
		m["max_dispatches"] = r.MaxDispatches
	}
	if r.BudgetEnforce {
		m["budget_enforce"] = true
	}
	if r.MaxAgents > 0 {
		m["max_agents"] = r.MaxAgents
	}
	return m

--- 2026-02-21T08:56:05Z | infra/intercore/cmd/ic/main.go | CONTEXT:unknown ---
OLD:   run set <id> [--complexity=N] [--auto-advance=bool] [--force-full=bool] [--max-dispatches=N]
NEW:   run set <id> [--complexity=N] [--auto-advance=bool] [--force-full=bool] [--max-dispatches=N]
  run create ... [--budget-enforce] [--max-agents=N]  Enable budget enforcement

--- 2026-02-21T08:56:10Z | infra/intercore/cmd/ic/main.go | CONTEXT:unknown ---
OLD:   dispatch spawn [opts]         Spawn an agent dispatch
NEW:   dispatch spawn [opts]         Spawn an agent dispatch (--parent-dispatch=<id>)

--- 2026-02-21T08:56:18Z | infra/intercore/CLAUDE.md | CONTEXT:unknown ---
OLD: ic dispatch spawn --prompt-file=<f> --project=<dir> --name=<label> --output=<path>
NEW: ic dispatch spawn --prompt-file=<f> --project=<dir> --name=<label> --output=<path>
ic dispatch spawn ... --parent-dispatch=<id>    # Nested dispatch (spawn depth tracking)

--- 2026-02-21T08:56:22Z | infra/intercore/CLAUDE.md | CONTEXT:unknown ---
OLD: ic run create --project=. --goal="Big feature" --token-budget=500000 --budget-warn-pct=80
NEW: ic run create --project=. --goal="Big feature" --token-budget=500000 --budget-warn-pct=80
ic run create --project=. --goal="Enforced" --budget-enforce --max-agents=5

--- 2026-02-21T08:56:29Z | infra/intercore/CLAUDE.md | CONTEXT:unknown ---
OLD: ## Event Bus Quick Reference
NEW: ## Config Quick Reference

```bash
ic config set global_max_dispatches 10  # Max active dispatches across all runs
ic config set max_spawn_depth 3         # Max dispatch nesting depth
ic config get <key>                     # Get a config value
ic config list [--verbose]              # List all config values
```

## Event Bus Quick Reference

--- 2026-02-21T08:56:49Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ### DBPool
NEW: ### Cost-Aware Agent Scheduling

Runs can opt into enforcement with `--budget-enforce` and `--max-agents=N` at creation time. When enabled:

**Spawn policy** (`dispatch/policy.go`) — checked before every `dispatch spawn`:
- **Budget enforcement**: if `budget_enforce=true` and budget is exceeded, spawn is rejected
- **Per-run concurrency**: active dispatches for the run vs `max_dispatches`
- **Global concurrency**: all active dispatches vs `kernel.global_max_dispatches` config
- **Agent cap**: total dispatches (lifetime) for the run vs `max_agents`
- **Spawn depth**: nested dispatch depth vs `kernel.max_spawn_depth` config

Rejected spawns return exit code 1 with a structured error including `current` and `limit` values.

**Budget gate** (`phase/gate.go`): when `budget_enforce=true`, phase advancement checks `budget_not_exceeded` alongside artifact/agent gates. A hard gate blocks advancement; can be overridden with `ic gate override`.

**Global config** (`ic config`): kernel-level limits stored in the state table under `kernel.*` scope:
```bash
ic config set global_max_dispatches 10   # limit concurrent dispatches
ic config set max_spawn_depth 3          # limit dispatch nesting
```

**TOCTOU note:** Concurrency checks are advisory — concurrent spawns may briefly exceed limits before the database is updated. Same trade-off as `max_dispatches`.

### DBPool

--- 2026-02-21T08:56:57Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ic run create --project=<dir> --goal=<text> [--complexity=N] [--scope-id=S] [--phases='[...]'] [--token-budget=N] [--budget-warn-pct=N]
NEW: ic run create --project=<dir> --goal=<text> [--complexity=N] [--scope-id=S] [--phases='[...]'] [--token-budget=N] [--budget-warn-pct=N] [--budget-enforce] [--max-agents=N]

--- 2026-02-21T08:57:05Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ic portfolio relay <id> [--interval=2s]    Start event relay (blocks, SIGINT to stop)
NEW: ic portfolio relay <id> [--interval=2s]    Start event relay (blocks, SIGINT to stop)
ic config set <key> <value>               Set kernel config (global_max_dispatches, max_spawn_depth)
ic config get <key>                       Get kernel config value
ic config list [--verbose]                List all kernel config values

--- 2026-02-21T08:57:12Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: ic dispatch spawn [flags]                  Spawn an agent dispatch (prints ID)
NEW: ic dispatch spawn [flags]                  Spawn an agent dispatch (prints ID, --parent-dispatch=<id> for nesting)

--- 2026-02-21T09:02:57Z | infra/intercore/internal/db/schema.sql | CONTEXT:unknown ---
OLD: CREATE INDEX IF NOT EXISTS idx_project_deps_portfolio ON project_deps(portfolio_run_id);
NEW: CREATE INDEX IF NOT EXISTS idx_project_deps_portfolio ON project_deps(portfolio_run_id);

-- v13: thematic work lanes
CREATE TABLE IF NOT EXISTS lanes (
    id          TEXT NOT NULL PRIMARY KEY,
    name        TEXT NOT NULL UNIQUE,
    lane_type   TEXT NOT NULL DEFAULT 'standing',  -- 'standing' or 'arc'
    status      TEXT NOT NULL DEFAULT 'active',    -- 'active', 'closed', 'archived'
    description TEXT NOT NULL DEFAULT '',
    metadata    TEXT NOT NULL DEFAULT '{}',         -- JSON: pollard config, starvation weights
    created_at  INTEGER NOT NULL DEFAULT (unixepoch()),
    updated_at  INTEGER NOT NULL DEFAULT (unixepoch()),
    closed_at   INTEGER
);
CREATE INDEX IF NOT EXISTS idx_lanes_status ON lanes(status) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_lanes_type ON lanes(lane_type);

CREATE TABLE IF NOT EXISTS lane_events (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    lane_id     TEXT NOT NULL REFERENCES lanes(id),
    event_type  TEXT NOT NULL,  -- 'created', 'bead_added', 'bead_removed', 'snapshot', 'closed'
    payload     TEXT NOT NULL DEFAULT '{}',
    created_at  INTEGER NOT NULL DEFAULT (unixepoch())
);
CREATE INDEX IF NOT EXISTS idx_lane_events_lane ON lane_events(lane_id);
CREATE INDEX IF NOT EXISTS idx_lane_events_created ON lane_events(created_at);

CREATE TABLE IF NOT EXISTS lane_members (
    lane_id     TEXT NOT NULL REFERENCES lanes(id),
    bead_id     TEXT NOT NULL,
    added_at    INTEGER NOT NULL DEFAULT (unixepoch()),
    PRIMARY KEY (lane_id, bead_id)
);
CREATE INDEX IF NOT EXISTS idx_lane_members_bead ON lane_members(bead_id);

--- 2026-02-21T09:03:01Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	currentSchemaVersion = 12
	maxSchemaVersion     = 12
NEW: 	currentSchemaVersion = 13
	maxSchemaVersion     = 13

--- 2026-02-21T09:03:19Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: 	if v != 12 {
		t.Fatalf("expected schema version 12, got %d", v)
NEW: 	if v != 13 {
		t.Fatalf("expected schema version 13, got %d", v)

--- 2026-02-21T09:03:19Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: // Compute pinned positions for sprint phases — horizontal arc
function computePhasePositions() {
  var positions = [];
  var arcW = width * 0.7;
  var startX = width * 0.15;
  var topY = height * 0.12;
  var botY = height * 0.45;
  var arcCurve = 30; // slight vertical curve

  // Top row: steps 1-5 (left to right)
  for (var i = 0; i < 5; i++) {
    var t = i / 4;
    var x = startX + t * arcW;
    var y = topY + Math.sin(t * Math.PI) * arcCurve;
    positions.push({ x: x, y: y });
  }
  // Bottom row: steps 6-10 (right to left)
  for (var i = 0; i < 5; i++) {
    var t = i / 4;
    var x = startX + arcW - t * arcW;
    var y = botY + Math.sin(t * Math.PI) * arcCurve;
    positions.push({ x: x, y: y });
  }
  return positions;
}
NEW: // Compute pinned positions for sprint phases — elliptical ring around ecosystem
function computePhasePositions() {
  var positions = [];
  var cx = width * 0.5;
  var cy = height * 0.5;
  var rx = width * 0.40;
  var ry = height * 0.40;
  // 10 phases clockwise from left (π): Brainstorm at 9 o'clock, Execute at 3 o'clock
  var n = SPRINT_PHASES.length;
  for (var i = 0; i < n; i++) {
    var angle = Math.PI + (i / n) * 2 * Math.PI; // start at π (left), go clockwise
    positions.push({ x: cx + rx * Math.cos(angle), y: cy - ry * Math.sin(angle) });
  }
  return positions;
}

--- 2026-02-21T09:03:30Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   .force('link', d3.forceLink(graphLinks).id(function(d) { return d.id; }).distance(function(d) {
    if (d.type === 'participates-in') return 200;
    if (d.type === 'part-of') return 100;
    if (d.type === 'companion-of') return 120;
    if (d.type === 'overlaps-with') return 90;
    if (d.type === 'provides-skill' || d.type === 'provides-agent') return 50;
    return 80;
  }))
  .force('charge', d3.forceManyBody().strength(function(d) {
    if (d.type === 'sprint-phase') return -500;
    if (d.type === 'monorepo' || d.type === 'hub') return -400;
    if (d.type === 'plugin' || d.type === 'kernel') return -200;
    return -60;
  }))
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(function(d) {
    if (d.type === 'sprint-phase') return 90;
    return (TYPE_SIZES[d.type] || 8) + 4;
  }));
NEW:   .force('link', d3.forceLink(graphLinks).id(function(d) { return d.id; }).distance(function(d) {
    if (d.type === 'participates-in') return 280;
    if (d.type === 'part-of') return 100;
    if (d.type === 'companion-of') return 120;
    if (d.type === 'overlaps-with') return 90;
    if (d.type === 'provides-skill' || d.type === 'provides-agent') return 50;
    return 80;
  }))
  .force('charge', d3.forceManyBody().strength(function(d) {
    if (d.type === 'sprint-phase') return -800;
    if (d.type === 'monorepo' || d.type === 'hub') return -400;
    if (d.type === 'plugin' || d.type === 'kernel') return -200;
    return -60;
  }))
  .force('center', d3.forceCenter(width / 2, height / 2).strength(0.05))
  .force('collision', d3.forceCollide().radius(function(d) {
    if (d.type === 'sprint-phase') return 120;
    return (TYPE_SIZES[d.type] || 8) + 4;
  }));

--- 2026-02-21T09:03:32Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: 	_, err = d.db.Exec(`INSERT INTO interest_profile (id) VALUES (2)`)
	if err == nil {
		t.Fatal("expected CHECK constraint violation on interest_profile.id != 1")
	}
}
NEW: 	_, err = d.db.Exec(`INSERT INTO interest_profile (id) VALUES (2)`)
	if err == nil {
		t.Fatal("expected CHECK constraint violation on interest_profile.id != 1")
	}
}

func TestMigrate_V12ToV13_LaneTables(t *testing.T) {
	d, _ := tempDB(t)
	ctx := context.Background()

	// Migrate from scratch (full DDL) — verifies lanes tables exist
	if err := d.Migrate(ctx); err != nil {
		t.Fatalf("Migrate: %v", err)
	}

	v, err := d.SchemaVersion()
	if err != nil {
		t.Fatal(err)
	}
	if v != 13 {
		t.Fatalf("expected schema version 13, got %d", v)
	}

	// Verify lanes table exists with correct columns
	rows, err := d.db.Query("SELECT id, name, lane_type, status, description, metadata, created_at, updated_at, closed_at FROM lanes LIMIT 0")
	if err != nil {
		t.Fatalf("lanes table missing or wrong schema: %v", err)
	}
	rows.Close()

	// Verify lane_events table
	rows, err = d.db.Query("SELECT id, lane_id, event_type, payload, created_at FROM lane_events LIMIT 0")
	if err != nil {
		t.Fatalf("lane_events table missing: %v", err)
	}
	rows.Close()

	// Verify lane_members table
	rows, err = d.db.Query("SELECT lane_id, bead_id, added_at FROM lane_members LIMIT 0")
	if err != nil {
		t.Fatalf("lane_members table missing: %v", err)
	}
	rows.Close()

	// Verify insert works
	_, err = d.db.Exec(`INSERT INTO lanes (id, name, lane_type) VALUES ('lane001', 'interop', 'standing')`)
	if err != nil {
		t.Fatalf("lanes insert failed: %v", err)
	}

	// Verify unique name constraint
	_, err = d.db.Exec(`INSERT INTO lanes (id, name, lane_type) VALUES ('lane002', 'interop', 'arc')`)
	if err == nil {
		t.Fatal("expected UNIQUE constraint violation on lanes.name")
	}

	// Verify lane_events foreign key
	_, err = d.db.Exec(`INSERT INTO lane_events (lane_id, event_type) VALUES ('lane001', 'created')`)
	if err != nil {
		t.Fatalf("lane_events insert failed: %v", err)
	}

	// Verify lane_members
	_, err = d.db.Exec(`INSERT INTO lane_members (lane_id, bead_id) VALUES ('lane001', 'iv-abc1')`)
	if err != nil {
		t.Fatalf("lane_members insert failed: %v", err)
	}

	// Verify lane_members composite PK prevents duplicates
	_, err = d.db.Exec(`INSERT INTO lane_members (lane_id, bead_id) VALUES ('lane001', 'iv-abc1')`)
	if err == nil {
		t.Fatal("expected PRIMARY KEY constraint violation on lane_members")
	}
}

--- 2026-02-21T09:03:34Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: .link.participates-in {
  stroke: #45B7D1;
  stroke-dasharray: 4 3;
  stroke-opacity: 0.2;
}
NEW: .link.participates-in {
  stroke: #45B7D1;
  stroke-dasharray: 4 3;
  stroke-opacity: 0.35;
  stroke-width: 1.5;
}

--- 2026-02-21T09:03:39Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: .domain-hull.hidden { fill-opacity: 0; stroke-opacity: 0; }
NEW: .domain-hull.hidden { fill-opacity: 0; stroke-opacity: 0; }
.hulls-dimmed .domain-hull { fill-opacity: 0.03; stroke-opacity: 0.12; }
.hulls-dimmed .domain-label { fill-opacity: 0.15; }

--- 2026-02-21T09:03:45Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function rebuildGraph() {
  // Clear sprint-specific rendering + spotlight
  sprintNodeGroup.selectAll('*').remove();
  sprintFlowGroup.selectAll('*').remove();
  spotlightGroup.selectAll('*').remove();
NEW: function rebuildGraph() {
  // Clear sprint-specific rendering + spotlight
  sprintNodeGroup.selectAll('*').remove();
  sprintFlowGroup.selectAll('*').remove();
  spotlightGroup.selectAll('*').remove();

  // Dim domain hulls when sprint is active to reduce visual noise
  hullGroup.classed('hulls-dimmed', sprintActive);
  hullLabelGroup.classed('hulls-dimmed', sprintActive);

--- 2026-02-21T09:03:54Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: want 12
NEW: want 13

--- 2026-02-21T09:04:02Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: if v != 12 {
NEW: if v != 13 {

--- 2026-02-21T09:04:12Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   // Skip path: Brainstorm → Write Plan
  var skipFrom = posById['brainstorm'];
  var skipTo = posById['write-plan'];
  if (skipFrom && skipTo) {
    var skipMidY = Math.min(skipFrom.y, skipTo.y) - 80;
    sprintFlowGroup.append('path')
      .attr('class', 'sprint-flow-arrow')
      .attr('d', 'M' + skipFrom.x + ',' + (skipFrom.y - nodeH / 2) +
        ' C' + skipFrom.x + ',' + skipMidY +
        ' ' + skipTo.x + ',' + skipMidY +
        ' ' + skipTo.x + ',' + (skipTo.y - nodeH / 2))
      .attr('fill', 'none').attr('stroke', '#F39C12').attr('stroke-width', 2)
      .attr('stroke-dasharray', '6 3')
      .attr('marker-end', 'url(#sprint-skip-arrow)');

    sprintFlowGroup.append('text')
      .attr('x', (skipFrom.x + skipTo.x) / 2)
      .attr('y', skipMidY - 6)
      .attr('text-anchor', 'middle')
      .attr('fill', '#F39C12').attr('font-size', '10px')
      .text('skip (trivial tasks)');
  }
NEW:   // Skip path: Brainstorm → Write Plan (curves inward toward center)
  var skipFrom = posById['brainstorm'];
  var skipTo = posById['write-plan'];
  if (skipFrom && skipTo) {
    var skipMidX = (skipFrom.x + skipTo.x) / 2 + (width * 0.5 - (skipFrom.x + skipTo.x) / 2) * 0.5;
    var skipMidY = (skipFrom.y + skipTo.y) / 2 + (height * 0.5 - (skipFrom.y + skipTo.y) / 2) * 0.5;
    sprintFlowGroup.append('path')
      .attr('class', 'sprint-flow-arrow')
      .attr('d', 'M' + skipFrom.x + ',' + skipFrom.y +
        ' Q' + skipMidX + ',' + skipMidY +
        ' ' + skipTo.x + ',' + skipTo.y)
      .attr('fill', 'none').attr('stroke', '#F39C12').attr('stroke-width', 2)
      .attr('stroke-dasharray', '6 3')
      .attr('marker-end', 'url(#sprint-skip-arrow)');

    sprintFlowGroup.append('text')
      .attr('x', skipMidX).attr('y', skipMidY - 10)
      .attr('text-anchor', 'middle')
      .attr('fill', '#F39C12').attr('font-size', '10px')
      .text('skip (trivial tasks)');
  }

--- 2026-02-21T09:07:41Z | infra/intercore/cmd/ic/main.go | CONTEXT:unknown ---
OLD: 	case "portfolio":
		exitCode = cmdPortfolio(ctx, subArgs)
	case "config":
NEW: 	case "portfolio":
		exitCode = cmdPortfolio(ctx, subArgs)
	case "lane":
		exitCode = cmdLane(ctx, subArgs)
	case "config":

--- 2026-02-21T09:07:52Z | infra/intercore/docs/roadmap.md | CONTEXT:unknown ---
OLD: ### E8: Level 4 — Orchestrate (P3) — SHIPPED
**What:** Multi-project coordination and portfolio management.
**Shipped:** Cross-project event relay (`ic portfolio relay`), portfolio runs (`ic run create --projects=`), project dependencies (`project_deps` table, `upstream_changed` events), portfolio gates (`children_at_phase`), dispatch budget (`max_dispatches` with relay-maintained counter). Schema v10.

## Open Epics
NEW: ### E8: Level 4 — Orchestrate (P3) — SHIPPED
**What:** Multi-project coordination and portfolio management.
**Shipped:** Cross-project event relay (`ic portfolio relay`), portfolio runs (`ic run create --projects=`), project dependencies (`project_deps` table, `upstream_changed` events), portfolio gates (`children_at_phase`), dispatch budget (`max_dispatches` with relay-maintained counter). Schema v10.

### TOCTOU Prevention — Phase 1 (P1) — SHIPPED
**What:** Fix race conditions in dispatch coordination and gate evaluation.
**Bead:** iv-14g9
**Shipped:** CAS guard on `dispatch.UpdateStatus` (AND status=? in WHERE), atomic gate-phase advance (`evaluateGate` + `UpdatePhase` wrapped in `BeginTx`), write-set conflict detection at dispatch merge time, Intent Record pattern for SQLite+git coordination, TOCTOU conflict telemetry aggregation. Schema v11. Phase 2 (telemetry evaluation after 30 days) is calendar-gated.

### Cost-Aware Agent Scheduling (P2) — SHIPPED
**What:** Budget enforcement and concurrency limits for agent dispatches.
**Bead:** iv-suzr
**Shipped:** Spawn policy enforcement (`dispatch/policy.go`) — budget check, per-run concurrency, global concurrency, agent caps, spawn depth limits. Budget gate type for phase advancement. `ic config set/get/list` for kernel-level limits. `--budget-enforce`, `--max-agents`, `--parent-dispatch` flags. Schema v12.

## Open Epics

--- 2026-02-21T09:08:02Z | infra/intercore/docs/roadmap.md | CONTEXT:unknown ---
OLD: ## Dependency Graph

```
E1 ──→ E2 ──→ E3 (Hook Cutover)     ✓ all shipped
           ├──→ E4 ──→ E5 (Discovery) ✓
           ├──→ E6 (Rollback)          ✓
           └──→ E7 (Autarch P1)        ✓
                         ↓
     E5+E6 ──→ E8 (Orchestrate)        ✓
     E5+E7 ──→ E9 (Autarch P2)        ← unblocked
     E8+E9 ──→ E10 (Sandbox+P3)       ← E9 remains
```
NEW: ## Dependency Graph

```
E1 ──→ E2 ──→ E3 (Hook Cutover)     ✓ all shipped
           ├──→ E4 ──→ E5 (Discovery) ✓
           ├──→ E6 (Rollback)          ✓
           └──→ E7 (Autarch P1)        ✓
                         ↓
     E5+E6 ──→ E8 (Orchestrate)        ✓
     E8 ────→ TOCTOU Prevention P1     ✓
     E8 ────→ Cost-Aware Scheduling    ✓
     E5+E7 ──→ E9 (Autarch P2)        ← unblocked
     E8+E9 ──→ E10 (Sandbox+P3)       ← E9 remains
```

--- 2026-02-21T09:08:31Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: echo "  Cost-aware scheduling tests passed"

# --- Version sync check ---
NEW: echo "  Cost-aware scheduling tests passed"

echo "=== Thematic Work Lanes ==="

# Lane create
LANE_ID=$(ic lane create --name=interop --type=standing --description="Plugin interop" --json --db="$TEST_DB" | jq -r '.id')
[[ -n "$LANE_ID" ]] || fail "lane create"
pass "lane: create"

# Lane list
ic lane list --json --db="$TEST_DB" | jq -e '.[0].name == "interop"' >/dev/null || fail "lane list"
pass "lane: list"

# Lane status
ic lane status "$LANE_ID" --json --db="$TEST_DB" | jq -e '.name == "interop"' >/dev/null || fail "lane status"
pass "lane: status"

# Lane status by name
ic lane status interop --json --db="$TEST_DB" | jq -e '.name == "interop"' >/dev/null || fail "lane status by name"
pass "lane: status by name"

# Lane sync (membership)
ic lane sync "$LANE_ID" --bead-ids=iv-abc1,iv-abc2,iv-abc3 --db="$TEST_DB" >/dev/null || fail "lane sync"
MEMBER_COUNT=$(ic lane members "$LANE_ID" --json --db="$TEST_DB" | jq 'length')
[[ "$MEMBER_COUNT" == "3" ]] || fail "lane members: expected 3, got $MEMBER_COUNT"
pass "lane: sync + members"

# Lane events
EVENT_COUNT=$(ic lane events "$LANE_ID" --json --db="$TEST_DB" | jq 'length')
[[ "$EVENT_COUNT" -ge 2 ]] || fail "lane events: expected >= 2, got $EVENT_COUNT"
pass "lane: events"

# Lane close
ic lane close "$LANE_ID" --db="$TEST_DB" >/dev/null || fail "lane close"
CLOSED_STATUS=$(ic lane status "$LANE_ID" --json --db="$TEST_DB" | jq -r '.status')
[[ "$CLOSED_STATUS" == "closed" ]] || fail "lane close: expected closed, got $CLOSED_STATUS"
pass "lane: close"

# Create arc lane
ARC_LANE_ID=$(ic lane create --name=e8-bigend --type=arc --json --db="$TEST_DB" | jq -r '.id')
ARC_TYPE=$(ic lane status "$ARC_LANE_ID" --json --db="$TEST_DB" | jq -r '.lane_type')
[[ "$ARC_TYPE" == "arc" ]] || fail "lane arc type: expected arc, got $ARC_TYPE"
pass "lane: arc type"

echo "  Thematic work lanes tests passed"

# --- Version sync check ---

--- 2026-02-21T09:08:51Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: internal/dispatch/      Agent dispatch lifecycle: spawn, poll, collect, wait
  dispatch.go           Store (CRUD), Dispatch struct, ID generation
  spawn.go              Process spawning, dispatch.sh resolution, prompt hashing
  collect.go            Liveness polling, verdict/summary parsing, wait loop
NEW: internal/dispatch/      Agent dispatch lifecycle: spawn, poll, collect, wait
  dispatch.go           Store (CRUD), Dispatch struct, ID generation
  spawn.go              Process spawning, dispatch.sh resolution, prompt hashing
  collect.go            Liveness polling, verdict/summary parsing, wait loop
  policy.go             SpawnPolicy enforcement: budget, concurrency, agent caps, spawn depth
  conflict.go           Write-set conflict detection at dispatch merge time
  intent.go             Intent Record pattern for SQLite+git merge coordination
  telemetry.go          TOCTOU conflict telemetry aggregation
  outcome.go            Dispatch outcome recording

--- 2026-02-21T09:09:56Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 	case "members":
		return cmdLaneMembers(ctx, args[1:])
	default:
NEW: 	case "members":
		return cmdLaneMembers(ctx, args[1:])
	case "velocity":
		return cmdLaneVelocity(ctx, args[1:])
	default:

--- 2026-02-21T09:10:23Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(members)
	} else {
		if len(members) == 0 {
			fmt.Println("no members")
			return 0
		}
		for _, m := range members {
			fmt.Println(m)
		}
	}
	return 0
}
NEW: 	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(members)
	} else {
		if len(members) == 0 {
			fmt.Println("no members")
			return 0
		}
		for _, m := range members {
			fmt.Println(m)
		}
	}
	return 0
}

func cmdLaneVelocity(ctx context.Context, args []string) int {
	days := 7
	for _, arg := range args {
		if strings.HasPrefix(arg, "--days=") {
			fmt.Sscanf(strings.TrimPrefix(arg, "--days="), "%d", &days)
		}
	}

	d, err := openDB()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: lane velocity: %v\n", err)
		return 2
	}
	defer d.Close()

	if err := d.Migrate(ctx); err != nil {
		fmt.Fprintf(os.Stderr, "ic: lane velocity: migrate: %v\n", err)
		return 2
	}

	store := lane.New(d.SqlDB())
	v := lane.NewVelocityCalculator(store)
	scores, err := v.ComputeStarvationFromDB(ctx, days)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: lane velocity: %v\n", err)
		return 2
	}

	sorted := lane.SortedByStarvation(scores)

	if flagJSON {
		items := make([]map[string]interface{}, len(sorted))
		for i, s := range sorted {
			items[i] = map[string]interface{}{
				"lane_id":    s.LaneID,
				"name":       s.LaneName,
				"open_beads": s.OpenBeads,
				"closed":     s.ClosedLast,
				"throughput": s.Throughput,
				"starvation": s.Starvation,
			}
		}
		json.NewEncoder(os.Stdout).Encode(items)
	} else {
		if len(sorted) == 0 {
			fmt.Println("no active lanes")
			return 0
		}
		fmt.Printf("%-12s %5s %6s %8s %10s\n", "LANE", "OPEN", "CLOSED", "THRPUT", "STARV")
		for _, s := range sorted {
			fmt.Printf("%-12s %5d %6d %8.1f %10.1f\n",
				s.LaneName, s.OpenBeads, s.ClosedLast, s.Throughput, s.Starvation)
		}
	}
	return 0
}

--- 2026-02-21T09:11:09Z | plugins/interphase/hooks/lib-discovery.sh | CONTEXT:unknown ---
OLD:     # Merge both lists
    local merged
    merged=$(jq -n --argjson a "$open_list" --argjson b "$ip_list" '$a + $b')

    local count
    count=$(echo "$merged" | jq 'length' 2>/dev/null) || count=0
NEW:     # Merge both lists
    local merged
    merged=$(jq -n --argjson a "$open_list" --argjson b "$ip_list" '$a + $b')

    # Lane filter: if DISCOVERY_LANE is set, filter to beads with lane:<name> label
    if [[ -n "${DISCOVERY_LANE:-}" && "$DISCOVERY_LANE" != "*" ]]; then
        merged=$(echo "$merged" | jq --arg lane "lane:${DISCOVERY_LANE}" \
            '[.[] | select(.labels // [] | any(. == $lane))]')
    fi

    local count
    count=$(echo "$merged" | jq 'length' 2>/dev/null) || count=0

--- 2026-02-21T09:11:21Z | plugins/interphase/hooks/lib-discovery.sh | CONTEXT:unknown ---
OLD:     # Count beads
    local open_count ip_count
    open_count=$(echo "$open_json" | jq 'length' 2>/dev/null) || open_count=0
    ip_count=$(echo "$ip_json" | jq 'length' 2>/dev/null) || ip_count=0
    local total_count=$(( open_count + ip_count ))
NEW:     # Lane filter: if DISCOVERY_LANE is set, filter to beads with lane:<name> label
    if [[ -n "${DISCOVERY_LANE:-}" && "$DISCOVERY_LANE" != "*" ]]; then
        open_json=$(echo "$open_json" | jq --arg lane "lane:${DISCOVERY_LANE}" \
            '[.[] | select(.labels // [] | any(. == $lane))]')
        ip_json=$(echo "$ip_json" | jq --arg lane "lane:${DISCOVERY_LANE}" \
            '[.[] | select(.labels // [] | any(. == $lane))]')
    fi

    # Count beads
    local open_count ip_count
    open_count=$(echo "$open_json" | jq 'length' 2>/dev/null) || open_count=0
    ip_count=$(echo "$ip_json" | jq 'length' 2>/dev/null) || ip_count=0
    local total_count=$(( open_count + ip_count ))

--- 2026-02-21T09:12:33Z | os/clavain/commands/sprint.md | CONTEXT:unknown ---
OLD: If invoked WITH arguments (`$ARGUMENTS` is not empty):
- **If `$ARGUMENTS` contains `--resume`**: Read checkpoint with `checkpoint_read`. If a checkpoint exists, validate with `checkpoint_validate`, display completed steps, and skip to the first incomplete step. If no checkpoint, fall through to Work Discovery.
- **If `$ARGUMENTS` contains `--from-step <n>`**: Skip directly to step `<n>` regardless of checkpoint state. Step names: brainstorm, strategy, plan, plan-review, execute, test, quality-gates, resolve, reflect, ship.
- **If `$ARGUMENTS` matches a bead ID** (format: `[A-Za-z]+-[a-z0-9]+`):
NEW: If invoked WITH arguments (`$ARGUMENTS` is not empty):
- **If `$ARGUMENTS` contains `--lane=<name>`**: Extract the lane name and set `DISCOVERY_LANE=<name>` before any discovery calls. Display: `Lane: <name> — filtering to lane-scoped beads`. When creating a new sprint bead, also tag it: `bd label add "$SPRINT_ID" "lane:${SPRINT_LANE}"`.
- **If `$ARGUMENTS` contains `--resume`**: Read checkpoint with `checkpoint_read`. If a checkpoint exists, validate with `checkpoint_validate`, display completed steps, and skip to the first incomplete step. If no checkpoint, fall through to Work Discovery.
- **If `$ARGUMENTS` contains `--from-step <n>`**: Skip directly to step `<n>` regardless of checkpoint state. Step names: brainstorm, strategy, plan, plan-review, execute, test, quality-gates, resolve, reflect, ship.
- **If `$ARGUMENTS` matches a bead ID** (format: `[A-Za-z]+-[a-z0-9]+`):

--- 2026-02-21T09:12:38Z | os/clavain/commands/sprint.md | CONTEXT:unknown ---
OLD: 1. Run the work discovery scanner:
   ```bash
   export DISCOVERY_PROJECT_DIR="."; source "${CLAUDE_PLUGIN_ROOT}/hooks/lib-discovery.sh" && discovery_scan_beads
   ```
NEW: 1. Run the work discovery scanner:
   ```bash
   export DISCOVERY_PROJECT_DIR="."; export DISCOVERY_LANE="${DISCOVERY_LANE:-}"; source "${CLAUDE_PLUGIN_ROOT}/hooks/lib-discovery.sh" && discovery_scan_beads
   ```

--- 2026-02-21T09:12:50Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD: # Returns bead ID to stdout (for CLAVAIN_BEAD_ID).
# REQUIRES: intercore available. Bead creation failure is fatal (when bd installed).
sprint_create() {
    local title="${1:-Sprint}"

    sprint_require_ic || { echo ""; return 1; }

    # Create bead for tracking (fatal when bd is available)
    local sprint_id=""
    if command -v bd &>/dev/null; then
NEW: # Returns bead ID to stdout (for CLAVAIN_BEAD_ID).
# REQUIRES: intercore available. Bead creation failure is fatal (when bd installed).
# $1: title, $2: complexity (default 3), $3: lane name (optional)
sprint_create() {
    local title="${1:-Sprint}"
    local lane="${3:-}"

    sprint_require_ic || { echo ""; return 1; }

    # Create bead for tracking (fatal when bd is available)
    local sprint_id=""
    if command -v bd &>/dev/null; then

--- 2026-02-21T09:12:56Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD:         bd set-state "$sprint_id" "sprint=true" >/dev/null 2>&1 || true
        bd update "$sprint_id" --status=in_progress >/dev/null 2>&1 || true
NEW:         bd set-state "$sprint_id" "sprint=true" >/dev/null 2>&1 || true
        bd update "$sprint_id" --status=in_progress >/dev/null 2>&1 || true
        # Tag with lane label if specified
        if [[ -n "$lane" ]]; then
            bd label add "$sprint_id" "lane:${lane}" >/dev/null 2>&1 || true
        fi

--- 2026-02-21T09:12:58Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   // 10 phases clockwise from left (π): Brainstorm at 9 o'clock, Execute at 3 o'clock
  var n = SPRINT_PHASES.length;
  for (var i = 0; i < n; i++) {
    var angle = Math.PI + (i / n) * 2 * Math.PI; // start at π (left), go clockwise
    positions.push({ x: cx + rx * Math.cos(angle), y: cy - ry * Math.sin(angle) });
  }
NEW:   // 10 phases clockwise from top (12 o'clock): Brainstorm at top
  var n = SPRINT_PHASES.length;
  for (var i = 0; i < n; i++) {
    var angle = -Math.PI / 2 + (i / n) * 2 * Math.PI; // start at -π/2 (top), go clockwise
    positions.push({ x: cx + rx * Math.cos(angle), y: cy + ry * Math.sin(angle) });
  }

--- 2026-02-21T09:13:07Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD: function renderSprintNodes() {
  var nodeW = 160, nodeH = 56;

  sprintNodes.forEach(function(sn) {
    var phase = sn._phase;
    var color = PHASE_COLORS[phase.phase] || '#8b949e';

    var gNode = sprintNodeGroup.append('g')
      .attr('class', 'sprint-phase-node')
      .attr('data-id', sn.id)
      .attr('transform', 'translate(' + (sn.x - nodeW / 2) + ',' + (sn.y - nodeH / 2) + ')')
      .style('cursor', 'pointer')
      .on('click', function(event) {
        event.stopPropagation();
        selectSprintNode(sn);
      });
NEW: function renderSprintNodes() {
  var nodeW = 160, nodeH = 56;

  sprintNodes.forEach(function(sn) {
    var phase = sn._phase;
    var color = PHASE_COLORS[phase.phase] || '#8b949e';

    var gNode = sprintNodeGroup.append('g')
      .attr('class', 'sprint-phase-node')
      .attr('data-id', sn.id)
      .attr('transform', 'translate(' + (sn.x - nodeW / 2) + ',' + (sn.y - nodeH / 2) + ')')
      .style('cursor', 'grab')
      .on('click', function(event) {
        event.stopPropagation();
        selectSprintNode(sn);
      })
      .call(d3.drag()
        .on('start', function(event) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          sn.fx = sn.x; sn.fy = sn.y;
          d3.select(this).style('cursor', 'grabbing');
        })
        .on('drag', function(event) {
          sn.fx = event.x; sn.fy = event.y;
          sn.x = event.x; sn.y = event.y;
        })
        .on('end', function(event) {
          if (!event.active) simulation.alphaTarget(0);
          // Keep pinned where user dropped it (don't clear fx/fy)
          d3.select(this).style('cursor', 'grab');
        })
      );

--- 2026-02-21T09:13:14Z | plugins/interchart/templates/ecosystem.html | CONTEXT:unknown ---
OLD:   node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  updateHulls();
  updateSpotlightPaths();
NEW:   node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  // Update sprint phase node positions (they live in a separate group)
  var sprintNodeW = 160, sprintNodeH = 56;
  sprintNodeGroup.selectAll('.sprint-phase-node').each(function() {
    var el = d3.select(this);
    var nodeId = el.attr('data-id');
    var sn = nodeById[nodeId];
    if (sn) el.attr('transform', 'translate(' + (sn.x - sprintNodeW / 2) + ',' + (sn.y - sprintNodeH / 2) + ')');
  });
  // Redraw flow arrows to follow sprint node positions
  if (sprintActive) {
    sprintFlowGroup.selectAll('*').remove();
    drawSprintFlowArrows();
  }
  updateHulls();
  updateSpotlightPaths();

--- 2026-02-21T09:15:10Z | hub/autarch/internal/icdata/types.go | CONTEXT:unknown ---
OLD: // TokenSummary represents token usage from `ic run tokens --json`.
type TokenSummary struct {
NEW: // Lane represents a thematic work lane from `ic lane list --json`.
type Lane struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	LaneType    string `json:"lane_type"`
	Status      string `json:"status"`
	Description string `json:"description"`
	CreatedAt   int64  `json:"created_at"`
	UpdatedAt   int64  `json:"updated_at"`
}

// LaneVelocity represents starvation data from `ic lane velocity --json`.
type LaneVelocity struct {
	LaneID     string  `json:"lane_id"`
	Name       string  `json:"name"`
	OpenBeads  int     `json:"open_beads"`
	Closed     int     `json:"closed"`
	Throughput float64 `json:"throughput"`
	Starvation float64 `json:"starvation"`
}

// TokenSummary represents token usage from `ic run tokens --json`.
type TokenSummary struct {

--- 2026-02-21T09:15:25Z | hub/autarch/internal/icdata/fetch.go | CONTEXT:unknown ---
OLD: // RunIC executes an `ic` command and returns its stdout.
NEW: // FetchLanes calls `ic lane list --json` to get all lanes.
func FetchLanes(ctx context.Context, projectDir string) ([]Lane, error) {
	out, err := RunIC(ctx, projectDir, "lane", "list", "--json")
	if err != nil {
		return nil, err
	}
	if strings.TrimSpace(out) == "" || strings.TrimSpace(out) == "[]" {
		return nil, nil
	}
	var lanes []Lane
	if err := json.Unmarshal([]byte(out), &lanes); err != nil {
		return nil, fmt.Errorf("parse lanes: %w", err)
	}
	return lanes, nil
}

// FetchLaneVelocity calls `ic lane velocity --json` to get starvation scores.
func FetchLaneVelocity(ctx context.Context, projectDir string) ([]LaneVelocity, error) {
	out, err := RunIC(ctx, projectDir, "lane", "velocity", "--json")
	if err != nil {
		return nil, err
	}
	if strings.TrimSpace(out) == "" || strings.TrimSpace(out) == "[]" {
		return nil, nil
	}
	var velocities []LaneVelocity
	if err := json.Unmarshal([]byte(out), &velocities); err != nil {
		return nil, fmt.Errorf("parse lane velocity: %w", err)
	}
	return velocities, nil
}

// RunIC executes an `ic` command and returns its stdout.

--- 2026-02-21T09:16:04Z | hub/autarch/pkg/tui/lane_pane.go | CONTEXT:unknown ---
OLD: func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
NEW: 

--- 2026-02-21T09:17:23Z | hub/autarch/internal/pollard/cli/scan.go | CONTEXT:unknown ---
OLD: var (
	scanHunter   string
	scanDryRun   bool
	scanPlanMode bool
	scanMode     string // quick, balanced, deep
)
NEW: var (
	scanHunter   string
	scanDryRun   bool
	scanPlanMode bool
	scanMode     string // quick, balanced, deep
	scanLane     string // lane scope for research
)

--- 2026-02-21T09:17:28Z | hub/autarch/internal/pollard/cli/scan.go | CONTEXT:unknown ---
OLD: 		// Check for proposals and suggest if none exist
NEW: 		// Display lane scope if set
		if scanLane != "" {
			fmt.Printf("Lane: %s — scoping research to lane beads\n", scanLane)
		}

		// Check for proposals and suggest if none exist

--- 2026-02-21T09:17:47Z | hub/autarch/internal/pollard/hunters/hunter.go | CONTEXT:unknown ---
OLD: 	// PipelineConfig for fetch/synthesize/score options
	Pipeline PipelineOptions
NEW: 	// LaneScope restricts research to beads in this lane (optional).
	// When set, findings are tagged with the lane for scoped discovery.
	LaneScope string

	// PipelineConfig for fetch/synthesize/score options
	Pipeline PipelineOptions

--- 2026-02-21T09:17:53Z | hub/autarch/internal/pollard/cli/scan.go | CONTEXT:unknown ---
OLD: 		hCfg := hunters.HunterConfig{
				Queries:     hunterCfg.Queries,
				MaxResults:  hunterCfg.MaxResults,
				MinStars:    hunterCfg.MinStars,
				MinPoints:   hunterCfg.MinPoints,
NEW: 		hCfg := hunters.HunterConfig{
				Queries:     hunterCfg.Queries,
				MaxResults:  hunterCfg.MaxResults,
				MinStars:    hunterCfg.MinStars,
				MinPoints:   hunterCfg.MinPoints,
				LaneScope:   scanLane,

--- 2026-02-21T09:17:59Z | hub/autarch/internal/pollard/cli/scan.go | CONTEXT:unknown ---
OLD: 	scanCmd.Flags().StringVar(&scanMode, "mode", "balanced", "Pipeline mode: quick (no synthesis), balanced (sample), deep (all)")
}
NEW: 	scanCmd.Flags().StringVar(&scanMode, "mode", "balanced", "Pipeline mode: quick (no synthesis), balanced (sample), deep (all)")
	scanCmd.Flags().StringVar(&scanLane, "lane", "", "Scope research to beads in this lane (e.g., interop, kernel)")
}

--- 2026-02-21T09:31:40Z | infra/intercore/internal/lane/store.go | CONTEXT:unknown ---
OLD: 	"database/sql"
	"fmt"
	"math/big"
	"time"
NEW: 	"database/sql"
	"errors"
	"fmt"
	"math/big"
	"time"

--- 2026-02-21T09:31:45Z | infra/intercore/internal/lane/store.go | CONTEXT:unknown ---
OLD: 	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("lane not found: %s", id)
	}
	if err != nil {
		return nil, fmt.Errorf("lane get: %w", err)
	}
NEW: 	if errors.Is(err, sql.ErrNoRows) {
		return nil, fmt.Errorf("lane not found: %s", id)
	}
	if err != nil {
		return nil, fmt.Errorf("lane get: %w", err)
	}

--- 2026-02-21T09:31:51Z | infra/intercore/internal/lane/store.go | CONTEXT:unknown ---
OLD: 	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("lane not found: %s", name)
	}
	if err != nil {
		return nil, fmt.Errorf("lane get by name: %w", err)
	}
NEW: 	if errors.Is(err, sql.ErrNoRows) {
		return nil, fmt.Errorf("lane not found: %s", name)
	}
	if err != nil {
		return nil, fmt.Errorf("lane get by name: %w", err)
	}

--- 2026-02-21T09:32:03Z | infra/intercore/internal/lane/store.go | CONTEXT:unknown ---
OLD: 	rows.Close()

	// Build desired set
NEW: 	rows.Close()
	if err := rows.Err(); err != nil {
		return fmt.Errorf("snapshot members: rows: %w", err)
	}

	// Build desired set

--- 2026-02-21T09:32:18Z | infra/intercore/internal/lane/store.go | CONTEXT:unknown ---
OLD: 	if err != nil {
		return fmt.Errorf("lane close event: %w", err)
	}

	return tx.Commit()
}
NEW: 	if err != nil {
		return fmt.Errorf("lane close event: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("lane close: commit: %w", err)
	}
	return nil
}

--- 2026-02-21T09:32:24Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 		if len(members) > 0 {
			fmt.Printf("Beads: %s\n", strings.Join(members, ", "))
NEW: 		if len(members) > 0 {
			fmt.Printf("Members (%d): %s\n", len(members), strings.Join(members, ", "))

--- 2026-02-21T09:32:37Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: func cmdLaneVelocity(ctx context.Context, args []string) int {
	days := 7
	for _, arg := range args {
		if strings.HasPrefix(arg, "--days=") {
			fmt.Sscanf(strings.TrimPrefix(arg, "--days="), "%d", &days)
		}
	}
NEW: func cmdLaneVelocity(ctx context.Context, args []string) int {
	days := 7
	for _, arg := range args {
		if strings.HasPrefix(arg, "--days=") {
			val := strings.TrimPrefix(arg, "--days=")
			n, err := fmt.Sscanf(val, "%d", &days)
			if err != nil || n != 1 {
				fmt.Fprintf(os.Stderr, "ic: lane velocity: invalid --days value: %s\n", val)
				return 3
			}
			if days < 1 {
				fmt.Fprintf(os.Stderr, "ic: lane velocity: --days must be >= 1, got %d\n", days)
				return 3
			}
		}
	}

--- 2026-02-21T09:32:53Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(map[string]string{
			"id":        id,
			"name":      name,
			"lane_type": laneType,
		})
	} else {
NEW: 	if flagJSON {
		if err := json.NewEncoder(os.Stdout).Encode(map[string]string{
			"id":        id,
			"name":      name,
			"lane_type": laneType,
		}); err != nil {
			fmt.Fprintf(os.Stderr, "ic: lane create: encode: %v\n", err)
			return 2
		}
	} else {

--- 2026-02-21T09:32:58Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 		json.NewEncoder(os.Stdout).Encode(items)
	} else {
		if len(lanes) == 0 {
NEW: 		if err := json.NewEncoder(os.Stdout).Encode(items); err != nil {
			fmt.Fprintf(os.Stderr, "ic: lane list: encode: %v\n", err)
			return 2
		}
	} else {
		if len(lanes) == 0 {

--- 2026-02-21T09:33:03Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 		json.NewEncoder(os.Stdout).Encode(out)
	} else {
		fmt.Printf("Lane: %s (%s)\n", l.Name, l.ID)
NEW: 		if err := json.NewEncoder(os.Stdout).Encode(out); err != nil {
			fmt.Fprintf(os.Stderr, "ic: lane status: encode: %v\n", err)
			return 2
		}
	} else {
		fmt.Printf("Lane: %s (%s)\n", l.Name, l.ID)

--- 2026-02-21T09:33:09Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 		json.NewEncoder(os.Stdout).Encode(items)
	} else {
		for _, e := range events {
NEW: 		if err := json.NewEncoder(os.Stdout).Encode(items); err != nil {
			fmt.Fprintf(os.Stderr, "ic: lane events: encode: %v\n", err)
			return 2
		}
	} else {
		for _, e := range events {

--- 2026-02-21T09:33:14Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 		json.NewEncoder(os.Stdout).Encode(map[string]interface{}{
			"lane_id":      l.ID,
			"member_count": len(beadIDs),
		})
	} else {
NEW: 		if err := json.NewEncoder(os.Stdout).Encode(map[string]interface{}{
			"lane_id":      l.ID,
			"member_count": len(beadIDs),
		}); err != nil {
			fmt.Fprintf(os.Stderr, "ic: lane sync: encode: %v\n", err)
			return 2
		}
	} else {

--- 2026-02-21T09:33:18Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 		json.NewEncoder(os.Stdout).Encode(members)
	} else {
NEW: 		if err := json.NewEncoder(os.Stdout).Encode(members); err != nil {
			fmt.Fprintf(os.Stderr, "ic: lane members: encode: %v\n", err)
			return 2
		}
	} else {

--- 2026-02-21T09:33:22Z | infra/intercore/cmd/ic/lane.go | CONTEXT:unknown ---
OLD: 		json.NewEncoder(os.Stdout).Encode(items)
	} else {
		if len(sorted) == 0 {
NEW: 		if err := json.NewEncoder(os.Stdout).Encode(items); err != nil {
			fmt.Fprintf(os.Stderr, "ic: lane velocity: encode: %v\n", err)
			return 2
		}
	} else {
		if len(sorted) == 0 {

--- 2026-02-21T09:33:33Z | hub/autarch/pkg/tui/lane_pane.go | CONTEXT:unknown ---
OLD: import (
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/lipgloss"
)
NEW: import (
	"fmt"
	"strings"
	"unicode/utf8"

	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/lipgloss"
)

--- 2026-02-21T09:33:42Z | hub/autarch/pkg/tui/lane_pane.go | CONTEXT:unknown ---
OLD: // SetSize updates pane dimensions.
func (p *LanePane) SetSize(width, height int) {
	p.width = width
	p.height = height
	p.viewport = viewport.New(width-2, height-1)
	p.viewport.MouseWheelEnabled = true
	p.updateContent()
}
NEW: // SetSize updates pane dimensions.
func (p *LanePane) SetSize(width, height int) {
	if width < 4 || height < 2 {
		return
	}
	p.width = width
	p.height = height
	p.viewport = viewport.New(width-2, height-1)
	p.viewport.MouseWheelEnabled = true
	p.updateContent()
}

--- 2026-02-21T09:33:47Z | hub/autarch/pkg/tui/lane_pane.go | CONTEXT:unknown ---
OLD: // starvationBar renders a 4-char bar visualization of starvation level.
func starvationBar(score float64, width int) string {
	// Normalize: 0-50 maps to 0-4 blocks
NEW: // starvationBar renders a 4-char bar visualization of starvation level.
func starvationBar(score float64, width int) string {
	// Score is unbounded; capped at width blocks for display.

--- 2026-02-21T09:33:52Z | hub/autarch/pkg/tui/lane_pane.go | CONTEXT:unknown ---
OLD: func truncate(s string, max int) string {
	if len(s) <= max {
		return s
	}
	return s[:max-1] + "…"
}
NEW: func truncate(s string, max int) string {
	if utf8.RuneCountInString(s) <= max {
		return s
	}
	runes := []rune(s)
	return string(runes[:max-1]) + "…"
}

--- 2026-02-21T09:34:08Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	if currentVersion >= currentSchemaVersion {
		return nil // already migrated
	}

	// v5 → v6: add new columns for configurable phase chains, token tracking, artifact hashing, budget
	if currentVersion >= 5 {
NEW: 	if currentVersion >= currentSchemaVersion {
		tx.Rollback() // explicit rollback — no work to commit
		return nil    // already migrated
	}

	// v5 → v6: add new columns for configurable phase chains, token tracking, artifact hashing, budget
	if currentVersion >= 5 && currentVersion < 6 {

--- 2026-02-21T15:23:58Z | hub/autarch/CLAUDE.md | CONTEXT:unknown ---
OLD: ## Design Decisions (Do Not Re-Ask)
NEW: ## Concurrency Rules

- Never return pointers to internal mutable state from synchronized methods. `State()` returns deep-copied snapshots via `Clone()`. All types crossing goroutine boundaries need `Clone()` methods.
- Run tests with `-race` flag.

## Bubble Tea Rules

- In parent `Update()` methods, never swallow messages that child views need. Default to fall-through. Only return early for messages exclusively owned by the parent. Error messages must always reach the view layer.
- Never use `[]rune` slicing on ANSI-styled strings for visual-column operations. Use `ansi.Truncate`/`TruncateLeft` from `charmbracelet/x/ansi`. Grep for `[]rune` + `lipgloss.Width` — that combination is always a bug.
- Always subtract chrome dimensions (header, footer, sidebar, padding) from `WindowSizeMsg` before passing to child views. Children must only know about their allocated space. Available Width = Terminal Width - Parent Horizontal Padding.

## Workflow Rules

- Reproduce bugs before planning fixes. Phase 0 (reproduction + failing test) is mandatory before any multi-phase fix plan. If bug cannot be reproduced, document as could-not-reproduce and close.

## Design Decisions (Do Not Re-Ask)

--- 2026-02-21T15:24:11Z | docs/guides/data-integrity-patterns.md | CONTEXT:unknown ---
OLD: ## Detailed Solution Docs

- `docs/solutions/patterns/wal-protocol-completeness-20260216.md`
- `docs/solutions/patterns/guard-fallthrough-null-validation-20260216.md`
NEW: ## Silent JSON Errors in Go

Never use `_ = json.Marshal/Unmarshal`. Write paths: fail hard (return error). Read paths: log warning with entity ID, continue with zero value. Grep for `_ = json.` as a CI check. Wrap multi-table materializations in transactions.

```go
// WRONG: silent data corruption
_ = json.Unmarshal(row, &entity)

// RIGHT: fail on writes, log on reads
if err := json.Unmarshal(row, &entity); err != nil {
    log.Printf("warning: corrupt JSON for entity %s: %v", id, err)
    // continue with zero value on reads; return err on writes
}
```

## Detailed Solution Docs

- `docs/solutions/patterns/wal-protocol-completeness-20260216.md`
- `docs/solutions/patterns/guard-fallthrough-null-validation-20260216.md`
- `services/intermute/docs/solutions/database-issues/silent-json-errors-sqlite-storage-20260211.md`

--- 2026-02-21T15:26:11Z | os/clavain/AGENTS.md | CONTEXT:unknown ---
OLD: - **workflow/** — Process automation (2): PR comments, bug reproduction

### Commands
NEW: - **workflow/** — Process automation (2): PR comments, bug reproduction

### Renaming/Deleting Agents

Grep sweep checklist (10 locations): `agents/*/`, `skills/*/SKILL.md`, `commands/*.md`, `hooks/*.sh`, `hooks/lib-*.sh`, `plugin.json`, `CLAUDE.md`, `AGENTS.md`, dispatch templates, test fixtures. Do NOT update historical records (solution docs, sprint logs).

### Commands

--- 2026-02-21T15:26:41Z | docs/guides/shell-and-tooling-patterns.md | CONTEXT:unknown ---
OLD: ## Detailed Solution Docs

- `docs/solutions/patterns/set-e-with-fallback-paths-20260216.md`
- `docs/solutions/runtime-errors/jq-null-slice-from-empty-string-return-clavain-20260216.md`
- `docs/solutions/workflow-issues/bd-sync-from-main-trunk-based-20260216.md`
NEW: ## awk `sub()` $0 Mutation

In awk, `sub()`/`gsub()` modify `$0` in-place. All subsequent pattern rules in the same program evaluate against the modified `$0`. Always add `next` after a rule that modifies `$0` if later rules check `$0` patterns.

```awk
# WRONG — Rule 2 fires on the same line because sub() changed $0
found && /^  - / { sub(/^  - */, ""); items = items "," $0 }
found && !/^  - / { exit }  # Fires immediately — modified $0 no longer matches ^  -

# RIGHT — next prevents Rule 2 from seeing the modified line
found && /^  - / { sub(/^  - */, ""); items = items "," $0; next }
found && !/^  - / { exit }
```

## Beads Daemon Stale Startlock

If `bd` commands hang, the daemon startlock is stale. One-liner fix:

```bash
kill $(cat .beads/daemon.pid 2>/dev/null) 2>/dev/null; rm -f .beads/bd.sock .beads/bd.sock.startlock .beads/daemon.pid .beads/daemon.lock
```

Common after force-killed sessions or network disconnects.

## Detailed Solution Docs

- `docs/solutions/patterns/set-e-with-fallback-paths-20260216.md`
- `docs/solutions/runtime-errors/jq-null-slice-from-empty-string-return-clavain-20260216.md`
- `docs/solutions/workflow-issues/bd-sync-from-main-trunk-based-20260216.md`
- `plugins/interlearn/docs/solutions/patterns/awk-sub-pattern-fallthrough-20260221.md`
- `plugins/tldr-swinton/docs/solutions/workflow-issues/bd-commands-hang-stale-startlock-20260213.md`

--- 2026-02-21T15:27:00Z | docs/guides/multi-agent-coordination.md | CONTEXT:unknown ---
OLD: ## Detailed Solution Docs

- `docs/solutions/patterns/synthesis-subagent-context-isolation-20260216.md`
- `docs/solutions/patterns/token-accounting-billing-vs-context-20260216.md`
NEW: ## Advisory-Only Enforcement Pattern

Convert background state-mutating actors to read-only observers. Push mutation to the edges — let the state owner make explicit decisions. Read-only code cannot race. This eliminates an entire class of TOCTOU bugs by ensuring concurrent actors never write to shared state directly.

Applied in interlock: `CheckExpiredNegotiations` is advisory-only — it reports expired negotiations but does NOT force-release, letting the state owner (the holding agent) decide.

## Post-Parallel Quality Gates

After parallel agent implementation, always run quality gates with the **full unified diff** — not individual agent diffs. Schema consistency is a cross-cutting concern that no single implementing agent owns. A unified diff catches:
- Conflicting field renames across files
- Missing imports or type updates from adjacent changes
- Interface/contract violations that only surface when all changes are combined

## Detailed Solution Docs

- `docs/solutions/patterns/synthesis-subagent-context-isolation-20260216.md`
- `docs/solutions/patterns/token-accounting-billing-vs-context-20260216.md`
- `plugins/interlock/docs/solutions/2026-02-16-advisory-only-timeout-eliminates-toctou.md`
- `plugins/tldr-swinton/docs/solutions/best-practices/parallel-agents-miss-cross-cutting-schema-bugs.md`

--- 2026-02-21T15:27:15Z | docs/guides/plugin-troubleshooting.md | CONTEXT:unknown ---
OLD: ## Detailed Solution Docs

For full incident investigations and root cause analysis:
NEW: ## Ghost Plugin Entries

Renamed plugins leave ghost entries in `enabledPlugins` (settings.json) and cache dirs. Worst case: old name in settings.json causes failed-to-load every session.

**Fix:**
1. Remove stale key from `~/.claude/settings.json` → `enabledPlugins`
2. Delete cache dir: `rm -rf ~/.claude/plugins/cache/interagency-marketplace/<old-name>`
3. Reinstall under new name: `claude plugins install <new-name>@interagency-marketplace`

**Detection:** If `/plugin` shows error counts at session start and you recently renamed a plugin, check for ghost entries first.

## Detailed Solution Docs

For full incident investigations and root cause analysis:

--- 2026-02-21T15:27:58Z | hub/autarch/AGENTS.md | CONTEXT:unknown ---
OLD: ### Debugging

**Before debugging, check solutions:**
NEW: ### TUI Design Principles

Chat is the primary input surface. Typing safety: no single-key shortcuts that fire during text entry. Discoverability via slash commands. Ctrl+ only for shortcuts. Minimal modes (avoid vim-style modal traps).

### Coding Standards (from Oracle Review)

- Use phase constants, not integer literals, for array indices.
- Focus-aware keyboard routing: switch on `shell.Focus()`, not `component.Focused()`.
- Error observability: non-fatal errors log to stderr with `warning:` prefix. Never silently swallow errors.

### TUI Input Patterns

- Shell layout owns focus state — use `shell.Focus()` not `component.Focused()` for routing decisions.
- Use `msg.String()` for key matching instead of `key.Matches()` for raw key events.
- Avoid Ctrl+J (= LF/Enter in terminals).

### Spec Phase Ordering

Canonical order: Vision > Problem > Users > Features > CUJs > Requirements > Scope > Acceptance. Ordering must reflect information dependencies — later phases consume earlier phase outputs.

### Debugging

**Before debugging, check solutions:**

--- 2026-02-21T15:37:03Z | plugins/interphase/hooks/lib-discovery.sh | CONTEXT:unknown ---
OLD: # ─── Scanner ──────────────────────────────────────────────────────────

# Scan open beads and rank by priority then recency.
NEW: # ─── Parent-Closed Detection ─────────────────────────────────────────

# Build a lookup table of open beads whose parent epic is closed.
# Output: newline-delimited "child_id:parent_epic_id" pairs.
# Performs a batch pre-scan: O(closed_epics), not O(open_beads).
# Fails silently — returns empty output on any error.
_discovery_build_stale_parent_map() {
    local closed_epics
    closed_epics=$(bd list --status=closed --type=epic --json 2>/dev/null) || { echo ""; return 0; }

    local epic_ids
    epic_ids=$(echo "$closed_epics" | jq -r '.[].id' 2>/dev/null) || { echo ""; return 0; }

    local epic_id
    for epic_id in $epic_ids; do
        [[ -z "$epic_id" ]] && continue
        local children
        children=$(bd dep list "$epic_id" --direction=up --type=parent-child --json 2>/dev/null) || continue
        local open_child_ids
        open_child_ids=$(echo "$children" | jq -r '.[] | select(.status == "open" or .status == "in_progress") | .id' 2>/dev/null) || continue
        local child_id
        for child_id in $open_child_ids; do
            [[ -z "$child_id" ]] && continue
            echo "${child_id}:${epic_id}"
        done
    done
}

# ─── Scanner ──────────────────────────────────────────────────────────

# Scan open beads and rank by priority then recency.

--- 2026-02-21T15:37:09Z | plugins/interphase/hooks/lib-discovery.sh | CONTEXT:unknown ---
OLD:     local i=0
    while [[ $i -lt $count ]]; do
NEW:     # Build parent-closed lookup table (batch pre-scan, O(closed_epics))
    declare -A _stale_parent_map
    local _spm_line
    while IFS= read -r _spm_line; do
        [[ -z "$_spm_line" ]] && continue
        local _spm_child="${_spm_line%%:*}"
        local _spm_parent="${_spm_line#*:}"
        _stale_parent_map["$_spm_child"]="$_spm_parent"
    done < <(_discovery_build_stale_parent_map)

    local i=0
    while [[ $i -lt $count ]]; do

--- 2026-02-21T15:37:22Z | plugins/interphase/hooks/lib-discovery.sh | CONTEXT:unknown ---
OLD:         # Skip if essential fields missing
        if [[ -z "$id" || -z "$status" ]]; then
            i=$((i + 1))
            continue
        fi

        # Read phase for this bead (F8: phase-aware scoring)
        # TODO(performance): phase_get is O(n) subprocess calls. For >50 beads,
        # consider caching phase state in /tmp/clavain-phase-cache-${session_id}.json
        local phase=""
        if command -v phase_get &>/dev/null; then
            phase=$(phase_get "$id" 2>/dev/null) || phase=""
        fi

        # Infer action via filesystem scan (now phase-aware)
        local action_result action plan_path
        action_result=$(infer_bead_action "$id" "$status")
        action="${action_result%%|*}"
        plan_path="${action_result#*|}"
NEW:         # Skip if essential fields missing
        if [[ -z "$id" || -z "$status" ]]; then
            i=$((i + 1))
            continue
        fi

        # Parent-closed check: if this bead's parent epic is closed, flag it
        local parent_closed_epic="${_stale_parent_map[$id]:-}"

        # Read phase for this bead (F8: phase-aware scoring)
        # TODO(performance): phase_get is O(n) subprocess calls. For >50 beads,
        # consider caching phase state in /tmp/clavain-phase-cache-${session_id}.json
        local phase=""
        if command -v phase_get &>/dev/null; then
            phase=$(phase_get "$id" 2>/dev/null) || phase=""
        fi

        # Infer action — short-circuit to verify_done if parent epic is closed
        local action_result action plan_path
        if [[ -n "$parent_closed_epic" ]]; then
            action="verify_done"
            plan_path=""
        else
            action_result=$(infer_bead_action "$id" "$status")
            action="${action_result%%|*}"
            plan_path="${action_result#*|}"
        fi

--- 2026-02-21T15:37:28Z | plugins/interphase/hooks/lib-discovery.sh | CONTEXT:unknown ---
OLD:         # Multi-factor score (F8)
        local score
        score=$(score_bead "$priority" "$phase" "$updated" "$stale")

        # Append to results with phase and score fields
NEW:         # Multi-factor score (F8)
        local score
        score=$(score_bead "$priority" "$phase" "$updated" "$stale")

        # Closed-parent penalty: push stale-parent beads to bottom of ranking
        if [[ -n "$parent_closed_epic" ]]; then
            score=$((score - 30))
        fi

        # Append to results with phase and score fields

--- 2026-02-21T15:37:35Z | plugins/interphase/hooks/lib-discovery.sh | CONTEXT:unknown ---
OLD:         results=$(echo "$results" | jq \
            --arg id "$id" \
            --arg title "$title" \
            --argjson priority "${priority:-4}" \
            --arg status "$status" \
            --arg action "$action" \
            --arg plan_path "$plan_path" \
            --argjson stale "$stale" \
            --arg phase "$phase" \
            --argjson score "${score:-0}" \
            '. + [{id: $id, title: $title, priority: $priority, status: $status, action: $action, plan_path: $plan_path, stale: $stale, phase: $phase, score: $score}]')
NEW:         results=$(echo "$results" | jq \
            --arg id "$id" \
            --arg title "$title" \
            --argjson priority "${priority:-4}" \
            --arg status "$status" \
            --arg action "$action" \
            --arg plan_path "$plan_path" \
            --argjson stale "$stale" \
            --arg phase "$phase" \
            --argjson score "${score:-0}" \
            --arg parent_closed_epic "${parent_closed_epic:-}" \
            '. + [{id: $id, title: $title, priority: $priority, status: $status, action: $action, plan_path: $plan_path, stale: $stale, phase: $phase, score: $score, parent_closed_epic: (if $parent_closed_epic == "" then null else $parent_closed_epic end)}]')

--- 2026-02-21T15:37:56Z | os/clavain/commands/sprint.md | CONTEXT:unknown ---
OLD:    - Action verbs: continue → "Continue", execute → "Execute plan for", plan → "Plan", strategize → "Strategize", brainstorm → "Brainstorm", ship → "Ship", closed → "Closed", create_bead → "Link orphan:"
NEW:    - Action verbs: continue → "Continue", execute → "Execute plan for", plan → "Plan", strategize → "Strategize", brainstorm → "Brainstorm", ship → "Ship", closed → "Closed", create_bead → "Link orphan:", verify_done → "Verify (parent closed):"
   - **Stale-parent entries** (action: "verify_done"): Label format: `"Verify (parent closed): <bead-id> — <title> (P<priority>, parent: <parent_closed_epic>)"`. These are beads whose parent epic is closed — they may already be complete.

--- 2026-02-21T15:38:04Z | os/clavain/commands/sprint.md | CONTEXT:unknown ---
OLD:    - `closed` → Tell user "This bead is already done" and re-run discovery
NEW:    - `closed` → Tell user "This bead is already done" and re-run discovery
   - `verify_done` → Parent epic is closed. Tell user: "Parent epic <parent_closed_epic> is closed. This bead may already be complete." Then AskUserQuestion with options:
     1. "Close this bead (work is done)" → `bd close <id> --reason="Completed as part of parent <parent_closed_epic>"`
     2. "Review code before closing" → Read the bead description and relevant source files, then re-ask
     3. "Cascade-close all siblings" → Run `bd-cascade-close <parent_closed_epic>` to close all open children of the parent epic

--- 2026-02-21T15:38:44Z | plugins/interphase/tests/shell/discovery.bats | CONTEXT:unknown ---
OLD:     # Executing bead should rank first (higher phase score)
    local first_id
    first_id=$(echo "$output" | jq -r '.[0].id')
    [[ "$first_id" == "Test-exec" ]]
}
NEW:     # Executing bead should rank first (higher phase score)
    local first_id
    first_id=$(echo "$output" | jq -r '.[0].id')
    [[ "$first_id" == "Test-exec" ]]
}

# ─── Parent-Closed Detection ─────────────────────────────────────────

# Mock bd that also handles closed epic queries and dep list
mock_bd_with_closed_parent() {
    local open_json="${1:-[]}"
    local ip_json="${2:-[]}"
    export MOCK_BD_JSON="$open_json"
    export MOCK_BD_IP_JSON="$ip_json"
    bd() {
        if [[ "$1" == "list" ]]; then
            if [[ "$*" == *"--type=epic"*"--status=closed"* ]] || [[ "$*" == *"--status=closed"*"--type=epic"* ]]; then
                echo '[{"id":"Test-epic1","title":"Done epic","status":"closed","issue_type":"epic"}]'
                return 0
            fi
            if [[ "$*" == *"--status=in_progress"* ]]; then
                echo "$MOCK_BD_IP_JSON"
            else
                echo "$MOCK_BD_JSON"
            fi
            return 0
        fi
        if [[ "$1" == "dep" && "$2" == "list" ]]; then
            if [[ "$3" == "Test-epic1" ]]; then
                echo '[{"id":"Test-orphan1","title":"Orphaned child","status":"open","dependency_type":"parent-child"}]'
                return 0
            fi
            echo '[]'
            return 0
        fi
        if [[ "$1" == "show" ]]; then
            return 0
        fi
        return 1
    }
    export -f bd
}

@test "discovery: bead with closed parent gets action=verify_done" {
    local recent_iso
    recent_iso=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)

    mock_bd_with_closed_parent \
        "[{\"id\":\"Test-orphan1\",\"title\":\"Orphaned child\",\"status\":\"open\",\"priority\":2,\"updated_at\":\"${recent_iso}\"}]"

    run discovery_scan_beads
    assert_success

    local action
    action=$(echo "$output" | jq -r '.[0].action')
    [[ "$action" == "verify_done" ]]
}

@test "discovery: bead with closed parent gets -30 score penalty" {
    local recent_iso
    recent_iso=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)

    # Test with closed parent
    mock_bd_with_closed_parent \
        "[{\"id\":\"Test-orphan1\",\"title\":\"Orphaned child\",\"status\":\"open\",\"priority\":2,\"updated_at\":\"${recent_iso}\"}]"
    run discovery_scan_beads
    assert_success
    local penalized_score
    penalized_score=$(echo "$output" | jq '.[0].score')

    # Test same bead without closed parent
    mock_bd \
        "[{\"id\":\"Test-orphan1\",\"title\":\"Orphaned child\",\"status\":\"open\",\"priority\":2,\"updated_at\":\"${recent_iso}\"}]"
    run discovery_scan_beads
    assert_success
    local normal_score
    normal_score=$(echo "$output" | jq '.[0].score')

    # Penalized score should be 30 less
    [[ $((normal_score - penalized_score)) -eq 30 ]]
}

@test "discovery: bead with closed parent includes parent_closed_epic field" {
    local recent_iso
    recent_iso=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)

    mock_bd_with_closed_parent \
        "[{\"id\":\"Test-orphan1\",\"title\":\"Orphaned child\",\"status\":\"open\",\"priority\":2,\"updated_at\":\"${recent_iso}\"}]"

    run discovery_scan_beads
    assert_success

    local parent
    parent=$(echo "$output" | jq -r '.[0].parent_closed_epic')
    [[ "$parent" == "Test-epic1" ]]
}

@test "discovery: bead without closed parent uses normal action" {
    local recent_iso
    recent_iso=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)

    mock_bd \
        "[{\"id\":\"Test-normal1\",\"title\":\"Normal bead\",\"status\":\"open\",\"priority\":2,\"updated_at\":\"${recent_iso}\"}]"

    run discovery_scan_beads
    assert_success

    local action parent
    action=$(echo "$output" | jq -r '.[0].action')
    parent=$(echo "$output" | jq -r '.[0].parent_closed_epic')
    [[ "$action" != "verify_done" ]]
    [[ "$parent" == "null" ]]
}

@test "discovery: stale parent map empty when no closed epics" {
    # Mock bd with no closed epics
    bd() {
        if [[ "$1" == "list" ]]; then
            if [[ "$*" == *"--type=epic"*"--status=closed"* ]] || [[ "$*" == *"--status=closed"*"--type=epic"* ]]; then
                echo '[]'
                return 0
            fi
            if [[ "$*" == *"--status=in_progress"* ]]; then
                echo '[]'
            else
                echo '[{"id":"Test-ok1","title":"Normal","status":"open","priority":2,"updated_at":"2026-02-12T10:00:00Z"}]'
            fi
            return 0
        fi
        return 1
    }
    export -f bd

    run discovery_scan_beads
    assert_success

    local action
    action=$(echo "$output" | jq -r '.[0].action')
    [[ "$action" != "verify_done" ]]
}

@test "discovery: stale parent check graceful when bd dep list fails" {
    local recent_iso
    recent_iso=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)

    # Mock bd where dep list always fails
    bd() {
        if [[ "$1" == "list" ]]; then
            if [[ "$*" == *"--type=epic"*"--status=closed"* ]] || [[ "$*" == *"--status=closed"*"--type=epic"* ]]; then
                echo '[{"id":"Test-epic1","title":"Done","status":"closed","issue_type":"epic"}]'
                return 0
            fi
            if [[ "$*" == *"--status=in_progress"* ]]; then
                echo '[]'
            else
                echo "[{\"id\":\"Test-child1\",\"title\":\"Child\",\"status\":\"open\",\"priority\":2,\"updated_at\":\"${recent_iso}\"}]"
            fi
            return 0
        fi
        if [[ "$1" == "dep" ]]; then
            return 1  # dep list fails
        fi
        return 1
    }
    export -f bd

    run discovery_scan_beads
    assert_success

    # Should still work — child just won't be flagged as verify_done
    local action
    action=$(echo "$output" | jq -r '.[0].action')
    [[ "$action" != "verify_done" ]]
}

--- 2026-02-21T16:40:37Z | os/clavain/config/routing.yaml | CONTEXT:unknown ---
OLD: # Model routing policy for Clavain (Track B1: Static Routing Table)
#
# Two namespaces:
#   subagents: Claude Code agents (haiku/sonnet/opus/inherit)
#   dispatch:  Codex CLI agents (concrete model IDs)
#
# Subagent resolution order (highest priority first):
#   overrides[agent] > phases[phase].categories[cat] > phases[phase].model > defaults.categories[cat] > defaults.model
#
# Dispatch resolution:
#   tiers[name].model, with fallback chain if tier not found
#
# When this file is absent, all consumers fall back to their existing defaults.
NEW: # Model routing policy for Clavain (Track B1+B2: Static + Complexity-Aware Routing)
#
# Three namespaces:
#   subagents:   Claude Code agents (haiku/sonnet/opus/inherit)
#   dispatch:    Codex CLI agents (concrete model IDs)
#   complexity:  Task complexity → model override layer (B2)
#
# Subagent resolution order (highest priority first):
#   complexity override (if enabled+matching) > overrides[agent] > phases[phase].categories[cat] > phases[phase].model > defaults.categories[cat] > defaults.model
#
# Dispatch resolution:
#   complexity tier promotion/demotion (if enabled) > tiers[name].model, with fallback chain
#
# When this file is absent, all consumers fall back to their existing defaults.

--- 2026-02-21T16:40:54Z | os/clavain/config/routing.yaml | CONTEXT:unknown ---
OLD:   # Fallback if a tier is unavailable (API returns model_not_found)
  fallback:
    fast: deep
    fast-clavain: deep-clavain
    deep-clavain: deep
NEW:   # Fallback if a tier is unavailable (API returns model_not_found)
  fallback:
    fast: deep
    fast-clavain: deep-clavain
    deep-clavain: deep

# Complexity-aware routing (Track B2)
#
# When enabled, task complexity signals (token count, file scope, reasoning depth)
# classify each task into a tier (C1-C5). Tiers can override the base model selection
# from subagents: and promote/demote dispatch tiers.
#
# mode:
#   off     — Zero-cost bypass. Complexity section is not parsed. (default)
#   shadow  — Classify and log what *would* change, but apply base routing.
#   enforce — Classify and apply complexity overrides.
#
# Zero-cost guarantee: when mode=off, routing_resolve_model behaves identically
# to B1 with no extra function calls, no config parsing, no overhead.
complexity:
  mode: off

  # Classification thresholds — a task's complexity tier is the highest tier
  # whose ANY threshold is met. Evaluated top-down (C5 first).
  # Signals: prompt_tokens (int), file_count (int), reasoning_depth (1-5 scale)
  tiers:
    C5:
      description: Architectural — multi-system design, novel algorithms, cross-cutting concerns
      prompt_tokens: 4000
      file_count: 15
      reasoning_depth: 5
    C4:
      description: Complex — multi-file implementation, significant refactoring
      prompt_tokens: 2000
      file_count: 8
      reasoning_depth: 4
    C3:
      description: Moderate — single-component feature, standard patterns
      prompt_tokens: 800
      file_count: 4
      reasoning_depth: 3
    C2:
      description: Simple — focused change, well-understood scope
      prompt_tokens: 300
      file_count: 2
      reasoning_depth: 2
    C1:
      description: Trivial — typo fix, config tweak, single-line change
      prompt_tokens: 0
      file_count: 0
      reasoning_depth: 1

  # Per-tier model overrides. These layer on TOP of base B1 resolution.
  # Only specified fields override; unspecified fields inherit from B1.
  # "inherit" means "use B1 result" (explicit passthrough).
  overrides:
    C5:
      subagent_model: opus
      dispatch_tier: deep
    C4:
      subagent_model: opus
      dispatch_tier: deep
    C3:
      subagent_model: inherit
      dispatch_tier: inherit
    C2:
      subagent_model: haiku
      dispatch_tier: fast
    C1:
      subagent_model: haiku
      dispatch_tier: fast

--- 2026-02-21T16:41:14Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD: #!/usr/bin/env bash
# lib-routing.sh — Read config/routing.yaml and resolve model tiers.
# Source this file; do not execute directly.
#
# Public API:
#   routing_resolve_model --phase <phase> [--category <cat>] [--agent <name>]
#   routing_resolve_dispatch_tier <tier-name>
#   routing_list_mappings
NEW: #!/usr/bin/env bash
# lib-routing.sh — Read config/routing.yaml and resolve model tiers.
# Source this file; do not execute directly.
#
# Public API (B1 — static routing):
#   routing_resolve_model --phase <phase> [--category <cat>] [--agent <name>]
#   routing_resolve_dispatch_tier <tier-name>
#   routing_list_mappings
#
# Public API (B2 — complexity-aware routing):
#   routing_classify_complexity --prompt-tokens <n> [--file-count <n>] [--reasoning-depth <n>]
#   routing_resolve_model_complex --complexity <tier> [--phase ...] [--category ...] [--agent ...]
#   routing_resolve_dispatch_tier_complex --complexity <tier> <tier-name>

--- 2026-02-21T16:41:21Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD: declare -g _ROUTING_CONFIG_PATH=""
declare -g _ROUTING_CACHE_POPULATED=""
NEW: declare -g _ROUTING_CONFIG_PATH=""
declare -g _ROUTING_CACHE_POPULATED=""

# --- B2: Complexity cache ---
declare -g _ROUTING_CX_MODE=""                  # off | shadow | enforce
declare -gA _ROUTING_CX_PROMPT_TOKENS=()       # [C1..C5]=threshold
declare -gA _ROUTING_CX_FILE_COUNT=()           # [C1..C5]=threshold
declare -gA _ROUTING_CX_REASONING_DEPTH=()      # [C1..C5]=threshold
declare -gA _ROUTING_CX_DESC=()                 # [C1..C5]=description
declare -gA _ROUTING_CX_SUBAGENT_MODEL=()       # [C1..C5]=model|inherit
declare -gA _ROUTING_CX_DISPATCH_TIER=()        # [C1..C5]=tier|inherit

--- 2026-02-21T16:41:27Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD:   # State machine for line-by-line YAML parsing (max 3 levels)
  local section=""        # subagents | dispatch
  local subsection=""     # defaults | phases | overrides | tiers | fallback
  local current_phase=""
  local in_categories=""  # true when inside a categories: block
  local current_tier=""
NEW:   # State machine for line-by-line YAML parsing (max 3 levels)
  local section=""        # subagents | dispatch | complexity
  local subsection=""     # defaults | phases | overrides | tiers | fallback | cx_tiers | cx_overrides
  local current_phase=""
  local in_categories=""  # true when inside a categories: block
  local current_tier=""
  local current_cx_tier=""  # B2: current complexity tier being parsed

--- 2026-02-21T16:41:33Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD:     if [[ "$line" =~ ^dispatch: ]]; then
      section="dispatch"; subsection=""; current_phase=""; in_categories=""; current_tier=""
      continue
    fi
    # Another top-level key — reset
    if [[ "$line" =~ ^[a-z] ]]; then
      section=""; subsection=""
      continue
    fi
NEW:     if [[ "$line" =~ ^dispatch: ]]; then
      section="dispatch"; subsection=""; current_phase=""; in_categories=""; current_tier=""
      continue
    fi
    if [[ "$line" =~ ^complexity: ]]; then
      section="complexity"; subsection=""; current_cx_tier=""
      continue
    fi
    # Another top-level key — reset
    if [[ "$line" =~ ^[a-z] ]]; then
      section=""; subsection=""
      continue
    fi

--- 2026-02-21T16:41:49Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD:       # --- fallback ---
      if [[ "$subsection" == "fallback" ]]; then
        if [[ "$line" =~ ^[[:space:]]{4}([a-z][a-z0-9_-]*):[[:space:]]*(.+) ]]; then
          local fb_tier="${BASH_REMATCH[1]}"
          local fb_val="${BASH_REMATCH[2]%%[[:space:]#]*}"
          _ROUTING_DISPATCH_FALLBACK["$fb_tier"]="$fb_val"
          continue
        fi
      fi
    fi
  done < "$_ROUTING_CONFIG_PATH"
NEW:       # --- fallback ---
      if [[ "$subsection" == "fallback" ]]; then
        if [[ "$line" =~ ^[[:space:]]{4}([a-z][a-z0-9_-]*):[[:space:]]*(.+) ]]; then
          local fb_tier="${BASH_REMATCH[1]}"
          local fb_val="${BASH_REMATCH[2]%%[[:space:]#]*}"
          _ROUTING_DISPATCH_FALLBACK["$fb_tier"]="$fb_val"
          continue
        fi
      fi
    fi

    # --- complexity section (B2) ---
    if [[ "$section" == "complexity" ]]; then
      # mode: off|shadow|enforce (2-space indent)
      if [[ "$line" =~ ^[[:space:]]{2}mode:[[:space:]]*(.+) ]]; then
        _ROUTING_CX_MODE="${BASH_REMATCH[1]%%[[:space:]#]*}"
        continue
      fi
      # tiers: subsection
      if [[ "$line" =~ ^[[:space:]]{2}tiers: ]]; then
        subsection="cx_tiers"; current_cx_tier=""
        continue
      fi
      # overrides: subsection
      if [[ "$line" =~ ^[[:space:]]{2}overrides: ]]; then
        subsection="cx_overrides"; current_cx_tier=""
        continue
      fi

      # --- complexity tiers ---
      if [[ "$subsection" == "cx_tiers" ]]; then
        # Tier name (4-space indent, e.g. "    C5:")
        if [[ "$line" =~ ^[[:space:]]{4}(C[1-5]):[[:space:]]*$ ]]; then
          current_cx_tier="${BASH_REMATCH[1]}"
          continue
        fi
        if [[ -n "$current_cx_tier" ]]; then
          if [[ "$line" =~ ^[[:space:]]{6}description:[[:space:]]*(.+) ]]; then
            _ROUTING_CX_DESC["$current_cx_tier"]="${BASH_REMATCH[1]%%[[:space:]#]*}"
            continue
          fi
          if [[ "$line" =~ ^[[:space:]]{6}prompt_tokens:[[:space:]]*([0-9]+) ]]; then
            _ROUTING_CX_PROMPT_TOKENS["$current_cx_tier"]="${BASH_REMATCH[1]}"
            continue
          fi
          if [[ "$line" =~ ^[[:space:]]{6}file_count:[[:space:]]*([0-9]+) ]]; then
            _ROUTING_CX_FILE_COUNT["$current_cx_tier"]="${BASH_REMATCH[1]}"
            continue
          fi
          if [[ "$line" =~ ^[[:space:]]{6}reasoning_depth:[[:space:]]*([1-5]) ]]; then
            _ROUTING_CX_REASONING_DEPTH["$current_cx_tier"]="${BASH_REMATCH[1]}"
            continue
          fi
        fi
      fi

      # --- complexity overrides ---
      if [[ "$subsection" == "cx_overrides" ]]; then
        # Tier name (4-space indent)
        if [[ "$line" =~ ^[[:space:]]{4}(C[1-5]):[[:space:]]*$ ]]; then
          current_cx_tier="${BASH_REMATCH[1]}"
          continue
        fi
        if [[ -n "$current_cx_tier" ]]; then
          if [[ "$line" =~ ^[[:space:]]{6}subagent_model:[[:space:]]*(.+) ]]; then
            _ROUTING_CX_SUBAGENT_MODEL["$current_cx_tier"]="${BASH_REMATCH[1]%%[[:space:]#]*}"
            continue
          fi
          if [[ "$line" =~ ^[[:space:]]{6}dispatch_tier:[[:space:]]*(.+) ]]; then
            _ROUTING_CX_DISPATCH_TIER["$current_cx_tier"]="${BASH_REMATCH[1]%%[[:space:]#]*}"
            continue
          fi
        fi
      fi
    fi
  done < "$_ROUTING_CONFIG_PATH"

--- 2026-02-21T16:42:16Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD: # --- Public: resolve dispatch tier to model ---
routing_resolve_dispatch_tier() {
NEW: # --- Public (B2): classify task complexity → C1..C5 ---
# Returns the highest complexity tier whose ANY threshold is met.
# Evaluates top-down (C5 first). Returns empty string if complexity is off.
routing_classify_complexity() {
  _routing_load_cache

  # Zero-cost bypass: if mode is off or not set, return immediately
  if [[ "${_ROUTING_CX_MODE:-off}" == "off" ]]; then
    return 0
  fi

  local prompt_tokens=0 file_count=0 reasoning_depth=1
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --prompt-tokens)    prompt_tokens="$2"; shift 2 ;;
      --file-count)       file_count="$2"; shift 2 ;;
      --reasoning-depth)  reasoning_depth="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  # Evaluate top-down: C5, C4, C3, C2, C1
  local tier
  for tier in C5 C4 C3 C2 C1; do
    local thresh_pt="${_ROUTING_CX_PROMPT_TOKENS[$tier]:-}"
    local thresh_fc="${_ROUTING_CX_FILE_COUNT[$tier]:-}"
    local thresh_rd="${_ROUTING_CX_REASONING_DEPTH[$tier]:-}"

    # Skip tiers with no thresholds defined
    [[ -z "$thresh_pt" && -z "$thresh_fc" && -z "$thresh_rd" ]] && continue

    # ANY threshold met → this tier matches
    if [[ -n "$thresh_pt" && "$prompt_tokens" -ge "$thresh_pt" ]]; then
      echo "$tier"; return 0
    fi
    if [[ -n "$thresh_fc" && "$file_count" -ge "$thresh_fc" ]]; then
      echo "$tier"; return 0
    fi
    if [[ -n "$thresh_rd" && "$reasoning_depth" -ge "$thresh_rd" ]]; then
      echo "$tier"; return 0
    fi
  done

  # No tier matched — default to C1 (lowest)
  echo "C1"
  return 0
}

# --- Public (B2): resolve subagent model with complexity override ---
# Wraps routing_resolve_model with complexity tier overrides.
# In shadow mode: resolves both, logs difference to stderr, returns base result.
# In enforce mode: returns complexity-overridden result.
# When complexity is off or tier is empty: delegates directly to routing_resolve_model.
routing_resolve_model_complex() {
  _routing_load_cache

  local complexity="" phase="" category="" agent=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --complexity) complexity="$2"; shift 2 ;;
      --phase)      phase="$2"; shift 2 ;;
      --category)   category="$2"; shift 2 ;;
      --agent)      agent="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  # Build args for base resolver
  local base_args=()
  [[ -n "$phase" ]]    && base_args+=(--phase "$phase")
  [[ -n "$category" ]] && base_args+=(--category "$category")
  [[ -n "$agent" ]]    && base_args+=(--agent "$agent")

  # Get base B1 result
  local base_result
  base_result="$(routing_resolve_model "${base_args[@]+"${base_args[@]}"}")"

  # Zero-cost bypass: no complexity tier or mode is off
  if [[ -z "$complexity" || "${_ROUTING_CX_MODE:-off}" == "off" ]]; then
    [[ -n "$base_result" ]] && echo "$base_result"
    return 0
  fi

  # Look up complexity override for subagent model
  local cx_model="${_ROUTING_CX_SUBAGENT_MODEL[$complexity]:-}"
  local final_result="$base_result"

  if [[ -n "$cx_model" && "$cx_model" != "inherit" ]]; then
    final_result="$cx_model"
  fi

  # Shadow mode: log but return base result
  if [[ "${_ROUTING_CX_MODE}" == "shadow" ]]; then
    if [[ "$final_result" != "$base_result" ]]; then
      echo "[B2-shadow] complexity=$complexity would change model: $base_result → $final_result (phase=$phase category=$category)" >&2
    fi
    [[ -n "$base_result" ]] && echo "$base_result"
    return 0
  fi

  # Enforce mode: return overridden result
  # Guard: never return "inherit"
  [[ "$final_result" == "inherit" ]] && final_result="$base_result"
  [[ -n "$final_result" ]] && echo "$final_result"
  return 0
}

# --- Public (B2): resolve dispatch tier with complexity override ---
# In enforce mode, complexity tier can promote/demote the dispatch tier.
# In shadow mode, logs what would change. When off, delegates to base.
routing_resolve_dispatch_tier_complex() {
  _routing_load_cache

  local complexity="" tier=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --complexity) complexity="$2"; shift 2 ;;
      *) [[ -z "$tier" ]] && tier="$1"; shift ;;
    esac
  done

  # Zero-cost bypass
  if [[ -z "$complexity" || "${_ROUTING_CX_MODE:-off}" == "off" ]]; then
    routing_resolve_dispatch_tier "$tier"
    return $?
  fi

  # Get base result
  local base_result
  base_result="$(routing_resolve_dispatch_tier "$tier" 2>/dev/null)" || base_result=""

  # Look up complexity dispatch tier override
  local cx_tier="${_ROUTING_CX_DISPATCH_TIER[$complexity]:-}"
  local final_tier="$tier"

  if [[ -n "$cx_tier" && "$cx_tier" != "inherit" ]]; then
    final_tier="$cx_tier"
  fi

  # Shadow mode
  if [[ "${_ROUTING_CX_MODE}" == "shadow" ]]; then
    if [[ "$final_tier" != "$tier" ]]; then
      local shadow_result
      shadow_result="$(routing_resolve_dispatch_tier "$final_tier" 2>/dev/null)" || shadow_result=""
      echo "[B2-shadow] complexity=$complexity would change dispatch: $tier($base_result) → $final_tier($shadow_result)" >&2
    fi
    [[ -n "$base_result" ]] && echo "$base_result"
    return 0
  fi

  # Enforce mode: resolve the overridden tier
  routing_resolve_dispatch_tier "$final_tier"
  return $?
}

# --- Public: resolve dispatch tier to model ---
routing_resolve_dispatch_tier() {

--- 2026-02-21T16:42:34Z | os/clavain/scripts/lib-routing.sh | CONTEXT:unknown ---
OLD:   if [[ ${#_ROUTING_DISPATCH_FALLBACK[@]} -gt 0 ]]; then
    echo "  Fallback:"
    for k in "${!_ROUTING_DISPATCH_FALLBACK[@]}"; do
      echo "    ${k} → ${_ROUTING_DISPATCH_FALLBACK[$k]}"
    done
  fi
}
NEW:   if [[ ${#_ROUTING_DISPATCH_FALLBACK[@]} -gt 0 ]]; then
    echo "  Fallback:"
    for k in "${!_ROUTING_DISPATCH_FALLBACK[@]}"; do
      echo "    ${k} → ${_ROUTING_DISPATCH_FALLBACK[$k]}"
    done
  fi

  # B2: Complexity routing
  echo ""
  echo "Complexity Routing (B2):"
  echo "  Mode: ${_ROUTING_CX_MODE:-off}"
  if [[ "${_ROUTING_CX_MODE:-off}" != "off" ]]; then
    echo "  Tiers:"
    local cx_tier
    for cx_tier in C5 C4 C3 C2 C1; do
      local cx_desc="${_ROUTING_CX_DESC[$cx_tier]:-}"
      local cx_pt="${_ROUTING_CX_PROMPT_TOKENS[$cx_tier]:-}"
      local cx_fc="${_ROUTING_CX_FILE_COUNT[$cx_tier]:-}"
      local cx_rd="${_ROUTING_CX_REASONING_DEPTH[$cx_tier]:-}"
      local cx_sm="${_ROUTING_CX_SUBAGENT_MODEL[$cx_tier]:-}"
      local cx_dt="${_ROUTING_CX_DISPATCH_TIER[$cx_tier]:-}"
      if [[ -n "$cx_pt" || -n "$cx_fc" || -n "$cx_rd" ]]; then
        local thresh="tokens≥${cx_pt:-_} files≥${cx_fc:-_} depth≥${cx_rd:-_}"
        local override="subagent=${cx_sm:-inherit} dispatch=${cx_dt:-inherit}"
        echo "    ${cx_tier}: ${thresh} → ${override}"
        [[ -n "$cx_desc" ]] && echo "         ${cx_desc}"
      fi
    done
  fi
}

--- 2026-02-21T16:43:39Z | os/clavain/tests/shell/test_routing.bats | CONTEXT:unknown ---
OLD: @test "list_mappings prints source path and default model" {
    _source_routing
    result="$(routing_list_mappings)"
    [[ "$result" == *"Source:"* ]]
    [[ "$result" == *"Default model: sonnet"* ]]
    [[ "$result" == *"Dispatch Tiers:"* ]]
}
NEW: @test "list_mappings prints source path and default model" {
    _source_routing
    result="$(routing_list_mappings)"
    [[ "$result" == *"Source:"* ]]
    [[ "$result" == *"Default model: sonnet"* ]]
    [[ "$result" == *"Dispatch Tiers:"* ]]
}

# ═══════════════════════════════════════════════════════════════════
# B2: Complexity-aware routing tests
# ═══════════════════════════════════════════════════════════════════

# Helper: write a complexity-enabled config for B2 tests
_write_cx_config() {
    local mode="${1:-enforce}"
    cat > "$TEST_DIR/config/cx.yaml" << YAML
subagents:
  defaults:
    model: sonnet
    categories:
      research: haiku
  phases:
    brainstorm:
      model: opus

dispatch:
  tiers:
    fast:
      model: gpt-5.3-codex-spark
    deep:
      model: gpt-5.3-codex

complexity:
  mode: ${mode}
  tiers:
    C5:
      description: Architectural
      prompt_tokens: 4000
      file_count: 15
      reasoning_depth: 5
    C4:
      description: Complex
      prompt_tokens: 2000
      file_count: 8
      reasoning_depth: 4
    C3:
      description: Moderate
      prompt_tokens: 800
      file_count: 4
      reasoning_depth: 3
    C2:
      description: Simple
      prompt_tokens: 300
      file_count: 2
      reasoning_depth: 2
    C1:
      description: Trivial
      prompt_tokens: 0
      file_count: 0
      reasoning_depth: 1
  overrides:
    C5:
      subagent_model: opus
      dispatch_tier: deep
    C4:
      subagent_model: opus
      dispatch_tier: deep
    C3:
      subagent_model: inherit
      dispatch_tier: inherit
    C2:
      subagent_model: haiku
      dispatch_tier: fast
    C1:
      subagent_model: haiku
      dispatch_tier: fast
YAML
}

# --- Classification tests ---

@test "classify_complexity returns empty when mode=off" {
    _source_routing  # default config has no complexity section → mode=off
    result="$(routing_classify_complexity --prompt-tokens 5000 --file-count 20)"
    [[ -z "$result" ]]
}

@test "classify_complexity returns C5 for high token count" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_classify_complexity --prompt-tokens 5000)"
    [[ "$result" == "C5" ]]
}

@test "classify_complexity returns C5 for high file count" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_classify_complexity --file-count 20)"
    [[ "$result" == "C5" ]]
}

@test "classify_complexity returns C5 for reasoning_depth=5" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_classify_complexity --reasoning-depth 5)"
    [[ "$result" == "C5" ]]
}

@test "classify_complexity returns C3 for moderate tokens" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_classify_complexity --prompt-tokens 900)"
    [[ "$result" == "C3" ]]
}

@test "classify_complexity returns C2 for low tokens" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_classify_complexity --prompt-tokens 350)"
    [[ "$result" == "C2" ]]
}

@test "classify_complexity returns C1 for minimal signals" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_classify_complexity --prompt-tokens 100 --file-count 0 --reasoning-depth 1)"
    [[ "$result" == "C1" ]]
}

@test "classify_complexity ANY threshold triggers tier" {
    # High file_count but low tokens should still classify as C4
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_classify_complexity --prompt-tokens 100 --file-count 10)"
    [[ "$result" == "C4" ]]
}

# --- Zero-cost bypass tests ---

@test "resolve_model_complex with no complexity is identical to resolve_model" {
    _source_routing
    base="$(routing_resolve_model --phase brainstorm)"
    complex="$(routing_resolve_model_complex --phase brainstorm)"
    [[ "$base" == "$complex" ]]
}

@test "resolve_model_complex with mode=off delegates to base" {
    _source_routing  # no complexity section → mode=off
    result="$(routing_resolve_model_complex --complexity C5 --phase brainstorm)"
    [[ "$result" == "opus" ]]  # base B1 result, not overridden
}

@test "resolve_dispatch_tier_complex with mode=off delegates to base" {
    _source_routing
    result="$(routing_resolve_dispatch_tier_complex fast)"
    [[ "$result" == "gpt-5.3-codex-spark" ]]
}

# --- Enforce mode tests ---

@test "resolve_model_complex C5 enforce overrides to opus" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    # Base would return sonnet (default), but C5 overrides to opus
    result="$(routing_resolve_model_complex --complexity C5)"
    [[ "$result" == "opus" ]]
}

@test "resolve_model_complex C2 enforce overrides to haiku" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    # Base would return opus (brainstorm phase), but C2 overrides to haiku
    result="$(routing_resolve_model_complex --complexity C2 --phase brainstorm)"
    [[ "$result" == "haiku" ]]
}

@test "resolve_model_complex C3 enforce inherits from base (inherit passthrough)" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    # C3 has subagent_model: inherit → should return base result
    result="$(routing_resolve_model_complex --complexity C3 --phase brainstorm)"
    [[ "$result" == "opus" ]]  # base B1 result
}

@test "resolve_dispatch_tier_complex C5 enforce promotes to deep" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    # Requesting fast, but C5 overrides to deep
    result="$(routing_resolve_dispatch_tier_complex --complexity C5 fast)"
    [[ "$result" == "gpt-5.3-codex" ]]
}

@test "resolve_dispatch_tier_complex C2 enforce demotes to fast" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    # Requesting deep, but C2 overrides to fast
    result="$(routing_resolve_dispatch_tier_complex --complexity C2 deep)"
    [[ "$result" == "gpt-5.3-codex-spark" ]]
}

@test "resolve_dispatch_tier_complex C3 enforce inherits original tier" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_resolve_dispatch_tier_complex --complexity C3 deep)"
    [[ "$result" == "gpt-5.3-codex" ]]
}

# --- Shadow mode tests ---

@test "resolve_model_complex shadow logs but returns base result" {
    _write_cx_config shadow
    _source_routing "$TEST_DIR/config/cx.yaml"
    # C2 would override sonnet → haiku, but shadow returns base
    run bash -c "
        unset _ROUTING_LOADED
        export CLAVAIN_ROUTING_CONFIG='$TEST_DIR/config/cx.yaml'
        source '$SCRIPTS_DIR/lib-routing.sh'
        routing_resolve_model_complex --complexity C2
    "
    # stdout should be base result (sonnet)
    [[ "$output" == *"sonnet"* ]]
    # stderr should contain shadow log (captured in combined output by bats)
    [[ "$output" == *"B2-shadow"* ]]
}

@test "resolve_dispatch_tier_complex shadow logs but returns base" {
    _write_cx_config shadow
    _source_routing "$TEST_DIR/config/cx.yaml"
    run bash -c "
        unset _ROUTING_LOADED
        export CLAVAIN_ROUTING_CONFIG='$TEST_DIR/config/cx.yaml'
        source '$SCRIPTS_DIR/lib-routing.sh'
        routing_resolve_dispatch_tier_complex --complexity C5 fast
    "
    # stdout should be base result (fast tier model)
    [[ "$output" == *"gpt-5.3-codex-spark"* ]]
    # stderr should contain shadow log
    [[ "$output" == *"B2-shadow"* ]]
}

@test "resolve_model_complex shadow does not log when no change" {
    _write_cx_config shadow
    _source_routing "$TEST_DIR/config/cx.yaml"
    # C3 has inherit → no change → no shadow log
    run bash -c "
        unset _ROUTING_LOADED
        export CLAVAIN_ROUTING_CONFIG='$TEST_DIR/config/cx.yaml'
        source '$SCRIPTS_DIR/lib-routing.sh'
        routing_resolve_model_complex --complexity C3
    "
    [[ "$output" == *"sonnet"* ]]
    [[ "$output" != *"B2-shadow"* ]]
}

# --- list_mappings with complexity ---

@test "list_mappings shows complexity mode when enabled" {
    _write_cx_config enforce
    _source_routing "$TEST_DIR/config/cx.yaml"
    result="$(routing_list_mappings)"
    [[ "$result" == *"Complexity Routing (B2):"* ]]
    [[ "$result" == *"Mode: enforce"* ]]
    [[ "$result" == *"C5:"* ]]
    [[ "$result" == *"C1:"* ]]
}

@test "list_mappings shows mode=off without tier details" {
    _source_routing  # default config, no complexity → mode=off
    result="$(routing_list_mappings)"
    [[ "$result" == *"Mode: off"* ]]
    # Should NOT show tier details when off
    [[ "$result" != *"C5:"* ]]
}

--- 2026-02-21T16:50:54Z | docs/brainstorms/2026-02-21-event-driven-advancement-brainstorm.md | CONTEXT:unknown ---
OLD: # Event-Driven Advancement: Phase Transitions Trigger Auto-Dispatch

**Bead:** iv-r9j2
NEW: # Event-Driven Advancement: Phase Transitions Trigger Auto-Dispatch

**Bead:** iv-r9j2
**Sprint:** iv-lype

--- 2026-02-21T16:59:06Z | infra/intercore/internal/db/schema.sql | CONTEXT:unknown ---
OLD: CREATE INDEX IF NOT EXISTS idx_lane_members_bead ON lane_members(bead_id);
NEW: CREATE INDEX IF NOT EXISTS idx_lane_members_bead ON lane_members(bead_id);

-- v14: phase actions (event-driven advancement)
CREATE TABLE IF NOT EXISTS phase_actions (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    run_id      TEXT NOT NULL REFERENCES runs(id),
    phase       TEXT NOT NULL,
    action_type TEXT NOT NULL DEFAULT 'command',
    command     TEXT NOT NULL,
    args        TEXT,
    mode        TEXT NOT NULL DEFAULT 'interactive',
    priority    INTEGER NOT NULL DEFAULT 0,
    created_at  INTEGER NOT NULL DEFAULT (unixepoch()),
    updated_at  INTEGER NOT NULL DEFAULT (unixepoch()),
    UNIQUE(run_id, phase, command)
);
CREATE INDEX IF NOT EXISTS idx_phase_actions_run ON phase_actions(run_id);
CREATE INDEX IF NOT EXISTS idx_phase_actions_phase ON phase_actions(run_id, phase);

--- 2026-02-21T16:59:10Z | infra/intercore/internal/db/db.go | CONTEXT:unknown ---
OLD: 	currentSchemaVersion = 13
	maxSchemaVersion     = 13
NEW: 	currentSchemaVersion = 14
	maxSchemaVersion     = 14

--- 2026-02-21T16:59:19Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: <!-- LLM:NEXT_GROUPINGS
Task: Group these P2 items under 5-10 thematic headings.
Format: **Bold Heading** followed by bullet items.
Heuristic: items sharing a [module] tag or dependency chain likely belong together.

Raw P2 items JSON:
[{"id":"iv-003t","title":"[interspect] Global modification rate limiter","priority":2,"dependencies":[{"issue_id":"iv-003t","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T01:35:01Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-0etu","title":"[flux-drive-spec] Phase 3: Extract scoring/synthesis Python library","priority":2,"dependencies":[{"issue_id":"iv-0etu","depends_on_id":"iv-ia66","type":"blocks","created_at":"2026-02-13T22:47:12Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-0fi2","title":"[interspect] Circuit breaker","priority":2,"dependencies":[{"issue_id":"iv-0fi2","depends_on_id":"iv-ukct","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-0lt","title":"Extract cache_hints metrics in score_tokens.py","priority":2,"dependencies":null},{"id":"iv-14g9","title":"TOCTOU prevention: phased dispatch coordination","priority":2,"dependencies":null},{"id":"iv-1gb","title":"Add cache-friendly format queries to regression_suite.json","priority":2,"dependencies":null},{"id":"iv-26pj","title":"[autarch] Streaming buffer / history split per agent panel","priority":2,"dependencies":null},{"id":"iv-2jtj","title":"F5: Escalation Timeout for Unresponsive Agents","priority":2,"dependencies":[{"issue_id":"iv-2jtj","depends_on_id":"iv-5ijt","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-2jtj","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-2o6c","title":"[interspect] F4: status display + revert for routing overrides","priority":2,"dependencies":[{"issue_id":"iv-2o6c","depends_on_id":"iv-gkj9","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-2o6c","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-3kee","title":"Research: product-native agent orchestration (whitespace opportunity)","priority":2,"dependencies":null},{"id":"iv-3w1x","title":"Split upstreams.json into config + state files","priority":2,"dependencies":null},{"id":"iv-435u","title":"[interspect] Counterfactual shadow evaluation","priority":2,"dependencies":[{"issue_id":"iv-435u","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T07:31:17Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-4728","title":"Consolidate upstream-check.sh API calls (24 to 12)","priority":2,"dependencies":null},{"id":"iv-5ijt","title":"F3: Structured negotiate_release MCP Tool","priority":2,"dependencies":[{"issue_id":"iv-5ijt","depends_on_id":"iv-1aug","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-5ijt","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-5su3","title":"[interspect] Autonomous mode flag","priority":2,"dependencies":[{"issue_id":"iv-5su3","depends_on_id":"iv-cylo","type":"blocks","created_at":"2026-02-15T07:32:25Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-5su3","depends_on_id":"iv-jo3i","type":"blocks","created_at":"2026-02-15T01:35:05Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-6ikc","title":"Plan intershift extraction (cross-AI dispatch engine)","priority":2,"dependencies":null},{"id":"iv-6liz","title":"[interspect] F5: manual routing override support","priority":2,"dependencies":[{"issue_id":"iv-6liz","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:17Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-6liz","depends_on_id":"iv-r6mf","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-6u3s","title":"F4: Sprint Scan Release Visibility","priority":2,"dependencies":[{"issue_id":"iv-6u3s","depends_on_id":"iv-1aug","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-6u3s","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-88yg","title":"[interspect] Structured commit message format","priority":2,"dependencies":[{"issue_id":"iv-88yg","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T01:35:01Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-8fgu","title":"[interspect] F2: routing-eligible pattern detection + propose flow","priority":2,"dependencies":[{"issue_id":"iv-8fgu","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-8fgu","depends_on_id":"iv-r6mf","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-905u","title":"Intermediate result sharing between parallel flux-drive agents","priority":2,"dependencies":[{"issue_id":"iv-905u","depends_on_id":"iv-ffo5","type":"relates-to","created_at":"2026-02-18T15:45:10Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-asfy","title":"[clavain] C1: Agency specs — declarative per-stage agent/model/tool config","priority":2,"dependencies":null},{"id":"iv-bj0w","title":"[interspect] Conflict detection","priority":2,"dependencies":[{"issue_id":"iv-bj0w","depends_on_id":"iv-rafa","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-bn4j","title":"[intermem] F4: One-shot tiered migration — --migrate-to-tiered","priority":2,"dependencies":[{"issue_id":"iv-bn4j","depends_on_id":"iv-f7po","type":"blocks","created_at":"2026-02-18T08:36:04Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-bn4j","depends_on_id":"iv-rkrm","type":"blocks","created_at":"2026-02-18T08:36:02Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-c2b4","title":"[interspect] /interspect:disable command","priority":2,"dependencies":[{"issue_id":"iv-c2b4","depends_on_id":"iv-o4x7","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-drgo","title":"[interspect] Privilege separation (proposer/applier)","priority":2,"dependencies":[{"issue_id":"iv-drgo","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T07:31:17Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-dthn","title":"Research: inter-layer feedback loops and optimization thresholds","priority":2,"dependencies":null},{"id":"iv-e8dg","title":"[flux-drive-spec] Phase 4: Migrate Clavain to consume the library","priority":2,"dependencies":[{"issue_id":"iv-e8dg","depends_on_id":"iv-0etu","type":"blocks","created_at":"2026-02-13T22:47:13Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-ev4o","title":"Agent capability discovery via intermute registration","priority":2,"dependencies":null},{"id":"iv-exos","title":"Research: bias-aware product decision framework","priority":2,"dependencies":null},{"id":"iv-f7po","title":"[intermem] F3: Multi-file tiered promotion — AGENTS.md index + docs/intermem/ detail","priority":2,"dependencies":[{"issue_id":"iv-f7po","depends_on_id":"iv-rkrm","type":"blocks","created_at":"2026-02-18T08:36:02Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-frqh","title":"F5: clavain:setup modpack — auto-install ecosystem-only plugins","priority":2,"dependencies":[{"issue_id":"iv-frqh","depends_on_id":"iv-gcu2","type":"blocks","created_at":"2026-02-20T12:49:42Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-fzrn","title":"Research: multi-agent hallucination cascades & failure taxonomy","priority":2,"dependencies":[{"issue_id":"iv-fzrn","depends_on_id":"iv-ffo5","type":"relates-to","created_at":"2026-02-18T15:45:11Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-g0to","title":"[interspect] /interspect:reset command","priority":2,"dependencies":[{"issue_id":"iv-g0to","depends_on_id":"iv-ukct","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-gg8v","title":"F2: Auto-Release on Clean Files","priority":2,"dependencies":[{"issue_id":"iv-gg8v","depends_on_id":"iv-1aug","type":"blocks","created_at":"2026-02-15T09:11:41Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-gg8v","depends_on_id":"iv-d72t","type":"blocks","created_at":"2026-02-15T09:11:40Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-gkj9","title":"[interspect] F3: apply override + canary + git commit","priority":2,"dependencies":[{"issue_id":"iv-gkj9","depends_on_id":"iv-8fgu","type":"blocks","created_at":"2026-02-15T12:47:18Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-gkj9","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-ht1l","title":"[autarch] Pollard: progressive result reveal per hunter","priority":2,"dependencies":null},{"id":"iv-ia66","title":"[flux-drive-spec] Phase 2: Extract domain detection library","priority":2,"dependencies":null},{"id":"iv-izth","title":"[interspect] Eval corpus construction","priority":2,"dependencies":[{"issue_id":"iv-izth","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-jc4j","title":"[intermute] Heterogeneous agent routing experiments inspired by SC-MAS/Dr. MAS","priority":2,"dependencies":[{"issue_id":"iv-jc4j","depends_on_id":"iv-qznx","type":"blocks","created_at":"2026-02-16T22:40:51Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-jk7q","title":"Research: cognitive load budgets & progressive disclosure review UX","priority":2,"dependencies":null},{"id":"iv-lx00","title":"[clavain] C2: Agent fleet registry — capability + cost profiles per agent×model","priority":2,"dependencies":[{"issue_id":"iv-lx00","depends_on_id":"iv-asfy","type":"blocks","created_at":"2026-02-20T09:28:07Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-lx00","depends_on_id":"iv-dd9q","type":"blocks","created_at":"2026-02-20T09:28:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-m6cd","title":"[interspect] Session-start summary injection","priority":2,"dependencies":[{"issue_id":"iv-m6cd","depends_on_id":"iv-o4x7","type":"blocks","created_at":"2026-02-15T01:34:57Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-otvb","title":"F1: Schema + Store — phase_actions table (v14 migration)","priority":2,"dependencies":[{"issue_id":"iv-otvb","depends_on_id":"iv-lype","type":"blocks","created_at":"2026-02-21T08:53:22Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-p4qq","title":"Smart semantic caching across sessions (intercache)","priority":2,"dependencies":[{"issue_id":"iv-p4qq","depends_on_id":"iv-qtcl","type":"relates-to","created_at":"2026-02-18T15:45:12Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-pipe","title":"F4: Bash integration — sprint skill consumes kernel actions","priority":2,"dependencies":[{"issue_id":"iv-pipe","depends_on_id":"iv-lype","type":"blocks","created_at":"2026-02-21T08:53:23Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-pipe","depends_on_id":"iv-z5pc","type":"blocks","created_at":"2026-02-21T08:53:24Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-qjm3","title":"F2: CLI — ic run action subcommands (add/list/update/delete)","priority":2,"dependencies":[{"issue_id":"iv-qjm3","depends_on_id":"iv-lype","type":"blocks","created_at":"2026-02-21T08:53:23Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-qjm3","depends_on_id":"iv-otvb","type":"blocks","created_at":"2026-02-21T08:53:23Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-qjwz","title":"AgentDropout: dynamic redundancy elimination for flux-drive reviews","priority":2,"dependencies":[{"issue_id":"iv-qjwz","depends_on_id":"iv-8m38","type":"blocks","created_at":"2026-02-15T17:42:31Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-qjwz","depends_on_id":"iv-ynbh","type":"blocks","created_at":"2026-02-15T17:31:23Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-quk4","title":"Hierarchical dispatch: meta-agent for N-agent fan-out","priority":2,"dependencies":null},{"id":"iv-r6mf","title":"[interspect] F1: routing-overrides.json schema + flux-drive reader","priority":2,"dependencies":[{"issue_id":"iv-r6mf","depends_on_id":"iv-nkak","type":"blocks","created_at":"2026-02-15T12:47:16Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-rafa","title":"[interspect] Meta-learning loop","priority":2,"dependencies":[{"issue_id":"iv-rafa","depends_on_id":"iv-8jpf","type":"blocks","created_at":"2026-02-19T23:37:00Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-rafa","depends_on_id":"iv-cylo","type":"blocks","created_at":"2026-02-15T07:32:26Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-rafa","depends_on_id":"iv-jo3i","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-sdqv","title":"Plan interscribe extraction (knowledge compounding)","priority":2,"dependencies":[{"issue_id":"iv-sdqv","depends_on_id":"iv-qtcl","type":"relates-to","created_at":"2026-02-18T15:45:13Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-t1m4","title":"[interspect] Prompt tuning (Type 3) overlay-based","priority":2,"dependencies":[{"issue_id":"iv-t1m4","depends_on_id":"iv-cylo","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-t1m4","depends_on_id":"iv-izth","type":"blocks","created_at":"2026-02-15T01:35:06Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-v81k","title":"[interstat] Repository-aware benchmark expansion for agent coding tasks","priority":2,"dependencies":[{"issue_id":"iv-v81k","depends_on_id":"iv-qznx","type":"blocks","created_at":"2026-02-16T22:40:51Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-wz3j","title":"[interflux] Role-aware latent memory architecture experiments","priority":2,"dependencies":[{"issue_id":"iv-wz3j","depends_on_id":"iv-jc4j","type":"blocks","created_at":"2026-02-16T22:40:51Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-xlpg","title":"[autarch] Pollard: optional-death hunter resilience","priority":2,"dependencies":null},{"id":"iv-xuec","title":"Security threat model for token optimization techniques","priority":2,"dependencies":[{"issue_id":"iv-xuec","depends_on_id":"iv-qtcl","type":"relates-to","created_at":"2026-02-18T15:45:13Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-z5pc","title":"F3: Resolution — template variables in ic run advance output","priority":2,"dependencies":[{"issue_id":"iv-z5pc","depends_on_id":"iv-lype","type":"blocks","created_at":"2026-02-21T08:53:23Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-z5pc","depends_on_id":"iv-otvb","type":"blocks","created_at":"2026-02-21T08:53:24Z","created_by":"mk","metadata":"{}"},{"issue_id":"iv-z5pc","depends_on_id":"iv-qjm3","type":"blocks","created_at":"2026-02-21T08:53:24Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-zsio","title":"[clavain/interphase] Integrate full discovery pipeline into sprint workflow","priority":2,"dependencies":[{"issue_id":"iv-zsio","depends_on_id":"iv-faq6","type":"parent-child","created_at":"2026-02-20T15:23:46Z","created_by":"mk","metadata":"{}"}]},{"id":"iv-zyym","title":"Evaluate Claude Hub for event-driven GitHub agent dispatch","priority":2,"dependencies":null}]

END LLM:NEXT_GROUPINGS -->
NEW: **Interspect Routing Overrides**
- [interspect] **iv-r6mf** F1: routing-overrides.json schema + flux-drive reader
- [interspect] **iv-8fgu** F2: routing-eligible pattern detection + propose flow
- [interspect] **iv-gkj9** F3: apply override + canary + git commit
- [interspect] **iv-2o6c** F4: status display + revert for routing overrides
- [interspect] **iv-6liz** F5: manual routing override support
- [interspect] **iv-5su3** Autonomous mode flag
- [interspect] **iv-c2b4** /interspect:disable command
- [interspect] **iv-g0to** /interspect:reset command

**Interspect Safety & Evaluation**
- [interspect] **iv-88yg** Structured commit message format
- [interspect] **iv-003t** Global modification rate limiter
- [interspect] **iv-0fi2** Circuit breaker
- [interspect] **iv-drgo** Privilege separation (proposer/applier)
- [interspect] **iv-bj0w** Conflict detection
- [interspect] **iv-435u** Counterfactual shadow evaluation
- [interspect] **iv-izth** Eval corpus construction
- [interspect] **iv-rafa** Meta-learning loop
- [interspect] **iv-t1m4** Prompt tuning (Type 3) overlay-based
- [interspect] **iv-m6cd** Session-start summary injection

**Intercore Event-Driven Advancement**
- [intercore] **iv-otvb** F1: Schema + Store — phase_actions table (v14 migration)
- [intercore] **iv-qjm3** F2: CLI — ic run action subcommands (add/list/update/delete)
- [intercore] **iv-z5pc** F3: Resolution — template variables in ic run advance output
- [intercore] **iv-pipe** F4: Bash integration — sprint skill consumes kernel actions
- [intercore] **iv-14g9** TOCTOU prevention: phased dispatch coordination
- [clavain] **iv-r9j2** A3: Event-driven advancement — phase transitions trigger auto-dispatch

**Clavain Orchestration & Fleet**
- [clavain] **iv-asfy** C1: Agency specs — declarative per-stage agent/model/tool config
- [clavain] **iv-lx00** C2: Agent fleet registry — capability + cost profiles per agent×model
- [clavain/interphase] **iv-zsio** Integrate full discovery pipeline into sprint workflow
- [clavain] **iv-frqh** F5: clavain:setup modpack — auto-install ecosystem-only plugins
- [clavain] **iv-zyym** Evaluate Claude Hub for event-driven GitHub agent dispatch

**Multi-Agent Coordination & Interlock**
- [interlock] **iv-gg8v** F2: Auto-Release on Clean Files
- [interlock] **iv-5ijt** F3: Structured negotiate_release MCP Tool
- [interlock] **iv-6u3s** F4: Sprint Scan Release Visibility
- [interlock] **iv-2jtj** F5: Escalation Timeout for Unresponsive Agents
- [intermute] **iv-ev4o** Agent capability discovery via intermute registration
- [intermute] **iv-jc4j** Heterogeneous agent routing experiments (SC-MAS/Dr. MAS)
- [intermute] **iv-quk4** Hierarchical dispatch: meta-agent for N-agent fan-out

**Flux-Drive Evolution & Review Intelligence**
- [flux-drive-spec] **iv-ia66** Phase 2: Extract domain detection library
- [flux-drive-spec] **iv-0etu** Phase 3: Extract scoring/synthesis Python library
- [flux-drive-spec] **iv-e8dg** Phase 4: Migrate Clavain to consume the library
- [interflux] **iv-wz3j** Role-aware latent memory architecture experiments
- [interflux] **iv-qjwz** AgentDropout: dynamic redundancy elimination for flux-drive reviews
- [interflux] **iv-905u** Intermediate result sharing between parallel flux-drive agents
- [interflux] **iv-6ikc** Plan intershift extraction (cross-AI dispatch engine)
- [interflux] **iv-sdqv** Plan interscribe extraction (knowledge compounding)

**Token Efficiency & Benchmarks**
- [interstat] **iv-0lt** Extract cache_hints metrics in score_tokens.py
- [interstat] **iv-1gb** Add cache-friendly format queries to regression_suite.json
- [interstat] **iv-4728** Consolidate upstream-check.sh API calls (24 to 12)
- [interstat] **iv-3w1x** Split upstreams.json into config + state files
- [interstat] **iv-v81k** Repository-aware benchmark expansion for agent coding tasks
- [intercache] **iv-p4qq** Smart semantic caching across sessions
- [intercache] **iv-xuec** Security threat model for token optimization techniques

**Autarch TUI & Memory Promotion**
- [autarch] **iv-26pj** Streaming buffer / history split per agent panel
- [autarch] **iv-ht1l** Pollard: progressive result reveal per hunter
- [autarch] **iv-xlpg** Pollard: optional-death hunter resilience
- [intermem] **iv-f7po** F3: Multi-file tiered promotion — AGENTS.md index + docs/intermem/ detail
- [intermem] **iv-bn4j** F4: One-shot tiered migration — --migrate-to-tiered

**Research & Futures**
- [research] **iv-3kee** Research: product-native agent orchestration (whitespace opportunity)
- [research] **iv-dthn** Research: inter-layer feedback loops and optimization thresholds
- [research] **iv-fzrn** Research: multi-agent hallucination cascades & failure taxonomy
- [research] **iv-exos** Research: bias-aware product decision framework
- [research] **iv-jk7q** Research: cognitive load budgets & progressive disclosure review UX

--- 2026-02-21T16:59:27Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: <!-- LLM:MODULE_HIGHLIGHTS
Task: Write 2-3 sentence summaries for these modules.
Format: ### module (location)
vX.Y.Z. Summary text.

Modules needing highlights:
interkasten|plugins/interkasten

END LLM:MODULE_HIGHLIGHTS -->
NEW: ### interkasten (plugins/interkasten)
v0.4.3. Bidirectional sync between local filesystems and Notion with three-way merge conflict resolution and crash-safe WAL recovery. Exposes 21 MCP tools for hierarchy discovery, raw signal gathering, and sync control — delegating classification and tagging to agent skills rather than hardcoding behavior.

--- 2026-02-21T16:59:42Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: want 13
NEW: want 14

--- 2026-02-21T16:59:46Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: expected schema version 13
NEW: expected schema version 14

--- 2026-02-21T16:59:53Z | infra/intercore/internal/db/db_test.go | CONTEXT:unknown ---
OLD: v != 13
NEW: v != 14

--- 2026-02-21T17:00:05Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: <!-- LLM:RESEARCH_AGENDA
Task: Synthesize into 10-15 thematic research bullets.
Format: - **Topic** — 1-line summary

Brainstorm files:
2026-02-15-linsenkasten-flux-agents-brainstorm
2026-02-15-multi-session-phase4-merge-agent-brainstorm
2026-02-15-sprint-resilience-brainstorm
2026-02-15-token-efficient-skill-loading
2026-02-16-agent-rig-autonomous-sync-brainstorm
2026-02-16-flux-drive-document-slicing-brainstorm
2026-02-16-interbus-central-integration-mesh-brainstorm
2026-02-16-linsenkasten-phase1-agents-brainstorm
2026-02-16-sprint-resilience-phase2-brainstorm
2026-02-16-subagent-context-flooding-brainstorm
2026-02-16-token-budget-controls-brainstorm
2026-02-19-intercore-e3-hook-cutover-brainstorm
2026-02-19-reflect-phase-learning-loop-brainstorm
2026-02-20-autarch-status-tool-brainstorm
2026-02-20-bigend-migration-brainstorm
2026-02-20-cost-aware-agent-scheduling-brainstorm
2026-02-20-dual-mode-plugin-architecture-brainstorm
2026-02-20-interchart-ecosystem-diagram-brainstorm
2026-02-20-intercore-e5-discovery-pipeline-brainstorm
2026-02-20-intercore-rollback-recovery-brainstorm
2026-02-20-plugin-synergy-catalog-brainstorm
2026-02-20-sprint-handover-kernel-driven-brainstorm
2026-02-21-event-driven-advancement-brainstorm
2026-02-21-intercore-e8-portfolio-orchestration
2026-02-21-portfolio-dependency-scheduling
2026-02-21-thematic-work-lanes-brainstorm

Plan files:
2026-02-15-cross-module-integration-opportunities
2026-02-15-linsenkasten-flux-agents
2026-02-15-multi-session-coordination-brainstorm
2026-02-15-sprint-resilience-phase1
2026-02-15-token-efficient-skill-loading
2026-02-16-flux-drive-document-slicing
2026-02-16-linsenkasten-phase1-remaining-agents
2026-02-16-sprint-resilience-phase2
2026-02-16-subagent-context-flooding
2026-02-16-token-budget-controls
2026-02-17-framework-benchmark-freshness-automation
2026-02-17-heterogeneous-collaboration-routing
2026-02-17-interband-sideband-hardening
2026-02-17-multi-framework-interoperability-benchmark
2026-02-17-repository-aware-benchmark-expansion
2026-02-17-role-aware-latent-memory-experiments
2026-02-19-bias-aware-product-decision-framework
2026-02-19-blueprint-distillation-sprint-intake
2026-02-19-catalog-reminder-interwatch-escalation
2026-02-19-clavain-roadmap-vision-alignment
2026-02-19-hierarchical-dispatch-meta-agent
2026-02-19-intercore-e3-hook-cutover
2026-02-19-intercore-spawn-handler-wiring
2026-02-19-interscribe-extraction-plan
2026-02-19-session-start-drift-summary-injection
2026-02-19-shift-work-boundary-formalization
2026-02-19-tldrs-import-graph-compression-dedup
2026-02-19-tldrs-longcodezip-block-compression
2026-02-19-tldrs-precomputed-context-bundles
2026-02-19-tldrs-structured-output-serialization
2026-02-19-tldrs-symbol-popularity-index
2026-02-20-autarch-status-tool
2026-02-20-cost-aware-agent-scheduling
2026-02-20-dual-mode-plugin-architecture
2026-02-20-interchart-ecosystem-diagram
2026-02-20-intercore-e5-discovery-pipeline
2026-02-20-intercore-rollback-recovery
2026-02-20-plugin-synergy-interop
2026-02-20-reflect-phase-sprint-integration
2026-02-20-sprint-handover-kernel-driven
2026-02-20-tui-kernel-validation
2026-02-21-intercore-e8-portfolio-orchestration
2026-02-21-portfolio-dependency-scheduling
2026-02-21-static-routing-table
2026-02-21-thematic-work-lanes
2026-02-21-toctou-bug-fixes

END LLM:RESEARCH_AGENDA -->
NEW: - **Lens-driven agent review (linsenkasten)** — FLUX podcast cognitive augmentation lenses for agent evaluation, MCP integration, severity classification, and phase-specific agent selection
- **Sprint resilience and kernel handoff** — Resume tracking, fault tolerance, multi-layer rollback recovery, and bidirectional bead-kernel sync to migrate sprint state to intercore kernel
- **Token efficiency and cost-aware dispatch** — Lazy skill loading, token budget controls per sprint, dispatch cost tracking, and write-behind for subagent context results
- **Document slicing and context compression** — Per-agent section filtering via interserve, import-graph compression, block compression, precomputed context bundles, and symbol-popularity indexing
- **Intercore kernel evolution (E3-E8)** — Hook cutover for sprint state, spawn handler wiring, discovery pipeline for kernel-native research intake, and portfolio orchestration across projects
- **Multi-session agent coordination** — Merge review for multi-agent sessions, hierarchical dispatch meta-agent, session-start drift summary injection, and autonomous sync mechanics
- **Plugin ecosystem and synergy** — Dual-mode architecture (standalone + integrated), cross-plugin interoperability catalog, plugin-synergy discovery, and unified interbus central integration mesh
- **Portfolio and dependency scheduling** — Cross-project portfolio runs with parent-child linking, dependency-aware phase scheduling, TOCTOU guards, and portfolio relay patterns
- **Dashboard and visualization** — Bigend TUI kernel state migration, autarch status tool validation, interchart D3 force graph ecosystem diagram, and tui-kernel validation patterns
- **Event-driven phase advancement** — Automatic phase transition dispatch, event-driven run progression, terminal status exhaustiveness, and gate check flow
- **Thematic sprint organization** — Label-based work lanes for sequencing, shift-work boundary formalization, blueprint distillation sprint intake, and role-aware memory experiments
- **Framework and context optimization** — Multi-framework interoperability benchmarking, repository-aware benchmark expansion, context freshness automation via interwatch, and reminder escalation patterns
- **Advanced state management** — Hierarchical config resolution for model routing, static routing tables, drift detection summaries, and bias-aware product decision frameworks
- **Code extraction and tools** — Interscribe symbol extraction, structured output serialization, longcodezip block compression, and advanced TUI automation with tuivision patterns

--- 2026-02-21T17:01:46Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	case "artifact":
		return cmdRunArtifact(ctx, args[1:])
	case "tokens":
NEW: 	case "artifact":
		return cmdRunArtifact(ctx, args[1:])
	case "action":
		return cmdRunAction(ctx, args[1:])
	case "tokens":

--- 2026-02-21T17:01:56Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	var project, goal, scopeID, phasesJSON, projects string
	complexity := 3
	var tokenBudget int64
	var maxDispatches, maxAgents int
	var budgetEnforce bool
	budgetWarnPct := 80
NEW: 	var project, goal, scopeID, phasesJSON, projects, actionsJSON string
	complexity := 3
	var tokenBudget int64
	var maxDispatches, maxAgents int
	var budgetEnforce bool
	budgetWarnPct := 80

--- 2026-02-21T17:02:08Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 			maxAgents = v
		default:
			fmt.Fprintf(os.Stderr, "ic: run create: unknown flag: %s\n", args[i])
			return 3
		}
	}
NEW: 			maxAgents = v
		case strings.HasPrefix(args[i], "--actions="):
			actionsJSON = strings.TrimPrefix(args[i], "--actions=")
		default:
			fmt.Fprintf(os.Stderr, "ic: run create: unknown flag: %s\n", args[i])
			return 3
		}
	}

--- 2026-02-21T17:02:33Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	id, err := store.Create(ctx, run)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: run create: %v\n", err)
		return 2
	}

	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(map[string]interface{}{
			"id":    id,
			"phase": phase.PhaseBrainstorm,
		})
	} else {
		fmt.Println(id)
	}
	return 0
}
NEW: 	id, err := store.Create(ctx, run)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: run create: %v\n", err)
		return 2
	}

	// Register phase actions if --actions provided
	if actionsJSON != "" {
		var actionMap map[string]struct {
			Command string  `json:"command"`
			Args    *string `json:"args,omitempty"`
			Mode    string  `json:"mode,omitempty"`
			Type    string  `json:"type,omitempty"`
		}
		if err := json.Unmarshal([]byte(actionsJSON), &actionMap); err != nil {
			fmt.Fprintf(os.Stderr, "ic: run create: invalid --actions JSON: %v\n", err)
			return 2
		}
		aStore := action.New(d.SqlDB())
		batch := make(map[string]*action.Action, len(actionMap))
		for aPhase, spec := range actionMap {
			a := &action.Action{
				Command:    spec.Command,
				ActionType: spec.Type,
				Mode:       spec.Mode,
				Args:       spec.Args,
			}
			batch[aPhase] = a
		}
		if err := aStore.AddBatch(ctx, id, batch); err != nil {
			fmt.Fprintf(os.Stderr, "ic: run create: register actions: %v\n", err)
			return 2
		}
	}

	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(map[string]interface{}{
			"id":    id,
			"phase": phase.PhaseBrainstorm,
		})
	} else {
		fmt.Println(id)
	}
	return 0
}

--- 2026-02-21T17:02:37Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	"github.com/mistakeknot/interverse/infra/intercore/internal/budget"
NEW: 	"github.com/mistakeknot/interverse/infra/intercore/internal/action"
	"github.com/mistakeknot/interverse/infra/intercore/internal/budget"

--- 2026-02-21T17:02:43Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 		fmt.Fprintf(os.Stderr, "ic: run: missing subcommand (create, status, advance, skip, rollback, phase, list, events, cancel, set, current, agent, artifact, tokens, budget)\n")
NEW: 		fmt.Fprintf(os.Stderr, "ic: run: missing subcommand (create, status, advance, skip, rollback, phase, list, events, cancel, set, current, agent, artifact, action, tokens, budget)\n")

--- 2026-02-21T17:05:16Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	if flagJSON {
		json.NewEncoder(os.Stdout).Encode(map[string]interface{}{
			"from_phase":  result.FromPhase,
			"to_phase":    result.ToPhase,
			"event_type":  result.EventType,
			"gate_result": result.GateResult,
			"gate_tier":   result.GateTier,
			"advanced":    result.Advanced,
			"reason":      result.Reason,
		})
	} else {
		if result.Advanced {
			fmt.Printf("%s → %s\n", result.FromPhase, result.ToPhase)
		} else {
			fmt.Printf("%s (blocked: %s)\n", result.FromPhase, result.EventType)
		}
	}
NEW: 	// Resolve actions for the destination phase
	var resolvedActions []*action.Action
	if result.Advanced {
		aStore := action.New(d.SqlDB())
		resolvedActions, _ = aStore.ListForPhaseResolved(ctx, id, result.ToPhase, run.ProjectDir)
	}

	if flagJSON {
		out := map[string]interface{}{
			"from_phase":  result.FromPhase,
			"to_phase":    result.ToPhase,
			"event_type":  result.EventType,
			"gate_result": result.GateResult,
			"gate_tier":   result.GateTier,
			"advanced":    result.Advanced,
			"reason":      result.Reason,
		}
		if len(resolvedActions) > 0 {
			items := make([]map[string]interface{}, len(resolvedActions))
			for i, a := range resolvedActions {
				items[i] = actionToMap(a)
			}
			out["actions"] = items
		}
		json.NewEncoder(os.Stdout).Encode(out)
	} else {
		if result.Advanced {
			fmt.Printf("%s → %s\n", result.FromPhase, result.ToPhase)
			for _, a := range resolvedActions {
				argsStr := ""
				if a.Args != nil {
					argsStr = " " + *a.Args
				}
				fmt.Printf("  → %s%s  [%s]\n", a.Command, argsStr, a.Mode)
			}
		} else {
			fmt.Printf("%s (blocked: %s)\n", result.FromPhase, result.EventType)
		}
	}

--- 2026-02-21T17:05:57Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: # --- Version sync check ---
NEW: # --- Phase Actions (Event-Driven Advancement) ---
echo ""
echo "=== Phase Actions ==="

# Create a run for action tests
ACT_RUN=$(ic --db="$TEST_DB" run create --project="$TEST_DIR" --goal="Action test")
pass "create run for actions"

# Add an action
ADD_OUT=$(ic --db="$TEST_DB" --json run action add "$ACT_RUN" --phase=planned --command=/clavain:work --args='["plan.md"]' --mode=interactive)
ACT_ID=$(echo "$ADD_OUT" | jq -r '.id')
[[ "$ACT_ID" != "null" && "$ACT_ID" != "" ]] || fail "action add: no id returned"
pass "action add"

# Add second action for a different phase
ic --db="$TEST_DB" run action add "$ACT_RUN" --phase=executing --command=/clavain:quality-gates --mode=both >/dev/null
pass "action add (second phase)"

# List actions for a specific phase
LIST_OUT=$(ic --db="$TEST_DB" --json run action list "$ACT_RUN" --phase=planned)
LIST_COUNT=$(echo "$LIST_OUT" | jq 'length')
[[ "$LIST_COUNT" == "1" ]] || fail "action list: expected 1 action for planned, got $LIST_COUNT"
LIST_CMD=$(echo "$LIST_OUT" | jq -r '.[0].command')
[[ "$LIST_CMD" == "/clavain:work" ]] || fail "action list: expected /clavain:work, got $LIST_CMD"
pass "action list (by phase)"

# List all actions for run
LIST_ALL=$(ic --db="$TEST_DB" --json run action list "$ACT_RUN")
ALL_COUNT=$(echo "$LIST_ALL" | jq 'length')
[[ "$ALL_COUNT" == "2" ]] || fail "action list all: expected 2, got $ALL_COUNT"
pass "action list (all)"

# Update an action
ic --db="$TEST_DB" run action update "$ACT_RUN" --phase=planned --command=/clavain:work --args='["updated.md"]' >/dev/null
UPD_OUT=$(ic --db="$TEST_DB" --json run action list "$ACT_RUN" --phase=planned)
UPD_ARGS=$(echo "$UPD_OUT" | jq -r '.[0].args[0]')
[[ "$UPD_ARGS" == "updated.md" ]] || fail "action update: expected updated.md, got $UPD_ARGS"
pass "action update"

# Duplicate detection
DUP_OUT=$(ic --db="$TEST_DB" run action add "$ACT_RUN" --phase=planned --command=/clavain:work 2>&1) && fail "action add duplicate: should have failed" || true
pass "action add duplicate rejected"

# Delete an action
ic --db="$TEST_DB" run action delete "$ACT_RUN" --phase=planned --command=/clavain:work >/dev/null
DEL_OUT=$(ic --db="$TEST_DB" --json run action list "$ACT_RUN" --phase=planned)
DEL_COUNT=$(echo "$DEL_OUT" | jq 'length')
[[ "$DEL_COUNT" == "0" ]] || fail "action delete: expected 0, got $DEL_COUNT"
pass "action delete"

# Actions in advance output — add action for brainstorm phase, advance, check output
ic --db="$TEST_DB" run action add "$ACT_RUN" --phase=brainstorm --command=/clavain:brainstorm --mode=interactive >/dev/null
ADV_OUT=$(ic --db="$TEST_DB" --json run advance "$ACT_RUN" --priority=4)
ADV_ACTIONS=$(echo "$ADV_OUT" | jq '.actions // [] | length')
[[ "$ADV_ACTIONS" -ge 1 ]] || fail "advance: expected actions in output, got $ADV_ACTIONS"
ADV_CMD=$(echo "$ADV_OUT" | jq -r '.actions[0].command')
[[ "$ADV_CMD" == "/clavain:brainstorm" ]] || fail "advance: expected /clavain:brainstorm, got $ADV_CMD"
pass "advance includes resolved actions"

# Batch add via --actions on create
BATCH_RUN=$(ic --db="$TEST_DB" run create --project="$TEST_DIR" --goal="Batch action test" --actions='{"planned":{"/interflux:flux-drive":{"args":"[\"plan.md\"]","mode":"interactive"}},"executing":{"/clavain:work":{"mode":"both"}}}')
BATCH_LIST=$(ic --db="$TEST_DB" --json run action list "$BATCH_RUN")
BATCH_COUNT=$(echo "$BATCH_LIST" | jq 'length')
[[ "$BATCH_COUNT" == "2" ]] || fail "batch action: expected 2, got $BATCH_COUNT"
pass "batch action registration via --actions"

echo "  Phase actions tests passed"

# --- Version sync check ---

--- 2026-02-21T17:06:19Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: # Batch add via --actions on create
BATCH_RUN=$(ic --db="$TEST_DB" run create --project="$TEST_DIR" --goal="Batch action test" --actions='{"planned":{"/interflux:flux-drive":{"args":"[\"plan.md\"]","mode":"interactive"}},"executing":{"/clavain:work":{"mode":"both"}}}')
BATCH_LIST=$(ic --db="$TEST_DB" --json run action list "$BATCH_RUN")
BATCH_COUNT=$(echo "$BATCH_LIST" | jq 'length')
[[ "$BATCH_COUNT" == "2" ]] || fail "batch action: expected 2, got $BATCH_COUNT"
pass "batch action registration via --actions"
NEW: # Batch add via --actions on create
BATCH_RUN=$(ic --db="$TEST_DB" run create --project="$TEST_DIR" --goal="Batch action test" --actions='{"planned":{"command":"/interflux:flux-drive","args":"[\"plan.md\"]","mode":"interactive"},"executing":{"command":"/clavain:work","mode":"both"}}')
BATCH_LIST=$(ic --db="$TEST_DB" --json run action list "$BATCH_RUN")
BATCH_COUNT=$(echo "$BATCH_LIST" | jq 'length')
[[ "$BATCH_COUNT" == "2" ]] || fail "batch action: expected 2, got $BATCH_COUNT"
pass "batch action registration via --actions"

--- 2026-02-21T17:06:53Z | infra/intercore/test-integration.sh | CONTEXT:unknown ---
OLD: # Actions in advance output — add action for brainstorm phase, advance, check output
ic --db="$TEST_DB" run action add "$ACT_RUN" --phase=brainstorm --command=/clavain:brainstorm --mode=interactive >/dev/null
ADV_OUT=$(ic --db="$TEST_DB" --json run advance "$ACT_RUN" --priority=4)
ADV_ACTIONS=$(echo "$ADV_OUT" | jq '.actions // [] | length')
[[ "$ADV_ACTIONS" -ge 1 ]] || fail "advance: expected actions in output, got $ADV_ACTIONS"
ADV_CMD=$(echo "$ADV_OUT" | jq -r '.actions[0].command')
[[ "$ADV_CMD" == "/clavain:brainstorm" ]] || fail "advance: expected /clavain:brainstorm, got $ADV_CMD"
pass "advance includes resolved actions"
NEW: # Actions in advance output — register action for destination phase, advance, check output
# Run starts at brainstorm; advancing goes to brainstorm-reviewed
ic --db="$TEST_DB" run action add "$ACT_RUN" --phase=brainstorm-reviewed --command=/clavain:strategy --mode=interactive >/dev/null
ADV_OUT=$(ic --db="$TEST_DB" --json run advance "$ACT_RUN" --priority=4)
ADV_ACTIONS=$(echo "$ADV_OUT" | jq '.actions // [] | length')
[[ "$ADV_ACTIONS" -ge 1 ]] || fail "advance: expected actions in output, got $ADV_ACTIONS"
ADV_CMD=$(echo "$ADV_OUT" | jq -r '.actions[0].command')
[[ "$ADV_CMD" == "/clavain:strategy" ]] || fail "advance: expected /clavain:strategy, got $ADV_CMD"
pass "advance includes resolved actions"

--- 2026-02-21T17:07:54Z | infra/intercore/lib-intercore.sh | CONTEXT:unknown ---
OLD: intercore_run_code_rollback() {
    local run_id="$1" filter_phase="${2:-}"
    if ! intercore_available; then return 1; fi
    local args=(run rollback "$run_id" --layer=code)
    [[ -n "$filter_phase" ]] && args+=(--phase="$filter_phase")
    "$INTERCORE_BIN" "${args[@]}" ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}
NEW: intercore_run_code_rollback() {
    local run_id="$1" filter_phase="${2:-}"
    if ! intercore_available; then return 1; fi
    local args=(run rollback "$run_id" --layer=code)
    [[ -n "$filter_phase" ]] && args+=(--phase="$filter_phase")
    "$INTERCORE_BIN" "${args[@]}" ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}

# --- Phase Action wrappers ---

# intercore_run_action_add — Register a phase action for a run.
# Args: $1=run_id, $2=phase, $3=command, $4=mode (optional), $5=args_json (optional)
# Prints: JSON with id
# Returns: 0 on success, 1 on duplicate, 2+ on error
intercore_run_action_add() {
    local run_id="$1" phase="$2" command="$3" mode="${4:-interactive}" args_json="${5:-}"
    if ! intercore_available; then return 1; fi
    local cmd_args=(--json run action add "$run_id" --phase="$phase" --command="$command" --mode="$mode")
    [[ -n "$args_json" ]] && cmd_args+=(--args="$args_json")
    "$INTERCORE_BIN" "${cmd_args[@]}" ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}

# intercore_run_action_list — List actions for a run, optionally filtered by phase.
# Args: $1=run_id, $2=phase (optional)
# Prints: JSON array of actions
# Returns: 0 on success, 1 on failure
intercore_run_action_list() {
    local run_id="$1" phase="${2:-}"
    if ! intercore_available; then return 1; fi
    local cmd_args=(--json run action list "$run_id")
    [[ -n "$phase" ]] && cmd_args+=(--phase="$phase")
    "$INTERCORE_BIN" "${cmd_args[@]}" ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}

# intercore_run_action_delete — Delete a phase action.
# Args: $1=run_id, $2=phase, $3=command
# Returns: 0 on success, 1 on not found
intercore_run_action_delete() {
    local run_id="$1" phase="$2" command="$3"
    if ! intercore_available; then return 1; fi
    "$INTERCORE_BIN" run action delete "$run_id" --phase="$phase" --command="$command" \
        ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}

# intercore_run_advance — Advance a run to the next phase.
# Args: $1=run_id, $2=priority (optional, default 0)
# Prints: JSON with from_phase, to_phase, advanced, actions, etc.
# Returns: 0 on success (advanced), 1 on blocked/not found
intercore_run_advance() {
    local run_id="$1" priority="${2:-0}"
    if ! intercore_available; then return 1; fi
    "$INTERCORE_BIN" --json run advance "$run_id" --priority="$priority" \
        ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}

--- 2026-02-21T17:08:33Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD: sprint_next_step() {
    local phase="$1"
    case "$phase" in
        brainstorm)          echo "strategy" ;;
        brainstorm-reviewed) echo "strategy" ;;
        strategized)         echo "write-plan" ;;
        planned)             echo "flux-drive" ;;
        plan-reviewed)       echo "work" ;;
        executing)           echo "quality-gates" ;;
        shipping)            echo "reflect" ;;
        reflect)             echo "done" ;;
        done)                echo "done" ;;
        *)                   echo "brainstorm" ;;
    esac
}
NEW: sprint_next_step() {
    local phase="$1"

    # Query kernel for registered phase actions (if run exists)
    if [[ -n "${CLAVAIN_BEAD_ID:-}" ]]; then
        local run_id
        run_id=$(_sprint_resolve_run_id "$CLAVAIN_BEAD_ID" 2>/dev/null) || run_id=""
        if [[ -n "$run_id" ]]; then
            local actions
            actions=$(intercore_run_action_list "$run_id" "$phase" 2>/dev/null) || actions="[]"
            local count
            count=$(echo "$actions" | jq 'length' 2>/dev/null) || count=0
            if [[ "$count" -gt 0 ]]; then
                # Return the highest-priority action's command
                local cmd
                cmd=$(echo "$actions" | jq -r '.[0].command' 2>/dev/null) || cmd=""
                if [[ -n "$cmd" ]]; then
                    # Map command names to sprint step names
                    case "$cmd" in
                        /clavain:brainstorm)       echo "brainstorm" ;;
                        /clavain:strategy)         echo "strategy" ;;
                        /clavain:write-plan)       echo "write-plan" ;;
                        /interflux:flux-drive)     echo "flux-drive" ;;
                        /clavain:work)             echo "work" ;;
                        /clavain:quality-gates)    echo "quality-gates" ;;
                        /clavain:resolve)          echo "ship" ;;
                        /reflect|/clavain:reflect) echo "reflect" ;;
                        *)                         echo "$cmd" ;;
                    esac
                    return 0
                fi
            fi
        fi
    fi

    # Fallback: static phase→step mapping
    case "$phase" in
        brainstorm)          echo "strategy" ;;
        brainstorm-reviewed) echo "strategy" ;;
        strategized)         echo "write-plan" ;;
        planned)             echo "flux-drive" ;;
        plan-reviewed)       echo "work" ;;
        executing)           echo "quality-gates" ;;
        shipping)            echo "reflect" ;;
        reflect)             echo "done" ;;
        done)                echo "done" ;;
        *)                   echo "brainstorm" ;;
    esac
}

--- 2026-02-21T17:09:06Z | infra/intercore/CLAUDE.md | CONTEXT:unknown ---
OLD: ic run artifact add <run> --phase=brainstorm --path=docs/brainstorms/x.md
ic run artifact list <run> --phase=brainstorm
```

## Lock Quick Reference
NEW: ic run artifact add <run> --phase=brainstorm --path=docs/brainstorms/x.md
ic run artifact list <run> --phase=brainstorm

# Phase actions (event-driven advancement)
ic run action add <run> --phase=planned --command=/interflux:flux-drive --args='["plan.md"]' --mode=interactive
ic run action list <run> [--phase=planned]
ic run action update <run> --phase=planned --command=/interflux:flux-drive --args='["new.md"]'
ic run action delete <run> --phase=planned --command=/interflux:flux-drive
ic run create --project=. --goal="..." --actions='{"planned":{"command":"/clavain:work","mode":"interactive"}}'
```

## Lock Quick Reference

--- 2026-02-21T17:09:19Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: - `run_agents` — tracks agents within a run (FK: `run_id → runs.id`)
- `run_artifacts` — tracks files produced during a run (FK: `run_id → runs.id`)

Foreign keys are enforced (`PRAGMA foreign_keys = ON` set in `db.Open()`).
NEW: - `run_agents` — tracks agents within a run (FK: `run_id → runs.id`)
- `run_artifacts` — tracks files produced during a run (FK: `run_id → runs.id`)
- `phase_actions` — registered actions per phase (FK: `run_id → runs.id`, UNIQUE: `run_id, phase, command`)

Foreign keys are enforced (`PRAGMA foreign_keys = ON` set in `db.Open()`).

--- 2026-02-21T17:09:31Z | infra/intercore/AGENTS.md | CONTEXT:unknown ---
OLD: intercore_run_budget <run_id>                              # Budget check (JSON, exit 1=exceeded)
intercore_dispatch_tokens <id> <in> <out> [cache]          # Update dispatch token counts
intercore_gate_check <run_id>                              # Gate check (0=pass, 1=fail, 2+=error)
intercore_gate_override <run_id> <reason>                  # Force-advance past failed gate
```
NEW: intercore_run_budget <run_id>                              # Budget check (JSON, exit 1=exceeded)
intercore_dispatch_tokens <id> <in> <out> [cache]          # Update dispatch token counts
intercore_gate_check <run_id>                              # Gate check (0=pass, 1=fail, 2+=error)
intercore_gate_override <run_id> <reason>                  # Force-advance past failed gate
intercore_run_advance <run_id> [priority]                  # Advance phase (JSON with actions)
intercore_run_action_add <run_id> <phase> <cmd> [mode] [args]  # Register action
intercore_run_action_list <run_id> [phase]                 # List actions (JSON)
intercore_run_action_delete <run_id> <phase> <cmd>         # Remove action
```

### Phase Actions (Event-Driven Advancement)

Phase actions map phase transitions to commands. Registered at run creation via `--actions` flag or individually via `ic run action add`. Template variables (`${artifact:<type>}`, `${run_id}`, `${project_dir}`) are resolved at advance time.

When `ic run advance` succeeds, the JSON output includes an `actions` array with resolved actions for the destination phase. `sprint_next_step()` in lib-sprint.sh queries the kernel first, falling back to the static routing table.

**Action fields:** `phase`, `command` (slash command), `args` (JSON array with placeholders), `mode` (interactive|autonomous|both), `priority` (ordering), `action_type` (command|spawn|hook).

--- 2026-02-21T17:09:49Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: | A3 | **Event-driven advancement** — phase transitions trigger automatic agent dispatch | iv-r9j2 | Open (P2) | A2 |
NEW: | A3 | **Event-driven advancement** — phase transitions trigger automatic agent dispatch. Schema v14: `phase_actions` table, action CRUD store, CLI (`ic run action`), template resolution (`${artifact:*}`, `${run_id}`, `${project_dir}`), advance output includes resolved actions, `sprint_next_step()` queries kernel first. | iv-r9j2 | **Done** | A2 |

--- 2026-02-21T17:14:41Z | infra/intercore/cmd/ic/action.go | CONTEXT:unknown ---
OLD: import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/mistakeknot/interverse/infra/intercore/internal/action"
)
NEW: import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/mistakeknot/interverse/infra/intercore/internal/action"
)

--- 2026-02-21T17:14:47Z | infra/intercore/cmd/ic/action.go | CONTEXT:unknown ---
OLD: 		if err == action.ErrDuplicate {
NEW: 		if errors.Is(err, action.ErrDuplicate) {

--- 2026-02-21T17:14:50Z | infra/intercore/cmd/ic/action.go | CONTEXT:unknown ---
OLD: 		if err == action.ErrNotFound {
NEW: 		if errors.Is(err, action.ErrNotFound) {

--- 2026-02-21T17:14:59Z | infra/intercore/lib-intercore.sh | CONTEXT:unknown ---
OLD: # intercore_run_action_delete — Delete a phase action.
# Args: $1=run_id, $2=phase, $3=command
# Returns: 0 on success, 1 on not found
intercore_run_action_delete() {
NEW: # intercore_run_action_update — Update a phase action's args, mode, or priority.
# Args: $1=run_id, $2=phase, $3=command, $4=field=value pairs (--args=, --mode=, --priority=)
# Returns: 0 on success, 1 on not found
intercore_run_action_update() {
    local run_id="$1" phase="$2" command="$3"
    shift 3
    if ! intercore_available; then return 1; fi
    local cmd_args=(run action update "$run_id" --phase="$phase" --command="$command")
    cmd_args+=("$@")
    "$INTERCORE_BIN" "${cmd_args[@]}" ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}

# intercore_run_action_delete — Delete a phase action.
# Args: $1=run_id, $2=phase, $3=command
# Returns: 0 on success, 1 on not found
intercore_run_action_delete() {

--- 2026-02-21T17:15:07Z | infra/intercore/cmd/ic/action.go | CONTEXT:unknown ---
OLD: 	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"
NEW: 	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"

--- 2026-02-21T17:15:16Z | infra/intercore/cmd/ic/action.go | CONTEXT:unknown ---
OLD: 	case strings.HasPrefix(arg, "--priority="):
			fmt.Sscanf(strings.TrimPrefix(arg, "--priority="), "%d", &priority)
		default:
			positional = append(positional, arg)
		}
	}

	if len(positional) < 1 {
		fmt.Fprintf(os.Stderr, "ic: run action add: usage: ic run action add <run_id> --phase=<p> --command=<c>\n")
NEW: 	case strings.HasPrefix(arg, "--priority="):
			v, err := strconv.Atoi(strings.TrimPrefix(arg, "--priority="))
			if err != nil {
				fmt.Fprintf(os.Stderr, "ic: run action add: invalid --priority: %s\n", strings.TrimPrefix(arg, "--priority="))
				return 3
			}
			priority = v
		default:
			positional = append(positional, arg)
		}
	}

	if len(positional) < 1 {
		fmt.Fprintf(os.Stderr, "ic: run action add: usage: ic run action add <run_id> --phase=<p> --command=<c>\n")

--- 2026-02-21T17:15:32Z | infra/intercore/cmd/ic/action.go | CONTEXT:unknown ---
OLD: 	case strings.HasPrefix(arg, "--priority="):
			fmt.Sscanf(strings.TrimPrefix(arg, "--priority="), "%d", &priority)
		default:
			positional = append(positional, arg)
		}
	}

	if len(positional) < 1 || phase == "" || command == "" {
		fmt.Fprintf(os.Stderr, "ic: run action update: usage: ic run action update <run_id> --phase=<p> --command=<c> [--args=...] [--mode=...]
NEW: 	case strings.HasPrefix(arg, "--priority="):
			v, err := strconv.Atoi(strings.TrimPrefix(arg, "--priority="))
			if err != nil {
				fmt.Fprintf(os.Stderr, "ic: run action update: invalid --priority: %s\n", strings.TrimPrefix(arg, "--priority="))
				return 3
			}
			priority = v
		default:
			positional = append(positional, arg)
		}
	}

	if len(positional) < 1 || phase == "" || command == "" {
		fmt.Fprintf(os.Stderr, "ic: run action update: usage: ic run action update <run_id> --phase=<p> --command=<c> [--args=...] [--mode=...]

--- 2026-02-21T17:16:21Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	// Resolve actions for the destination phase
	var resolvedActions []*action.Action
	if result.Advanced {
		aStore := action.New(d.SqlDB())
		resolvedActions, _ = aStore.ListForPhaseResolved(ctx, id, result.ToPhase, run.ProjectDir)
	}
NEW: 	// Resolve actions for the destination phase
	var resolvedActions []*action.Action
	if result.Advanced {
		aStore := action.New(d.SqlDB())
		var actErr error
		resolvedActions, actErr = aStore.ListForPhaseResolved(ctx, id, result.ToPhase, run.ProjectDir)
		if actErr != nil {
			fmt.Fprintf(os.Stderr, "ic: run advance: warning: action resolution failed: %v\n", actErr)
		}
	}

--- 2026-02-21T17:16:33Z | infra/intercore/internal/action/store.go | CONTEXT:unknown ---
OLD: import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"
)
NEW: import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"
)

--- 2026-02-21T17:16:46Z | infra/intercore/internal/action/store.go | CONTEXT:unknown ---
OLD: // resolveTemplateVars replaces ${artifact:<type>}, ${run_id}, ${project_dir} in a string.
func (s *Store) resolveTemplateVars(ctx context.Context, runID, projectDir, input string) string {
	// Resolve ${artifact:<type>}
	result := templateVarRE.ReplaceAllStringFunc(input, func(match string) string {
		sub := templateVarRE.FindStringSubmatch(match)
		if len(sub) < 2 {
			return match
		}
		artType := sub[1]
		var path string
		err := s.db.QueryRowContext(ctx,
			`SELECT path FROM run_artifacts WHERE run_id = ? AND type = ? AND status = 'active' ORDER BY created_at DESC LIMIT 1`,
			runID, artType,
		).Scan(&path)
		if err != nil {
			return match // leave unresolved
		}
		return path
	})

	// Resolve ${run_id}
	result = strings.ReplaceAll(result, "${run_id}", runID)

	// Resolve ${project_dir}
	result = strings.ReplaceAll(result, "${project_dir}", projectDir)

	return result
}
NEW: // resolveTemplateVars replaces ${artifact:<type>}, ${run_id}, ${project_dir} in a string.
// Values are JSON-escaped before substitution to prevent injection into the JSON args string.
func (s *Store) resolveTemplateVars(ctx context.Context, runID, projectDir, input string) string {
	// Resolve ${artifact:<type>}
	result := templateVarRE.ReplaceAllStringFunc(input, func(match string) string {
		sub := templateVarRE.FindStringSubmatch(match)
		if len(sub) < 2 {
			return match
		}
		artType := sub[1]
		var path string
		err := s.db.QueryRowContext(ctx,
			`SELECT path FROM run_artifacts WHERE run_id = ? AND type = ? AND status = 'active' ORDER BY created_at DESC LIMIT 1`,
			runID, artType,
		).Scan(&path)
		if err != nil {
			return match // leave unresolved
		}
		return jsonEscapeValue(path)
	})

	// Resolve ${run_id}
	result = strings.ReplaceAll(result, "${run_id}", jsonEscapeValue(runID))

	// Resolve ${project_dir}
	result = strings.ReplaceAll(result, "${project_dir}", jsonEscapeValue(projectDir))

	return result
}

// jsonEscapeValue escapes a string for safe embedding in a JSON string context.
// It uses json.Marshal to get proper escaping, then strips the surrounding quotes.
func jsonEscapeValue(s string) string {
	b, err := json.Marshal(s)
	if err != nil {
		return s
	}
	// Strip surrounding quotes from the marshaled JSON string
	return string(b[1 : len(b)-1])
}

--- 2026-02-21T17:17:03Z | infra/intercore/internal/action/store_test.go | CONTEXT:unknown ---
OLD: func strPtr(s string) *string { return &s }
NEW: func TestResolveJSONEscaping(t *testing.T) {
	db := setupTestDB(t)
	ctx := context.Background()

	// Insert an artifact with a path containing a double-quote
	_, err := db.Exec(`INSERT INTO run_artifacts (id, run_id, phase, path, type, status) VALUES ('art-esc', 'test-run-1', 'planned', 'docs/plan "v2".md', 'plan', 'active')`)
	if err != nil {
		t.Fatal(err)
	}

	s := New(db)
	_, err = s.Add(ctx, &Action{RunID: "test-run-1", Phase: "plan-reviewed", Command: "/test", Args: strPtr(`["${artifact:plan}"]`)})
	if err != nil {
		t.Fatal(err)
	}

	actions, err := s.ListForPhaseResolved(ctx, "test-run-1", "plan-reviewed", ".")
	if err != nil {
		t.Fatal(err)
	}
	// The path contains a double-quote; it must be JSON-escaped
	want := `["docs/plan \"v2\".md"]`
	if actions[0].Args == nil || *actions[0].Args != want {
		t.Errorf("expected JSON-escaped args %s, got %v", want, *actions[0].Args)
	}
}

func strPtr(s string) *string { return &s }

--- 2026-02-21T17:18:03Z | infra/intercore/cmd/ic/run.go | CONTEXT:unknown ---
OLD: 	id, err := store.Create(ctx, run)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: run create: %v\n", err)
		return 2
	}

	// Register phase actions if --actions provided
	if actionsJSON != "" {
		var actionMap map[string]struct {
			Command string  `json:"command"`
			Args    *string `json:"args,omitempty"`
			Mode    string  `json:"mode,omitempty"`
			Type    string  `json:"type,omitempty"`
		}
		if err := json.Unmarshal([]byte(actionsJSON), &actionMap); err != nil {
			fmt.Fprintf(os.Stderr, "ic: run create: invalid --actions JSON: %v\n", err)
			return 2
		}
		aStore := action.New(d.SqlDB())
		batch := make(map[string]*action.Action, len(actionMap))
		for aPhase, spec := range actionMap {
			a := &action.Action{
				Command:    spec.Command,
				ActionType: spec.Type,
				Mode:       spec.Mode,
				Args:       spec.Args,
			}
			batch[aPhase] = a
		}
		if err := aStore.AddBatch(ctx, id, batch); err != nil {
			fmt.Fprintf(os.Stderr, "ic: run create: register actions: %v\n", err)
			return 2
		}
	}
NEW: 	// Parse --actions JSON before creating the run (fail-fast, no orphaned runs)
	var actionBatch map[string]*action.Action
	if actionsJSON != "" {
		var actionMap map[string]struct {
			Command string  `json:"command"`
			Args    *string `json:"args,omitempty"`
			Mode    string  `json:"mode,omitempty"`
			Type    string  `json:"type,omitempty"`
		}
		if err := json.Unmarshal([]byte(actionsJSON), &actionMap); err != nil {
			fmt.Fprintf(os.Stderr, "ic: run create: invalid --actions JSON: %v\n", err)
			return 2
		}
		actionBatch = make(map[string]*action.Action, len(actionMap))
		for aPhase, spec := range actionMap {
			a := &action.Action{
				Command:    spec.Command,
				ActionType: spec.Type,
				Mode:       spec.Mode,
				Args:       spec.Args,
			}
			actionBatch[aPhase] = a
		}
	}

	id, err := store.Create(ctx, run)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ic: run create: %v\n", err)
		return 2
	}

	// Register phase actions after run creation (JSON already validated above)
	if actionBatch != nil {
		aStore := action.New(d.SqlDB())
		if err := aStore.AddBatch(ctx, id, actionBatch); err != nil {
			fmt.Fprintf(os.Stderr, "ic: run create: register actions: %v\n", err)
			return 2
		}
	}

--- 2026-02-21T17:43:51Z | plugins/intermux/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD:       "env": {
        "INTERMUTE_URL": "http://127.0.0.1:7338",
        "TMUX_SOCKET": "/tmp/tmux-0/default"
      }
NEW:       "env": {
        "INTERMUTE_URL": "http://127.0.0.1:7338"
      }

--- 2026-02-21T17:44:01Z | plugins/intermux/internal/tmux/watcher.go | CONTEXT:unknown ---
OLD: 	sessions, err := listSessions()
	if err != nil {
		// tmux not running is normal
		return
	}
NEW: 	sessions, err := listSessions()
	if err != nil {
		// tmux not running is normal, but log for diagnosability
		log.Printf("intermux: listSessions error: %v", err)
		return
	}

--- 2026-02-21T17:44:47Z | docs/research/synthesize-research-agenda-bullets.md | CONTEXT:unknown ---
OLD: # Research Agenda Synthesis

## Thematic Research Bullets

- **Lens-driven agent review (linsenkasten)** — FLUX podcast cognitive augmentation lenses for agent evaluation, MCP integration, severity classification, and phase-specific agent selection

- **Sprint resilience and kernel handoff** — Resume tracking, fault tolerance, multi-layer rollback recovery, and bidirectional bead↔kernel sync to migrate sprint state to intercore kernel

- **Token efficiency and cost-aware dispatch** — Lazy skill loading, token budget controls per sprint, dispatch cost tracking, and write-behind for subagent context results

- **Document slicing and context compression** — Per-agent section filtering via interserve, import-graph compression, block compression, precomputed context bundles, and symbol-popularity indexing

- **Intercore kernel evolution (E3→E8)** — Hook cutover for sprint state, spawn handler wiring, discovery pipeline for kernel-native research intake, and portfolio orchestration across projects

- **Multi-session agent coordination** — Merge review for multi-agent sessions, hierarchical dispatch meta-agent, session-start drift summary injection, and autonomous sync mechanics

- **Plugin ecosystem and synergy** — Dual-mode architecture (standalone + integrated), cross-plugin interoperability catalog, plugin-synergy discovery, and unified interbus central integration mesh

- **Portfolio and dependency scheduling** — Cross-project portfolio runs with parent-child linking, dependency-aware phase scheduling, TOCTOU guards, and portfolio relay patterns

- **Dashboard and visualization** — Bigend TUI kernel state migration, autarch status tool validation, interchart D3 force graph ecosystem diagram, and tui-kernel validation patterns

- **Event-driven phase advancement** — Automatic phase transition dispatch, event-driven run progression, terminal status exhaustiveness, and gate check flow

- **Thematic sprint organization** — Label-based work lanes for sequencing, shift-work boundary formalization, blueprint distillation sprint intake, and role-aware memory experiments

- **Framework and context optimization** — Multi-framework interoperability benchmarking, repository-aware benchmark expansion, context freshness automation via interwatch, and reminder escalation patterns

- **Advanced state management** — Hierarchical config resolution for model routing, static routing tables, drift detection summaries, and bias-aware product decision frameworks

- **Code extraction and tools** — Interscribe symbol extraction, structured output serialization, longcodezip block compression, and advanced TUI automation with tuivision patterns
NEW: # Interverse Research Agenda — Synthesized Bullets

## Core Kernel & Orchestration (11 items)

- **Intercore kernel expansion (E1-E9)** — Complete kernel primitives, event reactor, hook cutover (E3), discovery pipeline (E5), rollback/recovery (E6), portfolio orchestration (E8), dependency scheduling (E9), cost-aware scheduling

- **Sprint workflow migration to kernel** — Rewrite lib-sprint.sh to use `ic run` for phase management, sentinels, gates, artifacts, dispatches; single source of truth with audit trail

- **Event-driven phase advancement** — Wire phase_actions table to kernel; sprint reads kernel actions instead of bash case statements; enable autonomous dispatch via hook handlers

- **Cross-project portfolio orchestration** — Multi-project runs with child coordination, dependency graphs, cross-project relay, portfolio gates, max-dispatch limits

- **Sprint resilience & phase recovery** — Automated failure recovery with rollback primitives, gate enforcement, durable kernel state, audit trail for recovery decisions

- **Reflect phase integration** — Wire formal reflect step between resolve/ship; `/reflect` registers artifacts satisfying kernel gate; close recursive self-improvement loop

- **Session-aware sprint resumption** — Auto-detect active sprints via `ic run list`; resume from any step; checkpoint mechanism; prevent duplicate dispatch on restart

- **Multi-session coordination & merge agents** — Support multi-session agent rigs with upstream sync, merge agents for conflict resolution, kernel event coordination

- **Ambient discovery & research engine** — Kernel-backed discovery tables with confidence gates, embedding dedup, relevance decay, feedback; Interject writes to kernel; enable autonomous work discovery

- **Institutional knowledge indexing** — Cross-repo solution doc index via Interlearn; propagate findings; schema for incident reports, patterns, learnings

- **Hierarchical config resolution** — Cascading defaults: phase-specific model → phase default category → system defaults; supports role-aware routing and capability dispatch

## Cognitive & Review Augmentation (6 items)

- **Lens-augmented agents for flux-drive** — Integrate 288 FLUX analytical lenses into flux-drive review; create specialized lens agents (fd-systems, fd-decisions, fd-people, fd-resilience, fd-perception)

- **Plugin synergy & cross-plugin interop** — Wire analytics publishers (intercheck, interstat, interlock); enrich statusline (interline) with pressure/coordination/budget; unify staleness detection

- **Multi-agent synthesis & verdict routing** — Consolidate flux-drive verdict aggregation; cost-effectiveness feedback to Interspect; auto-create beads from P0/P1 findings

- **Dual-mode plugin architecture** — Centralized interbase.sh SDK, per-plugin stubs, integration.json manifests, companion nudge protocol; validate with interflux migration

- **Companion discovery & nudge protocol** — Machine-readable companion graph; smart nudge mechanism with session budget/dismissal tracking; ecosystem-only routing

- **Flux-drive document slicing** — Split large docs for parallel review; triage pre-filtering; domain-specific specialization; interserve context compression

## Efficiency & Resource Management (5 items)

- **Token budget controls & cost-aware scheduling** — Enforce budgets at sprint/phase granularity; soft gates on exhaustion; Interspect learns cost-effectiveness; flux-drive adjusts by remaining budget

- **Token-efficient skill injection** — Precomputed bundles, import graph compression, block compression, symbol-popularity indexing

- **Subagent context isolation & flooding prevention** — Isolate subagent context; strict budget envelope; tier-based dispatch limits; synthesis-driven compression

- **Framework benchmark freshness** — Auto-detect/rollback stale benchmarks; monitor repository freshness; multi-framework interoperability testing; token efficiency via interstat

- **Document slicing & context compression** — Per-agent section filtering, import-graph compression, block compression, precomputed bundles, symbol-popularity indexing

## Infrastructure & Tooling (4 items)

- **Intercore E3 hook cutover** — Migrate Clavain hooks from temp files to kernel sentinels; one source of truth; durable event audit trail; hard gate enforcement

- **Autarch status TUI** — Bubble Tea tool for sprint visualization; phase progress, dispatches, events, token consumption; 3s polling; validates kernel query APIs

- **Bigend TUI kernel migration** — Port TUI from beads/file-based state to kernel; UnifiedStatus enum; consolidate dashboard/run-list/dispatch-detail views

- **Ecosystem visualization & navigation** — Interactive D3.js diagram of 31+ plugins, 50+ skills, MCP servers; click-to-expand; type filters; self-contained HTML

## Autonomy & Learning Loops (4 items)

- **Cost-aware agent scheduling** — Schedule by cost/capability tradeoffs; compute effectiveness (findings per 1K tokens); route high-effectiveness to high-impact; feed back to dispatch eligibility

- **Interspect evidence & learning feedback** — Capture learnings via Reflect phase; record agent effectiveness signals; feed to Interspect evidence for routing; iterative improvement

- **Blueprint distillation & sprint intake** — Extract patterns from completed sprints; auto-generate templates; improve phase estimates from history; blueprint-driven initialization

- **Role-aware latent memory experiments** — Per-agent memory profiles; bias-aware product decisions; contextualize recommendations by capability tier and performance

--- 2026-02-21T18:05:34Z | os/clavain/hooks/lib-intercore.sh | CONTEXT:unknown ---
OLD: # --- Run wrappers ---

# intercore_run_current — Get the active run ID for a project.
NEW: # --- Run wrappers ---

# intercore_run_create — Create a new ic run.
# Args: $1=project_dir, $2=goal, $3=phases_json, $4=scope_id (optional),
#       $5=complexity (optional, default 3), $6=token_budget (optional),
#       $7=actions_json (optional, e.g. '{"planned":{"command":"/clavain:work","mode":"interactive"}}')
# Prints: run ID to stdout
# Returns: 0 on success, 1 on failure
intercore_run_create() {
    local project="$1" goal="$2" phases_json="$3" scope_id="${4:-}" complexity="${5:-3}" token_budget="${6:-}" actions_json="${7:-}"
    if ! intercore_available; then return 1; fi
    local args=(run create --project="$project" --goal="$goal" --complexity="$complexity")
    [[ -n "$phases_json" ]] && args+=(--phases="$phases_json")
    [[ -n "$scope_id" ]] && args+=(--scope-id="$scope_id")
    [[ -n "$token_budget" ]] && args+=(--token-budget="$token_budget")
    [[ -n "$actions_json" ]] && args+=(--actions="$actions_json")
    "$INTERCORE_BIN" "${args[@]}" ${INTERCORE_DB:+--db="$INTERCORE_DB"} 2>/dev/null
}

# intercore_run_current — Get the active run ID for a project.

--- 2026-02-21T18:05:49Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD:     # Create ic run (required — this is the state backend)
    local phases_json='["brainstorm","brainstorm-reviewed","strategized","planned","plan-reviewed","executing","shipping","reflect","done"]'
    local complexity="${2:-3}"
    local token_budget
    token_budget=$(_sprint_default_budget "$complexity")
    local run_id
    run_id=$(intercore_run_create "$(pwd)" "$title" "$phases_json" "$scope_id" "$complexity" "$token_budget") || run_id=""
NEW:     # Create ic run (required — this is the state backend)
    local phases_json='["brainstorm","brainstorm-reviewed","strategized","planned","plan-reviewed","executing","shipping","reflect","done"]'
    local complexity="${2:-3}"
    local token_budget
    token_budget=$(_sprint_default_budget "$complexity")

    # Default phase actions for kernel-driven routing (matches sprint_next_step fallback table)
    # Keys = phase where you ARE, values = command to run at that phase
    # Args is a string containing a JSON array (ic CLI expects *string, not raw array)
    local default_actions='{"brainstorm":{"command":"/clavain:strategy","mode":"interactive"},"strategized":{"command":"/clavain:write-plan","mode":"interactive"},"planned":{"command":"/interflux:flux-drive","args":"[\"${artifact:plan}\"]","mode":"interactive"},"plan-reviewed":{"command":"/clavain:work","args":"[\"${artifact:plan}\"]","mode":"both"},"executing":{"command":"/clavain:quality-gates","mode":"interactive"},"shipping":{"command":"/clavain:reflect","mode":"interactive"}}'

    local run_id
    run_id=$(intercore_run_create "$(pwd)" "$title" "$phases_json" "$scope_id" "$complexity" "$token_budget" "$default_actions") || run_id=""

--- 2026-02-21T18:10:41Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: **Version:** 0.6.48
**Last updated:** 2026-02-20
NEW: **Version:** 0.6.60
**Last updated:** 2026-02-21

--- 2026-02-21T18:10:47Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: Clavain is an autonomous software agency — 15 skills, 4 agents, 52 commands, 22 hooks, 1 MCP server. 31 companion plugins in the inter-* constellation. 1000 beads tracked, 660 closed, 339 open. Runs on its own TUI (Autarch), backed by Intercore kernel and Interspect profiler.
NEW: Clavain is an autonomous software agency — 16 skills, 4 agents, 53 commands, 22 hooks, 1 MCP server. 31 companion plugins in the inter-* constellation. 1419 beads tracked, 1098 closed, 321 open. Runs on its own TUI (Autarch), backed by Intercore kernel and Interspect profiler.

--- 2026-02-21T18:10:59Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: ### What's Not Working Yet

- **Hook cutover complete, sprint handover pending.** E3 hook cutover shipped — all sprint state management uses `ic` CLI with beads fallback. Next: make the sprint skill fully kernel-driven (A2).
- **No adaptive model routing.** Static routing exists (stage→model mapping), but no complexity-aware or outcome-driven selection.
- **Agency architecture is implicit.** Sub-agencies (Discover/Design/Build/Ship) are encoded in skills and hooks, not in declarative specs or a fleet registry.
- **Outcome measurement limited.** Interspect collects evidence but no override has been applied. Cost-per-change and quality metrics are unquantified. (Token budgets now tracked per-sprint via iv-pbmc, done.)
NEW: ### What's Not Working Yet

- **No adaptive model routing.** Static routing (B1) and complexity-aware routing (B2) shipped. Next: Interspect outcome data driving model selection (B3).
- **Agency architecture is implicit.** Sub-agencies (Discover/Design/Build/Ship) are encoded in skills and hooks, not in declarative specs or a fleet registry.
- **Outcome measurement limited.** Interspect collects evidence but no override has been applied. Cost-per-change and quality metrics are unquantified.

--- 2026-02-21T18:11:19Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: Major features that landed since the 0.6.22 roadmap:

| Feature | Description |
|---------|-------------|
| **E3 Hook cutover** | Clavain sprint state management migrated from beads-only to ic-primary with beads fallback. Sprint CRUD, agent tracking, phase advancement all flow through intercore. Migration script + event reactor hooks. |
| **Intercore kernel (E1-E2)** | Go CLI + SQLite — runs, phases, gates, dispatches, events as durable state. Kernel primitives and event reactor shipped. |
| **Vision rewrite** | New identity: autonomous software agency with three-layer architecture (Kernel/OS/Drivers). 13 spec gaps closed. |
| **12 new companions** | intermap, intermem, intersynth, interlens, interleave, interserve, interpeer, intertest, interkasten, interstat, interfluence, interphase v2 |
| **Monorepo consolidation** | Physical monorepo at /root/projects/Interverse with 31 companion plugins |
| **Version 0.6.22 → 0.6.43** | 21 version bumps |
NEW: Major features that landed since the 0.6.22 roadmap:

| Feature | Description |
|---------|-------------|
| **A2 Sprint handover** | Sprint skill fully kernel-driven — hybrid → handover → kernel-driven pipeline. |
| **A3 Event-driven advancement** | Schema v14 `phase_actions` table, action CRUD, CLI, template resolution, `sprint_next_step()` queries kernel actions, default actions registered at sprint creation. |
| **B1 Static routing** | Phase→model mapping declared in config, applied at dispatch. |
| **B2 Complexity-aware routing** | C1-C5 classification, zero-cost bypass, shadow mode, enforce mode. 22 new routing tests. |
| **E3 Hook cutover** | Sprint state management migrated from beads-only to ic-primary with beads fallback. |
| **E4 Interspect kernel integration** | Evidence events flow through Intercore event bus. |
| **E5 Discovery pipeline** | Kernel primitives for research intake — submit, score, promote, dismiss, decay, semantic search. |
| **E6 Rollback and recovery** | Three-layer revert — workflow state, code query, completed run rollback. |
| **E7 Autarch Phase 1** | Bigend TUI migration — dashboard, run pane, activity feed, aggregator dedup. |
| **Intercore kernel (E1-E2)** | Go CLI + SQLite — runs, phases, gates, dispatches, events as durable state. |
| **Vision rewrite** | Autonomous software agency with three-layer architecture (Kernel/OS/Drivers). |
| **31 companion plugins** | intermap, intermem, intersynth, interlens, interleave, interserve, interpeer, intertest, interkasten, interstat, interfluence, interphase v2, and more |
| **Version 0.6.22 → 0.6.60** | 38 version bumps |

--- 2026-02-21T18:11:27Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: | A2 | **Sprint handover** — sprint skill becomes kernel-driven (hybrid → handover → kernel-driven) | iv-kj6w | Open (P1) | A1 (done) |
| A3 | **Event-driven advancement** — phase transitions trigger automatic agent dispatch. Schema v14: `phase_actions` table, action CRUD store, CLI (`ic run action`), template resolution (`${artifact:*}`, `${run_id}`, `${project_dir}`), advance output includes resolved actions, `sprint_next_step()` queries kernel first. | iv-r9j2 | **Done** | A2 |
NEW: | A2 | **Sprint handover** — sprint skill becomes kernel-driven (hybrid → handover → kernel-driven) | iv-kj6w | **Done** | A1 (done) |
| A3 | **Event-driven advancement** — phase transitions trigger automatic agent dispatch. Schema v14: `phase_actions` table, action CRUD store, CLI (`ic run action`), template resolution (`${artifact:*}`, `${run_id}`, `${project_dir}`), advance output includes resolved actions, `sprint_next_step()` queries kernel first, default actions registered at sprint creation. | iv-r9j2 | **Done** | A2 (done) |

--- 2026-02-21T18:11:37Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: | B1 | **Static routing table** — phase→model mapping declared in config, applied at dispatch | iv-dd9q | Open (P2) | — |
| B2 | **Complexity-aware routing** — task complexity drives model selection within phases. Design with zero-cost abstraction (disabled = static path, no overhead) and shadow mode for safe rollout. See [pi_agent_rust lessons](brainstorms/2026-02-19-pi-agent-rust-lessons-brainstorm.md) §3. | iv-k8xn | Open (P2) | B1 |
| B3 | **Adaptive routing** — Interspect outcome data drives model/agent selection | iv-i198 | Open (P3) | B2, Interspect (iv-thp7) |
NEW: | B1 | **Static routing table** — phase→model mapping declared in config, applied at dispatch | iv-dd9q | **Done** | — |
| B2 | **Complexity-aware routing** — C1-C5 classification, zero-cost bypass (disabled = static path), shadow mode, enforce mode. 22 new tests. | iv-k8xn | **Done** | B1 (done) |
| B3 | **Adaptive routing** — Interspect outcome data drives model/agent selection | iv-i198 | Open (P3) | B2 (done), Interspect E4 (done) |

--- 2026-02-21T18:11:46Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: | C2 | **Agent fleet registry** — capability + cost profiles per agent×model combination | iv-lx00 | Open (P2) | B1, C1 |
| C3 | **Composer** — matches agency specs to fleet registry within budget constraints | iv-240m | Open (P3) | C1, C2 |
| C4 | **Cross-phase handoff** — structured protocol for how Discover's output becomes Design's input | iv-1vny | Open (P3) | C1 |
| C5 | **Self-building loop** — Clavain uses its own agency specs to run its own development sprints | iv-6ixw | Open (P3) | C3, C4, A3 |
NEW: | C2 | **Agent fleet registry** — capability + cost profiles per agent×model combination | iv-lx00 | Open (P2) | B1 (done), C1 |
| C3 | **Composer** — matches agency specs to fleet registry within budget constraints | iv-240m | Open (P3) | C1, C2 |
| C4 | **Cross-phase handoff** — structured protocol for how Discover's output becomes Design's input | iv-1vny | Open (P3) | C1 |
| C5 | **Self-building loop** — Clavain uses its own agency specs to run its own development sprints | iv-6ixw | Open (P3) | C3, C4, A3 (done) |

--- 2026-02-21T18:11:54Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: ```
Track A (Kernel)      Track B (Routing)     Track C (Agency)
    A1                    B1                    C1
    │                     │                     │
    A2                    B2───────────────→    C2
    │                     │                     │
    A3                    B3                    C3
    │                                           │
    └───────────────────────────────────────→   C4
                                                │
                                               C5 ← convergence
                                          (self-building)
```
NEW: ```
Track A (Kernel)      Track B (Routing)     Track C (Agency)
    A1 ✓                  B1 ✓                  C1
    │                     │                     │
    A2 ✓                  B2 ✓─────────────→    C2
    │                     │                     │
    A3 ✓                  B3                    C3
    │                                           │
    └───────────────────────────────────────→   C4
                                                │
                                               C5 ← convergence
                                          (self-building)
```

--- 2026-02-21T18:12:01Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: | E3 | Hook cutover — big-bang Clavain migration | iv-ngvy | **Done** |
| E4 | Level 3 Adapt — Interspect kernel event integration | iv-thp7 | Open (P2) |
| E5 | Discovery pipeline — kernel primitives for research intake | iv-fra3 | Open (P2) |
| E6 | Rollback and recovery — three-layer revert | iv-0k8s | Open (P2) |
| E7 | Autarch Phase 1 — Bigend migration + `ic tui` | iv-ishl | Open (P2) |
NEW: | E3 | Hook cutover — big-bang Clavain migration | iv-ngvy | **Done** |
| E4 | Level 3 Adapt — Interspect kernel event integration | iv-thp7 | **Done** |
| E5 | Discovery pipeline — kernel primitives for research intake | iv-fra3 | **Done** |
| E6 | Rollback and recovery — three-layer revert | iv-0k8s | **Done** |
| E7 | Autarch Phase 1 — Bigend migration + `ic tui` | iv-ishl | **Done** |

--- 2026-02-21T18:12:14Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: | Metric | Value |
|--------|-------|
| Total beads | 1000 |
| Closed | 660 |
| Open | 339 |
| In progress | 1 |

Key completed epics:
- **iv-66so** — Vision refresh: autonomous software agency (P1, done)
- **iv-ngvy** — E3: Hook cutover — big-bang Clavain migration to `ic` (P1, done)

Key active work:
- **iv-kj6w** — A2: Sprint handover — sprint skill becomes kernel-driven (P1)
- **iv-thp7** — E4: Level 3 Adapt — Interspect kernel event integration (P2)

Recently closed:
- **iv-pbmc** — Cost-aware agent scheduling with token budgets (P1, done)
- **iv-3krg** — Wire /reflect step into sprint.md orchestration (P2, done)
- **iv-yeka** — Update roadmap.md for new vision + parallel tracks (P1, done)
NEW: | Metric | Value |
|--------|-------|
| Total beads | 1419 |
| Closed | 1098 |
| Open | 321 |
| In progress | 0 |

Key completed epics:
- **iv-66so** — Vision refresh: autonomous software agency (P1, done)
- **iv-ngvy** — E3: Hook cutover — big-bang Clavain migration to `ic` (P1, done)
- **iv-kj6w** — A2: Sprint handover — kernel-driven sprint pipeline (P1, done)
- **iv-lype** — A3: Event-driven advancement — phase actions (P2, done)
- **iv-thp7** — E4: Interspect kernel integration (P1, done)
- **iv-fra3** — E5: Discovery pipeline (P2, done)
- **iv-0k8s** — E6: Rollback and recovery (P1, done)
- **iv-ishl** — E7: Autarch Phase 1 — Bigend TUI (P1, done)

Key active work:
- **iv-asfy** — C1: Agency specs — declarative per-stage config (P2)
- **iv-i198** — B3: Adaptive routing — Interspect-driven model selection (P3)

Recently closed:
- **iv-r9j2** — A3: Event-driven advancement — kernel-driven routing with fallback (P2, done)
- **iv-k8xn** — B2: Complexity-aware routing with zero-cost bypass (P2, done)
- **iv-dd9q** — B1: Static routing table (P2, done)

--- 2026-02-21T18:12:20Z | os/clavain/docs/roadmap.md | CONTEXT:unknown ---
OLD: *Synthesized from: [`docs/clavain-vision.md`](clavain-vision.md), [`docs/PRD.md`](PRD.md), 1000 beads, 31 companion plugins, and the Intercore kernel vision. Sources linked throughout.*
NEW: *Synthesized from: [`docs/clavain-vision.md`](clavain-vision.md), [`docs/PRD.md`](PRD.md), 1419 beads, 31 companion plugins, and the Intercore kernel vision. Sources linked throughout.*

--- 2026-02-21T18:16:16Z | .gitignore | CONTEXT:unknown ---
OLD: # ── Intermem state (per-project, not committed) ──
.intermem/
NEW: # ── Intermem state (per-project, not committed) ──
.intermem/

# ── Research clones (not part of monorepo) ──
frankentui-research/

--- 2026-02-21T22:21:00Z | .gitignore | CONTEXT:unknown ---
OLD: # Interverse monorepo .gitignore
# Each subproject has its own .git — ignore them all here.
# Only the monorepo skeleton, beads, and shared docs are tracked.

# ── Subproject directories (each has its own repo) ──
hub/
plugins/
services/
infra/*
sdk/*
NEW: # Demarch monorepo .gitignore
# Each subproject has its own .git — ignore them all here.
# Only the monorepo skeleton, beads, and shared docs are tracked.

# ── Subproject directories (each has its own repo) ──
apps/
os/
core/
interverse/
sdk/*

--- 2026-02-21T22:21:54Z | scripts/sync-roadmap-json.sh | CONTEXT:unknown ---
OLD: for base in "$ROOT_DIR/hub" "$ROOT_DIR/plugins" "$ROOT_DIR/services"; do
NEW: for base in "$ROOT_DIR/apps" "$ROOT_DIR/os" "$ROOT_DIR/core" "$ROOT_DIR/interverse"; do

--- 2026-02-21T22:21:55Z | scripts/sync-roadmap-json.sh | CONTEXT:unknown ---
OLD:     echo "No modules discovered under hub/, plugins/, or services/" >&2
NEW:     echo "No modules discovered under apps/, os/, core/, or interverse/" >&2

--- 2026-02-21T22:21:57Z | scripts/interbump.sh | CONTEXT:unknown ---
OLD:     if [ -f "$dir/infra/marketplace/.claude-plugin/marketplace.json" ]; then
        MARKETPLACE_ROOT="$dir/infra/marketplace"
NEW:     if [ -f "$dir/core/marketplace/.claude-plugin/marketplace.json" ]; then
        MARKETPLACE_ROOT="$dir/core/marketplace"

--- 2026-02-21T22:21:58Z | scripts/interbump.sh | CONTEXT:unknown ---
OLD:     echo -e "${RED}Error: Cannot find marketplace (tried infra/marketplace/ and ../interagency-marketplace/)${NC}" >&2
NEW:     echo -e "${RED}Error: Cannot find marketplace (tried core/marketplace/ and ../interagency-marketplace/)${NC}" >&2

--- 2026-02-21T22:22:00Z | scripts/intercheck-versions.sh | CONTEXT:unknown ---
OLD:     if [ -f "$dir/infra/marketplace/.claude-plugin/marketplace.json" ]; then
        MARKETPLACE_JSON="$dir/infra/marketplace/.claude-plugin/marketplace.json"
NEW:     if [ -f "$dir/core/marketplace/.claude-plugin/marketplace.json" ]; then
        MARKETPLACE_JSON="$dir/core/marketplace/.claude-plugin/marketplace.json"

--- 2026-02-21T22:22:08Z | scripts/consolidate-module-docs.sh | CONTEXT:unknown ---
OLD: declare -A MODULE_DEST=(
  [interject]="plugins/interject/docs"
  [intercore]="infra/intercore/docs"
  [clavain]="os/clavain/docs"
  [interspect]="infra/intercore/docs"
  [interfluence]="plugins/interfluence/docs"
  [interlock]="plugins/interlock/docs"
  [interstat]="plugins/interstat/docs"
  [interserve]="plugins/interserve/docs"
  [intermap]="plugins/intermap/docs"
  [intercheck]="plugins/intercheck/docs"
  [interflux]="plugins/interflux/docs"
  [intersynth]="plugins/intersynth/docs"
)
NEW: declare -A MODULE_DEST=(
  [interject]="interverse/interject/docs"
  [intercore]="core/intercore/docs"
  [clavain]="os/clavain/docs"
  [interspect]="core/intercore/docs"
  [interfluence]="interverse/interfluence/docs"
  [interlock]="interverse/interlock/docs"
  [interstat]="interverse/interstat/docs"
  [interserve]="interverse/interserve/docs"
  [intermap]="interverse/intermap/docs"
  [intercheck]="interverse/intercheck/docs"
  [interflux]="interverse/interflux/docs"
  [intersynth]="interverse/intersynth/docs"
)

--- 2026-02-21T22:22:09Z | scripts/consolidate-module-docs.sh | CONTEXT:unknown ---
OLD: mkdir -p "plugins/interlens/docs/research/flux-drive"
NEW: mkdir -p "interverse/interlens/docs/research/flux-drive"

--- 2026-02-21T22:22:16Z | scripts/consolidate-module-docs.sh | CONTEXT:unknown ---
OLD:   ["docs/research/flux-drive/2026-02-15-interspect-routing-overrides"]="infra/intercore/docs/research/flux-drive/2026-02-15-interspect-routing-overrides"
  ["docs/research/flux-drive/2026-02-15-interspect-routing-overrides-plan"]="infra/intercore/docs/research/flux-drive/2026-02-15-interspect-routing-overrides-plan"
  ["docs/research/flux-drive/interspect-overlay-plan"]="infra/intercore/docs/research/flux-drive/interspect-overlay-plan"
  ["docs/research/flux-drive/intermap-extraction"]="plugins/intermap/docs/research/flux-drive/intermap-extraction"
  ["docs/research/flux-drive/2026-02-15-interlens-flux-agents"]="plugins/interlens/docs/research/flux-drive/2026-02-15-interlens-flux-agents"
  ["docs/research/flux-drive/clavain-token-efficiency-trio"]="os/clavain/docs/research/flux-drive/clavain-token-efficiency-trio"
  ["docs/research/flux-drive/2026-02-16-token-budget-controls"]="plugins/interstat/docs/research/flux-drive/2026-02-16-token-budget-controls"
NEW:   ["docs/research/flux-drive/2026-02-15-interspect-routing-overrides"]="core/intercore/docs/research/flux-drive/2026-02-15-interspect-routing-overrides"
  ["docs/research/flux-drive/2026-02-15-interspect-routing-overrides-plan"]="core/intercore/docs/research/flux-drive/2026-02-15-interspect-routing-overrides-plan"
  ["docs/research/flux-drive/interspect-overlay-plan"]="core/intercore/docs/research/flux-drive/interspect-overlay-plan"
  ["docs/research/flux-drive/intermap-extraction"]="interverse/intermap/docs/research/flux-drive/intermap-extraction"
  ["docs/research/flux-drive/2026-02-15-interlens-flux-agents"]="interverse/interlens/docs/research/flux-drive/2026-02-15-interlens-flux-agents"
  ["docs/research/flux-drive/clavain-token-efficiency-trio"]="os/clavain/docs/research/flux-drive/clavain-token-efficiency-trio"
  ["docs/research/flux-drive/2026-02-16-token-budget-controls"]="interverse/interstat/docs/research/flux-drive/2026-02-16-token-budget-controls"

--- 2026-02-21T22:22:22Z | scripts/install-index-hooks.sh | CONTEXT:unknown ---
OLD: # Installs a pre-push hook in every .git directory under hub/, plugins/, services/,
# infra/, and the root. The hook checks if any docs/solutions/*.md files are in the
NEW: # Installs a pre-push hook in every .git directory under apps/, os/, core/,
# interverse/, and the root. The hook checks if any docs/solutions/*.md files are in the

--- 2026-02-21T22:22:24Z | scripts/install-index-hooks.sh | CONTEXT:unknown ---
OLD: INDEXER="$INTERVERSE_ROOT/plugins/interlearn/scripts/index-solutions.sh"
NEW: INDEXER="$INTERVERSE_ROOT/interverse/interlearn/scripts/index-solutions.sh"

--- 2026-02-21T22:22:26Z | scripts/gen-skill-compact.sh | CONTEXT:unknown ---
OLD: KNOWN_SKILLS=(
    "plugins/interwatch/skills/doc-watch"
    "plugins/interpath/skills/artifact-gen"
    "plugins/interflux/skills/flux-drive"
)
NEW: KNOWN_SKILLS=(
    "interverse/interwatch/skills/doc-watch"
    "interverse/interpath/skills/artifact-gen"
    "interverse/interflux/skills/flux-drive"
)

--- 2026-02-21T22:25:36Z | docs/guides/plugin-troubleshooting.md | CONTEXT:unknown ---
OLD: 3. `infra/marketplace/.claude-plugin/marketplace.json` — catalog
NEW: 3. `core/marketplace/.claude-plugin/marketplace.json` — catalog

--- 2026-02-21T22:25:36Z | docs/guides/interband-sideband-protocol.md | CONTEXT:unknown ---
OLD: 2. Monorepo path (`.../infra/interband/lib/interband.sh`)
NEW: 2. Monorepo path (`.../core/interband/lib/interband.sh`)

--- 2026-02-21T22:25:39Z | docs/guides/shell-and-tooling-patterns.md | CONTEXT:unknown ---
OLD: - `plugins/interlearn/docs/solutions/patterns/awk-sub-pattern-fallthrough-20260221.md`
- `plugins/tldr-swinton/docs/solutions/workflow-issues/bd-commands-hang-stale-startlock-20260213.md`
NEW: - `interverse/interlearn/docs/solutions/patterns/awk-sub-pattern-fallthrough-20260221.md`
- `interverse/tldr-swinton/docs/solutions/workflow-issues/bd-commands-hang-stale-startlock-20260213.md`

--- 2026-02-21T22:25:43Z | docs/guides/data-integrity-patterns.md | CONTEXT:unknown ---
OLD: - `services/intermute/docs/solutions/database-issues/silent-json-errors-sqlite-storage-20260211.md`
NEW: - `core/intermute/docs/solutions/database-issues/silent-json-errors-sqlite-storage-20260211.md`

--- 2026-02-21T22:25:43Z | docs/guides/multi-agent-coordination.md | CONTEXT:unknown ---
OLD: - `plugins/interlock/docs/solutions/2026-02-16-advisory-only-timeout-eliminates-toctou.md`
- `plugins/tldr-swinton/docs/solutions/best-practices/parallel-agents-miss-cross-cutting-schema-bugs.md`
NEW: - `interverse/interlock/docs/solutions/2026-02-16-advisory-only-timeout-eliminates-toctou.md`
- `interverse/tldr-swinton/docs/solutions/best-practices/parallel-agents-miss-cross-cutting-schema-bugs.md`

--- 2026-02-21T22:25:45Z | docs/architecture.md | CONTEXT:unknown ---
OLD: - [Intercore Vision](infra/intercore/docs/product/intercore-vision.md) — kernel design and roadmap
- [Clavain Vision](os/clavain/docs/clavain-vision.md) — OS layer design and workflow
- [Autarch Vision](hub/autarch/docs/autarch-vision.md) — apps layer and TUI strategy
- [Interverse Vision](interverse-vision.md) — ecosystem overview and adoption ladder
- [Compatibility Contract](infra/intercore/COMPATIBILITY.md) — stability guarantees for external consumers
NEW: - [Intercore Vision](core/intercore/docs/product/intercore-vision.md) — kernel design and roadmap
- [Clavain Vision](os/clavain/docs/clavain-vision.md) — OS layer design and workflow
- [Autarch Vision](apps/autarch/docs/autarch-vision.md) — apps layer and TUI strategy
- [Demarch Vision](demarch-vision.md) — project overview and adoption ladder
- [Compatibility Contract](core/intercore/COMPATIBILITY.md) — stability guarantees for external consumers

--- 2026-02-21T22:26:01Z | docs/diagrams/ecosystem.html | CONTEXT:unknown ---
OLD:       "label": "Interverse",
      "description": "Monorepo for the inter-module ecosystem",
      "meta": {
        "repoUrl": "https://github.com/mistakeknot/Interverse"
      }
NEW:       "label": "Demarch",
      "description": "Autonomous software agency — Interverse plugin ecosystem",
      "meta": {
        "repoUrl": "https://github.com/mistakeknot/Demarch"
      }

--- 2026-02-21T22:26:46Z | .claude/agents/fd-dispatch-efficiency.md | CONTEXT:unknown ---
OLD:    - `os/clavain/config/routing.yaml` — model routing policy (resolution hierarchy, phase overrides, complexity tiers)
   - `os/clavain/scripts/lib-routing.sh` — routing resolution engine
   - `os/clavain/scripts/dispatch.sh` — Codex dispatch with tier resolution
   - `os/clavain/docs/prds/2026-02-16-clavain-token-efficiency.md` — token efficiency roadmap (F1-F6)
   - `os/clavain/docs/prds/2026-02-20-static-routing-table.md` — B1 routing PRD
NEW:    - `os/clavain/config/routing.yaml` — model routing policy (resolution hierarchy, phase overrides, complexity tiers)
   - `os/clavain/scripts/lib-routing.sh` — routing resolution engine
   - `os/clavain/scripts/dispatch.sh` — Codex dispatch with tier resolution
   - `os/clavain/docs/prds/2026-02-16-clavain-token-efficiency.md` — token efficiency roadmap (F1-F6)
   - `os/clavain/docs/prds/2026-02-20-static-routing-table.md` — B1 routing PRD

--- 2026-02-21T22:26:47Z | .claude/agents/fd-dispatch-efficiency.md | CONTEXT:unknown ---
OLD: - Check `os/clavain/config/routing.yaml` for gaps in the routing policy.
NEW: - Check `os/clavain/config/routing.yaml` for gaps in the routing policy.

--- 2026-02-21T22:26:50Z | .claude/agents/fd-leverage-analysis.md | CONTEXT:unknown ---
OLD:    - `os/clavain/config/routing.yaml` — model routing policy and complexity tiers
   - `os/clavain/docs/prds/2026-02-16-clavain-token-efficiency.md` — token efficiency roadmap (F1-F6 features, implementation status)
   - `os/clavain/docs/research/audit-flux-drive-token-flow.md` — flux-drive token flow audit
   - `plugins/interstat/` — token measurement infrastructure (SQLite-backed benchmarking)
   - `plugins/tool-time/` — tool usage analytics
   - `os/clavain/docs/prds/2026-02-20-static-routing-table.md` — B1 routing table PRD
NEW:    - `os/clavain/config/routing.yaml` — model routing policy and complexity tiers
   - `os/clavain/docs/prds/2026-02-16-clavain-token-efficiency.md` — token efficiency roadmap (F1-F6 features, implementation status)
   - `os/clavain/docs/research/audit-flux-drive-token-flow.md` — flux-drive token flow audit
   - `interverse/interstat/` — token measurement infrastructure (SQLite-backed benchmarking)
   - `interverse/tool-time/` — tool usage analytics
   - `os/clavain/docs/prds/2026-02-20-static-routing-table.md` — B1 routing table PRD

--- 2026-02-21T22:26:53Z | .claude/flux-drive.yaml | CONTEXT:unknown ---
OLD: # Subprojects are Claude Code plugins (plugins/), a Go service (services/intermute/),
# and a multi-agent hub (os/clavain/).
NEW: # Subprojects are Claude Code plugins (interverse/), core infrastructure (core/),
# the OS layer (os/clavain/), and apps (apps/autarch/).

--- 2026-02-21T22:26:58Z | scripts/tests/skill_compact.bats | CONTEXT:unknown ---
OLD: $INTERVERSE_ROOT/plugins/interwatch/skills/doc-watch
NEW: $INTERVERSE_ROOT/interverse/interwatch/skills/doc-watch

--- 2026-02-21T22:26:59Z | scripts/tests/skill_compact.bats | CONTEXT:unknown ---
OLD: $INTERVERSE_ROOT/plugins/interpath/skills/artifact-gen
NEW: $INTERVERSE_ROOT/interverse/interpath/skills/artifact-gen

--- 2026-02-21T22:27:00Z | scripts/tests/skill_compact.bats | CONTEXT:unknown ---
OLD: $INTERVERSE_ROOT/plugins/interflux/skills/flux-drive
NEW: $INTERVERSE_ROOT/interverse/interflux/skills/flux-drive

--- 2026-02-21T22:27:01Z | scripts/tests/skill_compact.bats | CONTEXT:unknown ---
OLD: plugins/interwatch/skills/doc-watch plugins/interpath/skills/artifact-gen plugins/interflux/skills/flux-drive
NEW: interverse/interwatch/skills/doc-watch interverse/interpath/skills/artifact-gen interverse/interflux/skills/flux-drive

--- 2026-02-21T22:29:14Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: # Interverse — Vision Document

**Version:** 1.1
**Date:** 2026-02-19
**Status:** Draft
**See also:** [Architecture diagram](architecture.md)

---

## The Core Idea

Interverse is the infrastructure for autonomous software development. It provides a layered system — kernel, operating system, profiler, drivers, and applications — that together make it possible for AI agents to build software with the durability, discipline, and observability that production work demands.
NEW: # Demarch — Vision Document

**Version:** 2.0
**Date:** 2026-02-21
**Status:** Draft
**See also:** [Architecture diagram](architecture.md)

---

## The Core Idea

Demarch (from Alastair Reynolds' Democratic Anarchists — reflecting the continuous polling and consensus-driven architecture of the system) is the infrastructure for autonomous software development. It provides a layered system — kernel, operating system, profiler, drivers, and applications — that together make it possible for AI agents to build software with the durability, discipline, and observability that production work demands.

**Interverse** refers specifically to the ecosystem of 33+ companion plugins (`/interverse`) that extend the platform's capabilities.

--- 2026-02-22T05:55:08Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## The Pitch

Demarch is an autonomous software agency — it orchestrates the full development lifecycle from problem discovery through shipped code, using AI agents with the discipline, durability, and accountability that production work demands.

Not a coding assistant. Not an AI gateway. Not a framework for calling LLMs. An agency — a system that discovers what to build, designs a plan, builds the code, reviews it with a fleet of specialized agents, ships it, and then gets better at all of the above because it remembers what happened last time.

The whole thing is open source.
NEW: ## The Pitch

Demarch is an autonomous software agency that pushes the frontier on three axes simultaneously: state-of-the-art autonomy, uncompromising quality, and relentless token efficiency.

Most agent systems pick two. Full autonomy with quality? Expensive — you throw tokens at everything and hope the review fleet catches the mess. Autonomy with efficiency? Fast and cheap, but the output is slop. Quality with efficiency? Sure — just keep a human in the loop for every decision, defeating the point.

Demarch refuses to choose. It orchestrates the full development lifecycle from problem discovery through shipped code, using heterogeneous AI agents with the discipline, durability, and accountability that production work demands — and it gets cheaper and better every time it runs, because it learns from what happened last time.

Not a coding assistant. Not an AI gateway. Not a framework for calling LLMs. An agency that builds software with production-grade discipline at a cost that keeps declining.

The whole thing is open source.

--- 2026-02-22T05:55:16Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle — not just code generation, but discovery, design, review, testing, shipping, and compounding what was learned. And if you build a learning loop on top of that infrastructure, the system gets cheaper and better every time it runs.
NEW: The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle — not just code generation, but discovery, design, review, testing, shipping, and compounding what was learned. And if you build a learning loop on top of that infrastructure — one that measures outcomes per dollar and feeds that signal back into model routing, agent selection, and gate calibration — you get a system where autonomy, quality, and efficiency aren't tradeoffs. They're a flywheel. More autonomy produces more outcome data. More outcome data improves routing and review. Better routing cuts cost. Lower cost enables more autonomy. The system that runs the most sprints learns the fastest.

--- 2026-02-22T05:55:32Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## Design Principles
NEW: ## The Frontier

Demarch advances three axes simultaneously. Every roadmap decision, every new module, every architectural choice is filtered through this lens: does it improve at least two axes without materially weakening the third?

**Autonomy** — how much of the development lifecycle runs without human intervention. Not autonomy for its own sake, but autonomy that frees the human to operate at the strategic level where their judgment matters most. Measured by: sprint completion rate, gate pass rate on first attempt, intervention frequency at each autonomy level.

**Quality** — how good the output is. Defect escape rate, review signal precision, the ratio of actionable findings to false positives. Quality is not a phase you bolt on at the end; it's the cumulative result of discipline at every phase — brainstorm rigor, plan review depth, gate enforcement, multi-perspective code review, and the learning loop that tightens all of these over time.

**Token efficiency** — how much it costs. Not just raw tokens, but tokens per *impact*: cost per landable change, cost per actionable finding, cost per defect caught. The goal is not to spend less — it's to get more per dollar. Twelve agents should cost less than eight through orchestration optimization, *and* catch more bugs.

The flywheel connecting these three axes is Interspect. The profiler reads outcome data from every sprint and proposes configuration changes — model downgrades where Haiku catches the same issues as Opus, agent retirement where a reviewer consistently produces findings no one acts on, gate relaxation where a check always passes. Each optimization simultaneously increases autonomy (less human calibration needed), improves quality (resources reallocated to where they matter), and reduces cost (less waste). The system that ships the most sprints learns the fastest, and the system that learns the fastest ships the cheapest.

## Design Principles

--- 2026-02-22T05:55:44Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## North Star Metric

**What does it cost to ship a reviewed, tested change?**

Everything else is a supporting metric:

| Metric | What It Measures |
|--------|-----------------|
| **Tokens per landable change** | Total token spend for a sprint that produces a merged commit |
| **Defect escape rate** | Bugs found after Ship that were present during Build |
| **Cost per actionable finding** | Token cost of quality gate findings that aren't false positives |
| **Agent utilization** | % of dispatched agents whose output contributes to the final change |
| **Model routing accuracy** | % of model selections that match the outcome-optimal model |

The north star is economic because the platform play only works if other people can afford to run it. The self-building loop and compound learning are means to that end — they drive cost down and quality up over time.
NEW: ## North Star Metric

**What does it cost to ship a reviewed, tested change?**

This is the metric where the three frontier axes collapse into a single number. A low cost-per-landable-change requires all three: autonomy (the sprint ran without babysitting), quality (the change landed without rework), and efficiency (the right models and agents were selected, not the most expensive ones).

Supporting metrics, organized by axis:

| Axis | Metric | What It Measures |
|------|--------|-----------------|
| **Efficiency** | Tokens per landable change | Total token spend for a sprint that produces a merged commit |
| **Efficiency** | Agent utilization | % of dispatched agents whose output contributes to the final change |
| **Efficiency** | Model routing accuracy | % of model selections that match the outcome-optimal model |
| **Quality** | Defect escape rate | Bugs found after Ship that were present during Build |
| **Quality** | Cost per actionable finding | Token cost of quality gate findings that aren't false positives |
| **Autonomy** | Sprint completion rate | % of sprints that reach Ship without abandonment |
| **Autonomy** | Gate pass rate | % of phase transitions that pass on first attempt |
| **Learning** | Self-improvement rate | Interspect proposals that improve metrics when applied |

The north star is economic because the platform play only works if other people can afford to run it. But cost alone is a vanity metric — a system that's cheap and wrong is worthless. The point is outcomes per dollar: defects caught per token, merge-ready changes per session, signal per gate. The learning loop (Interspect) is what drives this number down over time, and the self-building loop is what generates the evidence Interspect needs to learn.

--- 2026-02-22T06:00:02Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch refuses to choose. It orchestrates the full development lifecycle from problem discovery through shipped code, using heterogeneous AI agents with the discipline, durability, and accountability that production work demands — and it gets cheaper and better every time it runs, because it learns from what happened last time.

Not a coding assistant. Not an AI gateway. Not a framework for calling LLMs. An agency that builds software with production-grade discipline at a cost that keeps declining.
NEW: Demarch refuses to choose. It orchestrates the full development lifecycle from problem discovery through shipped code, using AI agents — Claude, Codex, Gemini, GPT-5.2, Haiku, whatever's best for the task — with the discipline, durability, and accountability that shipping real software demands. And it gets cheaper and better every time it runs, because it learns from what happened last time.

Not a coding assistant. Not an AI gateway. Not a framework for calling LLMs. An agency that builds software with discipline, at a cost that keeps declining.

--- 2026-02-22T06:00:17Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **Level 0 — Record.** The kernel records what happened. Runs, phases, dispatches, artifacts — all tracked. The human drives everything. The kernel is a logbook. *(Shipped.)*

**Level 1 — Enforce.** Gates evaluate real conditions. A run cannot advance without meeting preconditions. The kernel says "no" when evidence is insufficient. The human reviews every phase transition. *(Shipped.)*

**Level 2 — React.** Events trigger automatic reactions. Phase transitions spawn agents. Completed dispatches advance phases. The human observes and intervenes on exceptions. *(Shipped.)*

**Level 3 — Adapt.** Interspect reads kernel events, correlates with outcomes, and proposes configuration changes. Agents that produce false positives get downweighted. Gate rules evolve based on evidence. The human reviews Interspect proposals. *(In progress.)*

**Level 4 — Orchestrate.** The kernel manages a portfolio of concurrent runs across multiple projects. Token budgets prevent runaway costs. Changes in one project trigger verification in dependents. The human sets portfolio goals and reviews weekly digests. *(Shipped — E8 portfolio primitives landed.)*

**Level -1 — Discover.** Before work can be recorded, it must be found. The discovery pipeline scans sources, scores relevance, and routes findings through confidence-tiered autonomy gates. *(Shipped — E5 discovery primitives landed.)*
NEW: **Level -1 — Discover.** Before work can be recorded, it must be found. The discovery pipeline scans sources, scores relevance, and routes findings through confidence-tiered autonomy gates. *(Shipped — kernel primitives landed.)*

**Level 0 — Record.** The kernel records what happened. Runs, phases, dispatches, artifacts — all tracked. The human drives everything. The kernel is a logbook. *(Shipped.)*

**Level 1 — Enforce.** Gates evaluate real conditions. A run cannot advance without meeting preconditions. The kernel says "no" when evidence is insufficient. The human reviews every phase transition. *(Shipped.)*

**Level 2 — React.** Events trigger automatic reactions. Phase transitions spawn agents. Completed dispatches advance phases. The human observes and intervenes on exceptions. *(Shipped.)*

**Level 3 — Adapt.** Interspect reads kernel events, correlates with outcomes, and proposes configuration changes. Agents that produce false positives get downweighted. Gate rules evolve based on evidence. The human reviews Interspect proposals. *(In progress — this is the current frontier.)*

**Level 4 — Orchestrate.** The kernel manages a portfolio of concurrent runs across multiple projects. Token budgets prevent runaway costs. Changes in one project trigger verification in dependents. The human sets portfolio goals and reviews weekly digests. *(Shipped — portfolio primitives landed.)*

--- 2026-02-22T06:00:28Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ### 7. Context hygiene

LLM context windows collapse under the weight of raw sub-agent outputs. Demarch prevents this through a strict write-behind protocol: when agents finish work, their raw results persist to durable storage (the kernel), but *only synthesized summaries* enter the orchestrator's context window. This prevents context flooding and allows sprints to run indefinitely without the orchestrator losing the plot.

### 8. Right model, right task

No one model is best at everything. The agency's intelligence includes knowing *which* intelligence to apply. Gemini for long-context exploration. Opus for reasoning and design. Codex for parallel implementation. Haiku for quick checks. Oracle (GPT-5.2 Pro) for cross-validation. Model routing is a first-class architectural decision, not an afterthought.

### 9. Self-building as proof
NEW: ### 7. Self-building as proof

--- 2026-02-22T06:00:36Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **Token efficiency** — how much it costs. Not just raw tokens, but tokens per *impact*: cost per landable change, cost per actionable finding, cost per defect caught. The goal is not to spend less — it's to get more per dollar. Twelve agents should cost less than eight through orchestration optimization, *and* catch more bugs.

The flywheel connecting these three axes is Interspect.
NEW: **Token efficiency** — how much it costs. Not just raw tokens, but tokens per *impact*: cost per landable change, cost per actionable finding, cost per defect caught. The goal is not to spend less — it's to get more per dollar. Twelve agents should cost less than eight through orchestration optimization, *and* catch more bugs. Two tactics make this concrete: model routing as a first-class decision (no one model is best at everything — Gemini for long-context exploration, Opus for reasoning, Codex for parallel implementation, Haiku for quick checks, Oracle for cross-validation), and context hygiene via a strict write-behind protocol (raw sub-agent output persists to the kernel, but only synthesized summaries enter the orchestrator's context window — preventing the context flooding that kills long-running sprints).

The flywheel connecting these three axes is Interspect.

--- 2026-02-22T06:00:40Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## What's Working Right Now

This is not vaporware. As of February 2026:
NEW: ## Where We Are

As of February 2026:

--- 2026-02-22T06:00:51Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch handles them with a durable kernel backed by SQLite, an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and a fleet of 33+ companion drivers that extend the system's capabilities. The kernel is a Go CLI binary. The OS is a Claude Code plugin (for now — the architecture is designed to outlive any host platform). The profiler reads the kernel's event stream and proposes improvements. The drivers wrap individual capabilities — multi-agent review, file coordination, ambient research, token-efficient code context, TUI automation, and two dozen more.

The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle
NEW: Demarch handles them with infrastructure purpose-built for the problem: a durable kernel backed by SQLite, an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and a fleet of 33+ companion drivers that extend the system's capabilities. The kernel is a Go CLI binary. The OS is a Claude Code plugin (for now — the architecture is designed to outlive any host platform). The profiler reads the kernel's event stream and proposes improvements. The drivers wrap individual capabilities — multi-agent review, file coordination, ambient research, token-efficient code context, TUI automation, and two dozen more.

But the infrastructure is not the aspiration. The aspiration is what the infrastructure makes possible.

The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle

--- 2026-02-22T07:02:31Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Research, brainstorming, and problem definition. The agency scans the landscape, identifies opportunities, and frames the problem worth solving.
NEW: Research, brainstorming, and problem definition. The agency scans sources, identifies opportunities, and frames the problem worth solving.

--- 2026-02-22T07:02:40Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch refuses to choose. It orchestrates the full development lifecycle from problem discovery through shipped code, using AI agents — Claude, Codex, Gemini, GPT-5.2, Haiku, whatever's best for the task — with the discipline, durability, and accountability that shipping real software demands. And it gets cheaper and better every time it runs, because it learns from what happened last time.
NEW: Demarch refuses to choose. It orchestrates the full development lifecycle from problem discovery through shipped code, selecting the right model for each task (Claude, Codex, Gemini, GPT-5.2, Haiku) with the discipline, durability, and accountability that shipping real software demands. And it gets cheaper and better every time it runs, because it learns from what happened last time.

--- 2026-02-22T07:02:50Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch handles them with infrastructure purpose-built for the problem: a durable kernel backed by SQLite, an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and a fleet of 33+ companion drivers that extend the system's capabilities. The kernel is a Go CLI binary. The OS is a Claude Code plugin (for now — the architecture is designed to outlive any host platform). The profiler reads the kernel's event stream and proposes improvements. The drivers wrap individual capabilities — multi-agent review, file coordination, ambient research, token-efficient code context, TUI automation, and two dozen more.
NEW: Demarch handles them with infrastructure purpose-built for the problem: a durable kernel backed by SQLite, an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and a fleet of 33+ companion drivers that extend the system's capabilities. The kernel is a Go CLI binary. The OS is a Claude Code plugin for now, though the architecture is designed to outlive any host platform. The profiler reads the kernel's event stream and proposes improvements. The drivers wrap individual capabilities: multi-agent review, file coordination, ambient research, token-efficient code context, TUI automation, and two dozen more.

--- 2026-02-22T07:03:00Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle — not just code generation, but discovery, design, review, testing, shipping, and compounding what was learned. And if you build a learning loop on top of that infrastructure — one that measures outcomes per dollar and feeds that signal back into model routing, agent selection, and gate calibration — you get a system where autonomy, quality, and efficiency aren't tradeoffs. They're a flywheel. More autonomy produces more outcome data. More outcome data improves routing and review. Better routing cuts cost. Lower cost enables more autonomy. The system that runs the most sprints learns the fastest.
NEW: The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle. Not just code generation, but discovery, design, review, testing, shipping, and compounding what was learned. And if you build a learning loop on top of that infrastructure, one that measures outcomes per dollar and feeds that signal back into model routing, agent selection, and gate calibration, you get a system where autonomy, quality, and efficiency aren't tradeoffs. They're a flywheel. More autonomy produces more outcome data. More outcome data improves routing and review. Better routing cuts cost. Lower cost enables more autonomy. The system that runs the most sprints learns the fastest.

--- 2026-02-22T07:03:08Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The kernel (Intercore)** provides mechanism. Runs, phases, gates, dispatches, events, state, locks, sentinels. It's a Go CLI binary with no daemon, no server, no background process. Every `ic` invocation opens the database, does its work, and exits. The SQLite database is the system of record. The kernel says "a gate can block a transition" — it doesn't say "brainstorm requires an artifact." That's policy, and policy belongs in the OS.
NEW: **The kernel (Intercore)** provides mechanism. Runs, phases, gates, dispatches, events, state, locks, sentinels. A Go CLI binary with no daemon, no server, no background process. Every `ic` invocation opens the database, does its work, and exits. The SQLite database is the system of record. The kernel says "a gate can block a transition." It doesn't say "brainstorm requires an artifact." That's policy, and policy belongs in the OS.

--- 2026-02-22T07:03:16Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The profiler (Interspect)** provides learning. It reads the kernel's event stream, correlates dispatch outcomes with human corrections, and proposes changes to OS configuration. Override rate, false positive rate, finding density — signals that compound over time. The profiler is what makes Demarch not just another orchestration framework; static orchestration is table stakes, but a system that improves its own agents through evidence rather than intuition is genuinely new. Interspect never modifies the kernel. It modifies the OS layer through safe, reversible overlays.
NEW: **The profiler (Interspect)** provides learning. It reads the kernel's event stream, correlates dispatch outcomes with human corrections, and proposes changes to OS configuration. Override rate, false positive rate, finding density: signals that compound over time. Static orchestration is table stakes. A system that improves its own agents through evidence rather than intuition is what makes Demarch different. Interspect never modifies the kernel. It modifies the OS layer through safe, reversible overlays.

--- 2026-02-22T07:05:31Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: LLM-based agents have a fundamental problem: nothing survives. Context windows compress. Sessions end. Networks drop. Processes crash. An agent that ran for an hour, produced three artifacts, dispatched two sub-agents, and advanced through four workflow phases leaves behind... a chat transcript. The state, the decisions, the evidence, the coordination signals — all gone.

This is not a prompting problem. It's an infrastructure problem.

Every serious software development workflow has the same needs: lifecycle management (what phase are we in?), quality gates (can we advance?), dispatch tracking (who's working on what?), event history (what happened?), and coordination (who holds the lock?). Most agent systems today handle these with temp files, environment variables, in-memory state, and hope.

Demarch handles them with infrastructure purpose-built for the problem: a durable kernel backed by SQLite, an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and a fleet of 33+ companion drivers that extend the system's capabilities. The kernel is a Go CLI binary. The OS is a Claude Code plugin for now, though the architecture is designed to outlive any host platform. The profiler reads the kernel's event stream and proposes improvements. The drivers wrap individual capabilities: multi-agent review, file coordination, ambient research, token-efficient code context, TUI automation, and two dozen more.
NEW: LLM-based agents have a fundamental problem: nothing survives. Context windows compress. Sessions end. Networks drop. Processes crash. An agent that ran for an hour, produced three artifacts, dispatched two sub-agents, and advanced through four workflow phases leaves behind... a chat transcript. The state, the decisions, the evidence, the coordination signals: gone.

Not a prompting problem. An infrastructure problem.

Serious software development workflows all need the same things: lifecycle management (what phase are we in?), quality gates (can we advance?), dispatch tracking (who's working on what?), event history (what happened?), and coordination (who holds the lock?). Most agent systems today handle these with temp files, environment variables, in-memory state, and hope.

Demarch handles them with purpose-built infrastructure: a durable kernel backed by SQLite, an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and a fleet of 33+ companion drivers that extend the system's capabilities. The kernel is a Go CLI binary. The OS is a Claude Code plugin for now, though the architecture is designed to outlive any host platform. The profiler reads the kernel's event stream and proposes improvements. The drivers wrap individual capabilities: multi-agent review, file coordination, ambient research, token-efficient code context, TUI automation, and two dozen more.

--- 2026-02-22T07:05:34Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The survival properties are the point. Each layer can be replaced, rewritten, or removed without destroying the layers beneath it. The kernel outlives the OS. The OS outlives its host platform. The apps outlive any particular rendering choice. This is practical architecture for a system that must survive the agent platform wars — not paranoia, just planning.
NEW: The survival properties are the point. Each layer can be replaced, rewritten, or removed without destroying the layers beneath it. The kernel outlives the OS. The OS outlives its host platform. The apps outlive any particular rendering choice. Practical architecture for a system that must survive the agent platform wars. Not paranoia, just planning.

--- 2026-02-22T07:05:39Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The kernel (Intercore)** provides mechanism. Runs, phases, gates, dispatches, events, state, locks, sentinels. A Go CLI binary with no daemon, no server, no background process. Every `ic` invocation opens the database, does its work, and exits. The SQLite database is the system of record. The kernel says "a gate can block a transition." It doesn't say "brainstorm requires an artifact." That's policy, and policy belongs in the OS.
NEW: **The kernel (Intercore)** provides mechanism. Runs, phases, gates, dispatches, events, state, locks, sentinels. A Go CLI binary: no daemon, no server, no background process. Every `ic` invocation opens the database, does its work, and exits. The SQLite database is the system of record. The kernel says "a gate can block a transition." It doesn't say "brainstorm requires an artifact." That's policy, and policy belongs in the OS.

--- 2026-02-22T07:05:44Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The OS (Clavain)** provides policy. Which phases make up a development sprint, what conditions must be met at each gate, which model to route each agent to, when to advance automatically. Clavain is an autonomous software agency — it orchestrates the full lifecycle from problem discovery through shipped code. It's opinionated about what "good" looks like at every phase, and those opinions are encoded in gates, review agents, and quality disciplines. Today it ships as a Claude Code plugin; the architecture is designed so the opinions survive even if the host platform doesn't.
NEW: **The OS (Clavain)** provides policy. Which phases make up a development sprint, what conditions must be met at each gate, which model to route each agent to, when to advance automatically. Clavain orchestrates the full lifecycle from problem discovery through shipped code. It's opinionated about what "good" looks like at every phase, and those opinions are encoded in gates, review agents, and quality disciplines. Today it ships as a Claude Code plugin; the architecture is designed so the opinions survive even if the host platform doesn't.

--- 2026-02-22T07:05:51Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The profiler (Interspect)** provides learning. It reads the kernel's event stream, correlates dispatch outcomes with human corrections, and proposes changes to OS configuration. Override rate, false positive rate, finding density: signals that compound over time. Static orchestration is table stakes. A system that improves its own agents through evidence rather than intuition is what makes Demarch different. Interspect never modifies the kernel. It modifies the OS layer through safe, reversible overlays.
NEW: **The profiler (Interspect)** provides learning. It reads the kernel's event stream, correlates dispatch outcomes with human corrections, and proposes changes to OS configuration. Override rate, false positive rate, finding density: signals that compound over time. Static orchestration is table stakes; a system that improves its own agents through evidence rather than intuition is what makes Demarch different. Interspect never touches the kernel. It modifies the OS layer through safe, reversible overlays.

--- 2026-02-22T07:05:56Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The drivers (companion plugins)** provide capabilities. Multi-agent review (interflux), file coordination (interlock), ambient research (interject), token-efficient code context (tldr-swinton), agent visibility (intermux), multi-agent synthesis (intersynth), and two dozen more. Each wraps one capability and extends the system through kernel primitives. Critically, every capability driver is independently installable — usable in vanilla Claude Code without Clavain, Intercore, or any other Demarch module. The full stack provides enhanced integration when present, but each driver is valuable on its own.
NEW: **The drivers (companion plugins)** provide capabilities. Multi-agent review (interflux), file coordination (interlock), ambient research (interject), token-efficient code context (tldr-swinton), agent visibility (intermux), multi-agent synthesis (intersynth), and two dozen more. Each wraps one capability and extends the system through kernel primitives. Every driver is independently installable, usable in vanilla Claude Code without Clavain, Intercore, or any other Demarch module. The full stack provides enhanced integration when present, but each driver is valuable on its own.

--- 2026-02-22T07:06:00Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The apps (Autarch)** provide surfaces. Bigend (monitoring), Gurgeh (PRD generation), Coldwine (task orchestration), Pollard (research intelligence). Each renders kernel state into interactive TUI experiences. The apps are a convenience layer — everything they do can be done via CLI.
NEW: **The apps (Autarch)** provide surfaces. Bigend (monitoring), Gurgeh (PRD generation), Coldwine (task orchestration), Pollard (research intelligence). Each renders kernel state into interactive TUI experiences. The apps are a convenience layer; everything they do can be done via CLI.

--- 2026-02-22T07:06:17Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **Autonomy** — how much of the development lifecycle runs without human intervention. Not autonomy for its own sake, but autonomy that frees the human to operate at the strategic level where their judgment matters most. Measured by: sprint completion rate, gate pass rate on first attempt, intervention frequency at each autonomy level.

**Quality** — how good the output is. Defect escape rate, review signal precision, the ratio of actionable findings to false positives. Quality is not a phase you bolt on at the end; it's the cumulative result of discipline at every phase — brainstorm rigor, plan review depth, gate enforcement, multi-perspective code review, and the learning loop that tightens all of these over time.

**Token efficiency** — how much it costs. Not just raw tokens, but tokens per *impact*: cost per landable change, cost per actionable finding, cost per defect caught. The goal is not to spend less — it's to get more per dollar. Twelve agents should cost less than eight through orchestration optimization, *and* catch more bugs. Two tactics make this concrete: model routing as a first-class decision (no one model is best at everything — Gemini for long-context exploration, Opus for reasoning, Codex for parallel implementation, Haiku for quick checks, Oracle for cross-validation), and context hygiene via a strict write-behind protocol (raw sub-agent output persists to the kernel, but only synthesized summaries enter the orchestrator's context window — preventing the context flooding that kills long-running sprints).
NEW: **Autonomy.** How much of the development lifecycle runs without human intervention. Not autonomy for its own sake, but autonomy that frees the human to operate at the strategic level where their judgment matters most. Measured by sprint completion rate, gate pass rate on first attempt, intervention frequency at each autonomy level.

**Quality.** Defect escape rate, review signal precision, the ratio of actionable findings to false positives. Quality is not a phase you bolt on at the end. It's the cumulative result of discipline at every phase: brainstorm rigor, plan review depth, gate enforcement, multi-perspective code review, and the learning loop that tightens all of these over time.

**Token efficiency.** Not just raw tokens, but tokens per *impact*: cost per landable change, cost per actionable finding, cost per defect caught. The goal is not to spend less but to get more per dollar. Twelve agents should cost less than eight through orchestration optimization, *and* catch more bugs. Two tactics make this concrete: model routing as a first-class decision (no one model is best at everything: Gemini for long-context exploration, Opus for reasoning, Codex for parallel implementation, Haiku for quick checks, Oracle for cross-validation), and context hygiene via a strict write-behind protocol (raw sub-agent output persists to the kernel, but only synthesized summaries enter the orchestrator's context window, preventing the context flooding that kills long-running sprints).

--- 2026-02-22T07:06:25Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The flywheel connecting these three axes is Interspect. The profiler reads outcome data from every sprint and proposes configuration changes — model downgrades where Haiku catches the same issues as Opus, agent retirement where a reviewer consistently produces findings no one acts on, gate relaxation where a check always passes. Each optimization simultaneously increases autonomy (less human calibration needed), improves quality (resources reallocated to where they matter), and reduces cost (less waste). The system that ships the most sprints learns the fastest, and the system that learns the fastest ships the cheapest.
NEW: The flywheel connecting these three axes is Interspect. The profiler reads outcome data from every sprint and proposes configuration changes: model downgrades where Haiku catches the same issues as Opus, agent retirement where a reviewer consistently produces findings no one acts on, gate relaxation where a check always passes. Each optimization simultaneously increases autonomy (less human calibration needed), improves quality (resources reallocated to where they matter), and reduces cost (less waste). The system that ships the most sprints learns the fastest, and the system that learns the fastest ships the cheapest.

--- 2026-02-22T07:06:30Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The kernel provides primitives. The OS provides opinions. A phase chain is a mechanism — an ordered sequence with transition rules. The decision that software development should flow through ten phases is a policy that Clavain configures at run creation time.
NEW: The kernel provides primitives. The OS provides opinions. A phase chain is a mechanism: an ordered sequence with transition rules. The decision that software development should flow through ten phases is a policy that Clavain configures at run creation time.

--- 2026-02-22T07:06:33Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: This separation is what makes the system extensible without modification. A documentation project uses `draft → review → publish`. A hotfix uses `triage → fix → verify`. A research spike uses `explore → synthesize`. The kernel doesn't care. New workflows don't require new kernel code.
NEW: That separation is what makes the system extensible without modification. A documentation project uses `draft → review → publish`. A hotfix uses `triage → fix → verify`. A research spike uses `explore → synthesize`. The kernel doesn't care. New workflows don't require new kernel code.

--- 2026-02-22T07:06:36Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: If it matters, it's in the database. Phase transitions, gate evidence, dispatch outcomes, event history — all persisted atomically in SQLite. Temp files, environment variables, and in-memory state are never acceptable for the system of record.
NEW: If it matters, it's in the database. Phase transitions, gate evidence, dispatch outcomes, event history, all persisted atomically in SQLite. Temp files, environment variables, and in-memory state are never acceptable for the system of record.

--- 2026-02-22T07:06:41Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Small, focused tools composed through explicit interfaces beat large integrated platforms. The inter-\* constellation follows Unix philosophy: each companion does one thing well. Composition works because boundaries are explicit — typed interfaces, schemas, manifests, and declarative specs rather than prompt sorcery.
NEW: Small, focused tools composed through explicit interfaces beat large integrated platforms. The inter-\* constellation follows Unix philosophy: each companion does one thing well. Composition works because boundaries are explicit (typed interfaces, schemas, manifests, and declarative specs rather than prompt sorcery).

--- 2026-02-22T07:06:47Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Every capability driver works standalone. Install interflux for multi-agent review, tldr-swinton for code context, or interlock for file coordination — without Clavain, without Intercore, without the rest of the stack. The full Demarch stack adds durable state (kernel), adaptive improvement (profiler), and opinionated workflow (OS), but these are enhancements, not prerequisites.

This constraint also prevents consolidation creep. The temptation to fold a driver into its nearest layer (interphase into Intercore, intersynth into interflux) is always wrong if it would break standalone installation.
NEW: Any capability driver works standalone. Install interflux for multi-agent review, tldr-swinton for code context, or interlock for file coordination. No Clavain, no Intercore, no rest of the stack required. The full Demarch stack adds durable state (kernel), adaptive improvement (profiler), and opinionated workflow (OS), but these are enhancements, not prerequisites.

The constraint also prevents consolidation creep. The temptation to fold a driver into its nearest layer (interphase into Intercore, intersynth into interflux) is always wrong if it would break standalone installation.

--- 2026-02-22T07:06:50Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Agents are cheap. Human focus is scarce. The system optimizes for the human's time, not the agent's. Token efficiency is not the same as attention efficiency — multi-agent output must be presented so humans can review quickly and confidently, not just cheaply.
NEW: Agents are cheap. Human focus is scarce. The system optimizes for the human's time, not the agent's. Token efficiency is not the same as attention efficiency. Multi-agent output must be presented so humans can review quickly and confidently, not just cheaply.

--- 2026-02-22T07:06:57Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The human drives strategy (what to build, which tradeoffs to accept, when to ship) while the agency drives execution (which model, which agents, what sequence, when to advance, what to review). The human is above the loop, not in it — same authority at every autonomy level, but less frequent exercise of it as the system earns trust through evidence. (More on this in the autonomy ladder below.)
NEW: The human drives strategy (what to build, which tradeoffs to accept, when to ship) while the agency drives execution (which model, which agents, what sequence, when to advance, what to review). The human is above the loop, not in it. Same authority at every autonomy level, but less frequent exercise of it as the system earns trust through evidence. (More on this in the autonomy ladder below.)

--- 2026-02-22T07:06:59Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Quality gates matter more than velocity. Agents without discipline ship slop. The system resolves all open questions before execution — ambiguity costs more during building than during planning. The review phases are not overhead; they are the product.
NEW: Quality gates matter more than velocity. Agents without discipline ship slop. The system resolves all open questions before execution because ambiguity costs more during building than during planning. The review phases are not overhead; they are the product.

--- 2026-02-22T07:07:03Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Every capability must survive contact with its own development process. Clavain builds Clavain. The agency runs its own sprints. This is the credibility engine: a system that autonomously builds itself is a more convincing proof than any benchmark. It's also the highest-fidelity eval — it tests the full stack under real conditions with real stakes.
NEW: Every capability must survive contact with its own development process. Clavain builds Clavain. The agency runs its own sprints. The credibility engine: a system that autonomously builds itself is a more convincing proof than any benchmark. Also the highest-fidelity eval, because it tests the full stack under real conditions with real stakes.

--- 2026-02-22T07:07:08Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch covers the full product development lifecycle through five macro-stages. Each macro-stage is a sub-agency — a team of models and agents selected for the work at hand.
NEW: Demarch covers the full product development lifecycle through five macro-stages. Each macro-stage is a sub-agency, a team of models and agents selected for the work at hand.

--- 2026-02-22T07:07:12Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: This is where most agent tools fall down — they treat product work as prompt fluff and skip straight to code. Demarch makes brainstorm and strategy first-class phases with real artifacts, real gates, and real review. The plan review uses flux-drive with formalized cognitive lenses (security, resilience, architecture, user experience) to combat AI consensus bias.
NEW: Most agent tools fall down here: they treat product work as prompt fluff and skip straight to code. Demarch makes brainstorm and strategy first-class phases with real artifacts, real gates, and real review. The plan review uses flux-drive with formalized cognitive lenses (security, resilience, architecture, user experience) to combat AI consensus bias.

--- 2026-02-22T07:07:15Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Codex handles parallel implementation. Opus and Sonnet handle complex reasoning. Haiku handles quick checks. Test-driven development is a discipline, not a suggestion — the TDD agents write failing tests first.
NEW: Codex handles parallel implementation. Opus and Sonnet handle complex reasoning. Haiku handles quick checks. Test-driven development is a discipline, not a suggestion; the TDD agents write failing tests first.

--- 2026-02-22T07:07:20Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Capture what was learned. The agency documents patterns discovered, mistakes caught, decisions validated, and complexity calibration data. This closes the recursive learning loop — every sprint feeds knowledge back into the system.
NEW: Capture what was learned. The agency documents patterns discovered, mistakes caught, decisions validated, and complexity calibration data. Closes the recursive learning loop: every sprint feeds knowledge back into the system.

--- 2026-02-22T07:07:22Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The system enables increasing levels of autonomous operation. Each level builds on the one below, and each is earned through measured outcomes at the previous level.
NEW: Demarch enables increasing levels of autonomous operation. Each level builds on the one below, earned through measured outcomes at the previous level.

--- 2026-02-22T07:07:37Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **Level -1 — Discover.** Before work can be recorded, it must be found. The discovery pipeline scans sources, scores relevance, and routes findings through confidence-tiered autonomy gates. *(Shipped — kernel primitives landed.)*

**Level 0 — Record.** The kernel records what happened. Runs, phases, dispatches, artifacts — all tracked. The human drives everything. The kernel is a logbook. *(Shipped.)*

**Level 1 — Enforce.** Gates evaluate real conditions. A run cannot advance without meeting preconditions. The kernel says "no" when evidence is insufficient. The human reviews every phase transition. *(Shipped.)*

**Level 2 — React.** Events trigger automatic reactions. Phase transitions spawn agents. Completed dispatches advance phases. The human observes and intervenes on exceptions. *(Shipped.)*

**Level 3 — Adapt.** Interspect reads kernel events, correlates with outcomes, and proposes configuration changes. Agents that produce false positives get downweighted. Gate rules evolve based on evidence. The human reviews Interspect proposals. *(In progress — this is the current frontier.)*

**Level 4 — Orchestrate.** The kernel manages a portfolio of concurrent runs across multiple projects. Token budgets prevent runaway costs. Changes in one project trigger verification in dependents. The human sets portfolio goals and reviews weekly digests. *(Shipped — portfolio primitives landed.)*

The earned-autonomy model means the system can't promote itself to a higher level without evidence. And the human can always intervene at any level — the authority never transfers, just the cadence of exercising it.
NEW: **Level -1: Discover.** Before work can be recorded, it must be found. The discovery pipeline scans sources, scores relevance, and routes findings through confidence-tiered autonomy gates. *(Shipped, kernel primitives landed.)*

**Level 0: Record.** The kernel records what happened. Runs, phases, dispatches, artifacts, all tracked. The human drives everything. The kernel is a logbook. *(Shipped.)*

**Level 1: Enforce.** Gates evaluate real conditions. A run cannot advance without meeting preconditions. The kernel says "no" when evidence is insufficient. The human reviews every phase transition. *(Shipped.)*

**Level 2: React.** Events trigger automatic reactions. Phase transitions spawn agents. Completed dispatches advance phases. The human observes and intervenes on exceptions. *(Shipped.)*

**Level 3: Adapt.** Interspect reads kernel events, correlates with outcomes, and proposes configuration changes. Agents that produce false positives get downweighted. Gate rules evolve based on evidence. The human reviews Interspect proposals. *(In progress, the current frontier.)*

**Level 4: Orchestrate.** The kernel manages a portfolio of concurrent runs across multiple projects. Token budgets prevent runaway costs. Changes in one project trigger verification in dependents. The human sets portfolio goals and reviews weekly digests. *(Shipped, portfolio primitives landed.)*

The earned-autonomy model means the system can't promote itself to a higher level without evidence. The human can always intervene at any level. The authority never transfers, just the cadence of exercising it.

--- 2026-02-22T07:07:41Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The inter-\* ecosystem has 37 modules organized by architectural role.
NEW: 37 modules organized by architectural role.

--- 2026-02-22T07:07:45Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Each companion started as a tightly-coupled feature inside Clavain. Tight coupling is a feature during the research phase — capabilities are built integrated, tested under real use, and extracted when the pattern stabilizes enough to stand alone. The constellation represents crystallized research outputs; each companion earned its independence through repeated, successful use.
NEW: Every companion started as a tightly-coupled feature inside Clavain. Tight coupling is a feature during the research phase: build integrated, test under real use, extract when the pattern stabilizes enough to stand alone. The constellation represents crystallized research outputs. Each companion earned its independence through repeated, successful use.

--- 2026-02-22T07:07:53Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **Stage 2: OS policy.** Plugins declare default model preferences. Clavain's routing table overrides per-project, per-run, or per-complexity-level. C1-C5 complexity classification drives model selection — not everything needs Opus. *(Shipped — static + complexity-aware routing.)*

**Stage 3: Adaptive optimization.** The agent fleet registry stores cost/quality profiles per agent×model combination. The composer optimizes the entire fleet dispatch within a budget constraint. "Run this review with $5 budget" → the composer allocates Opus to the 2 highest-impact agents and Haiku to the rest. Interspect's outcome data drives profile updates. *(Planned — this is where outcomes-per-dollar gets optimized.)*
NEW: **Stage 2: OS policy.** Plugins declare default model preferences. Clavain's routing table overrides per-project, per-run, or per-complexity-level. C1-C5 complexity classification drives model selection; not everything needs Opus. *(Shipped, static + complexity-aware routing.)*

**Stage 3: Adaptive optimization.** The agent fleet registry stores cost/quality profiles per agent×model combination. The composer optimizes the entire fleet dispatch within a budget constraint. "Run this review with $5 budget" → the composer allocates Opus to the 2 highest-impact agents and Haiku to the rest. Interspect's outcome data drives profile updates. *(Planned, where outcomes-per-dollar gets optimized.)*

--- 2026-02-22T07:07:59Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: This is the metric where the three frontier axes collapse into a single number. A low cost-per-landable-change requires all three: autonomy (the sprint ran without babysitting), quality (the change landed without rework), and efficiency (the right models and agents were selected, not the most expensive ones).
NEW: The metric where the three frontier axes collapse into a single number. A low cost-per-landable-change requires all three: autonomy (the sprint ran without babysitting), quality (the change landed without rework), and efficiency (the right models and agents were selected, not the most expensive ones).

--- 2026-02-22T07:08:04Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The north star is economic because the platform play only works if other people can afford to run it. But cost alone is a vanity metric — a system that's cheap and wrong is worthless. The point is outcomes per dollar: defects caught per token, merge-ready changes per session, signal per gate. The learning loop (Interspect) is what drives this number down over time, and the self-building loop is what generates the evidence Interspect needs to learn.
NEW: The north star is economic because the platform play only works if other people can afford to run it. But cost alone is a vanity metric. A system that's cheap and wrong is worthless. The point is outcomes per dollar: defects caught per token, merge-ready changes per session, signal per gate. Interspect drives this number down over time, and the self-building loop generates the evidence Interspect needs to learn.

--- 2026-02-22T07:08:10Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch is infrastructure for anyone building autonomous coding agents. Intercore is the kernel. Clavain is the reference OS. The personal rig is the highest-fidelity eval — the platform is built by using it to build itself.
NEW: Demarch is infrastructure for anyone building autonomous coding agents. Intercore is the kernel. Clavain is the reference OS. The personal rig is the highest-fidelity eval: built by using it to build itself.

--- 2026-02-22T07:08:13Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: 3. **Personal rig.** One product-minded engineer, as effective as a full team. The personal rig is both the daily driver and the proving ground for the platform. Optimized relentlessly for one workflow — but the architecture ensures those optimizations generalize.
NEW: 3. **Personal rig.** One product-minded engineer, as effective as a full team. The personal rig is both the daily driver and the proving ground for the platform. Optimized relentlessly for one workflow, but the architecture ensures those optimizations generalize.

--- 2026-02-22T07:08:17Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The bet is on ecosystem effects. If the kernel is good enough, people will build their own OS layers on top of it. If the OS is good enough, people will write their own companions. The value of the platform increases with every external contribution — and the learning loop (Interspect) benefits from a larger evidence base.
NEW: The bet is on ecosystem effects. If the kernel is good enough, people will build their own OS layers on top of it. If the OS is good enough, people will write their own companions. The value of the platform increases with every external contribution, and the learning loop (Interspect) benefits from a larger evidence base.

--- 2026-02-22T07:08:25Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **Track A: Kernel integration** — done. Sprint is fully kernel-driven.

**Track B: Model routing** — static and complexity-aware routing done. Next: Interspect outcome data driving model selection (B3).

**Track C: Agency architecture** — the next frontier. Declarative agency specs (C1), agent fleet registry with cost/quality profiles (C2), budget-constrained fleet composition (C3), cross-phase handoff protocol (C4), and the convergence point: a self-building loop where Clavain uses its own agency specs to run its own development sprints (C5).
NEW: **Track A: Kernel integration.** Done. Sprint is fully kernel-driven.

**Track B: Model routing.** Static and complexity-aware routing done. Next: Interspect outcome data driving model selection (B3).

**Track C: Agency architecture.** The next frontier. Declarative agency specs (C1), agent fleet registry with cost/quality profiles (C2), budget-constrained fleet composition (C3), cross-phase handoff protocol (C4), and the convergence point: a self-building loop where Clavain uses its own agency specs to run its own development sprints (C5).

--- 2026-02-22T07:08:27Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: - **Not a coding assistant.** It doesn't help you write code; it *builds software* — the full lifecycle. The coding is one phase of five.
NEW: - **Not a coding assistant.** It doesn't help you write code; it *builds software*. The coding is one phase of five.

--- 2026-02-22T07:08:31Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch (from Alastair Reynolds' Democratic Anarchists — reflecting the continuous polling and consensus-driven architecture of the system). Clavain is a protagonist from the same series. The inter-\* naming convention describes what each component does — the space *between* things. Interverse is the universe that contains them all.
NEW: Demarch (from Alastair Reynolds' Democratic Anarchists, reflecting the continuous polling and consensus-driven architecture of the system). Clavain is a protagonist from the same series. The inter-\* naming convention describes what each component does: the space *between* things. Interverse is the universe that contains them all.

--- 2026-02-22T07:08:38Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: - **Kernel:** 10 of 12 epics shipped. Runs, phases, gates, dispatches, events, discovery pipeline, rollback, portfolio orchestration, TOCTOU prevention, cost-aware scheduling — all landed and tested.
NEW: - **Kernel:** 10 of 12 epics shipped. Runs, phases, gates, dispatches, events, discovery pipeline, rollback, portfolio orchestration, TOCTOU prevention, cost-aware scheduling. All landed and tested.

--- 2026-02-22T07:08:42Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: *For layer-specific details, see the vision docs for [Intercore](../core/intercore/docs/intercore-roadmap.md) (kernel), [Clavain](../os/clavain/docs/clavain-vision.md) (OS), [Autarch](../apps/autarch/docs/autarch-vision.md) (apps), and [Interspect](#) (profiler — vision doc forthcoming).*
NEW: *For layer-specific details, see the vision docs for [Intercore](../core/intercore/docs/intercore-roadmap.md) (kernel), [Clavain](../os/clavain/docs/clavain-vision.md) (OS), [Autarch](../apps/autarch/docs/autarch-vision.md) (apps), and [Interspect](#) (profiler, vision doc forthcoming).*

--- 2026-02-22T08:16:43Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## The Constellation

37 modules organized by architectural role.

### Infrastructure

| Module | What It Does |
|--------|-------------|
| **intercore** | Orchestration kernel — runs, phases, gates, dispatches, events, state, locks |
| **interspect** | Adaptive profiler — reads kernel events, proposes OS configuration changes |
| **intermute** | Multi-agent coordination service (Go) — message routing between agents |

### Operating System

| Module | What It Does |
|--------|-------------|
| **clavain** | Autonomous software agency — the opinionated workflow, skills, hooks, routing |

### Core Drivers

| Module | Capability |
|--------|-----------|
| **interflux** | Multi-agent review and research dispatch |
| **interlock** | Multi-agent file coordination |
| **interject** | Ambient research and discovery engine |
| **tldr-swinton** | Token-efficient code context |
| **intermux** | Agent visibility and session monitoring |
| **intersynth** | Multi-agent output synthesis |
| **interserve** | Codex dispatch and context compression |

Additional drivers cover artifact generation (interpath), document freshness (interwatch), plugin publishing (interpub), cross-AI review (interpeer), Notion sync (interkasten), TUI testing (tuivision), cognitive lenses (interlens), voice adaptation (interfluence), and more. The full listing is in [CLAUDE.md](../CLAUDE.md).

### Applications

| Module | What It Does |
|--------|-------------|
| **autarch** | Interactive TUI surfaces — Bigend, Gurgeh, Coldwine, Pollard |

Every companion started as a tightly-coupled feature inside Clavain. Tight coupling is a feature during the research phase: build integrated, test under real use, extract when the pattern stabilizes enough to stand alone. The constellation represents crystallized research outputs. Each companion earned its independence through repeated, successful use.

## Model Routing

Model routing operates at three stages, each building on the one below:

**Stage 1: Kernel mechanism.** All dispatches flow through the kernel with an explicit model parameter. The kernel records which model was used, tracks token consumption, and emits events. *(Shipped.)*

**Stage 2: OS policy.** Plugins declare default model preferences. Clavain's routing table overrides per-project, per-run, or per-complexity-level. C1-C5 complexity classification drives model selection; not everything needs Opus. *(Shipped, static + complexity-aware routing.)*

**Stage 3: Adaptive optimization.** The agent fleet registry stores cost/quality profiles per agent×model combination. The composer optimizes the entire fleet dispatch within a budget constraint. "Run this review with $5 budget" → the composer allocates Opus to the 2 highest-impact agents and Haiku to the rest. Interspect's outcome data drives profile updates. *(Planned, where outcomes-per-dollar gets optimized.)*

## North Star Metric
NEW: ## North Star Metric

--- 2026-02-22T08:16:49Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## Adoption Ladder

Demarch is adoptable incrementally. Each step adds capability on top of the previous:

**Step 1: One driver.** Install a single companion plugin (interflux for code review, tldr-swinton for code context). Works in vanilla Claude Code. No other Demarch modules required.

**Step 2: Clavain (OS).** Install Clavain for the sprint workflow, quality gates, and brainstorm→ship lifecycle. Drivers are auto-discovered and integrated.

**Step 3: Intercore (kernel).** Install the `ic` CLI for durable state. Runs, phases, gates, and events persist across sessions. Crash recovery. Audit trails.

**Step 4: Interspect (profiler).** Enable the adaptive profiler. Agent routing improves based on outcome data. Gate rules tighten or relax based on evidence. The system starts learning.

**Step 5: Autarch (apps).** Install the TUI tools for interactive dashboards, PRD generation, and task orchestration.

Each step is optional. Step 1 is useful without Step 2. Step 2 is useful without Step 3. The stack rewards depth but doesn't demand it.

## Where We Are
NEW: ## Where We Are

--- 2026-02-22T08:16:56Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: *For layer-specific details, see the vision docs for [Intercore](../core/intercore/docs/intercore-roadmap.md) (kernel), [Clavain](../os/clavain/docs/clavain-vision.md) (OS), [Autarch](../apps/autarch/docs/autarch-vision.md) (apps), and [Interspect](#) (profiler, vision doc forthcoming).*
NEW: *Module inventory, model routing stages, and adoption ladder: [demarch-reference.md](./demarch-reference.md). Layer-specific vision docs: [Intercore](../core/intercore/docs/intercore-roadmap.md) (kernel), [Clavain](../os/clavain/docs/clavain-vision.md) (OS), [Autarch](../apps/autarch/docs/autarch-vision.md) (apps), [Interspect](#) (profiler, forthcoming).*

--- 2026-02-22T08:17:21Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: LLM-based agents have a fundamental problem: nothing survives. Context windows compress. Sessions end. Networks drop. Processes crash. An agent that ran for an hour, produced three artifacts, dispatched two sub-agents, and advanced through four workflow phases leaves behind... a chat transcript. The state, the decisions, the evidence, the coordination signals: gone.

Not a prompting problem. An infrastructure problem.

Serious software development workflows all need the same things: lifecycle management (what phase are we in?), quality gates (can we advance?), dispatch tracking (who's working on what?), event history (what happened?), and coordination (who holds the lock?). Most agent systems today handle these with temp files, environment variables, in-memory state, and hope.

Demarch handles them with purpose-built infrastructure: a durable kernel backed by SQLite, an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and a fleet of 33+ companion drivers that extend the system's capabilities. The kernel is a Go CLI binary. The OS is a Claude Code plugin for now, though the architecture is designed to outlive any host platform. The profiler reads the kernel's event stream and proposes improvements. The drivers wrap individual capabilities: multi-agent review, file coordination, ambient research, token-efficient code context, TUI automation, and two dozen more.

But the infrastructure is not the aspiration. The aspiration is what the infrastructure makes possible.

The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle. Not just code generation, but discovery, design, review, testing, shipping, and compounding what was learned. And if you build a learning loop on top of that infrastructure, one that measures outcomes per dollar and feeds that signal back into model routing, agent selection, and gate calibration, you get a system where autonomy, quality, and efficiency aren't tradeoffs. They're a flywheel. More autonomy produces more outcome data. More outcome data improves routing and review. Better routing cuts cost. Lower cost enables more autonomy. The system that runs the most sprints learns the fastest.
NEW: LLM-based agents have a fundamental problem: nothing survives. Context windows compress. Sessions end. Networks drop. Processes crash. An agent that ran for an hour, produced three artifacts, dispatched two sub-agents, and advanced through four workflow phases leaves behind... a chat transcript. The state, the decisions, the evidence, the coordination signals: gone. Not a prompting problem. An infrastructure problem. And most agent systems today handle it with temp files, environment variables, in-memory state, and hope.

Demarch handles it with a durable kernel (SQLite-backed Go CLI), an opinionated OS that encodes development discipline, a profiler that learns from outcomes, and 33+ companion drivers. But the infrastructure is not the aspiration.

The bet: if you build the right infrastructure beneath agents, they become capable of the full development lifecycle. Not just code generation, but discovery, design, review, testing, shipping, and compounding what was learned. And if you build a learning loop on top of that infrastructure, one that measures outcomes per dollar and feeds that signal back into model routing, agent selection, and gate calibration, you get a system where autonomy, quality, and efficiency aren't tradeoffs. They're a flywheel. More autonomy produces more outcome data. More outcome data improves routing and review. Better routing cuts cost. Lower cost enables more autonomy. The system that runs the most sprints learns the fastest.

--- 2026-02-22T08:17:33Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The human drives strategy (what to build, which tradeoffs to accept, when to ship) while the agency drives execution (which model, which agents, what sequence, when to advance, what to review). The human is above the loop, not in it. Same authority at every autonomy level, but less frequent exercise of it as the system earns trust through evidence. (More on this in the autonomy ladder below.)
NEW: The human drives strategy (what to build, which tradeoffs to accept, when to ship) while the agency drives execution (which model, which agents, what sequence, when to advance, what to review). The human is above the loop, not in it. The autonomy ladder below defines what "above the loop" looks like at each level.

--- 2026-02-22T08:17:38Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The earned-autonomy model means the system can't promote itself to a higher level without evidence. The human can always intervene at any level. The authority never transfers, just the cadence of exercising it.
NEW: No level is self-promoting. The system advances only when outcome data justifies it, and any level can be revoked if the evidence stops supporting it.

--- 2026-02-22T08:17:49Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: - **Self-building:** 1,419 beads tracked, 1,098 closed. The system has been building itself for months.
NEW: - **Profiler:** Evidence collection shipped (override tracking, false positive rates, finding density). Proposal engine and automatic routing adjustments are next.
- **Self-building:** 1,419 beads tracked, 1,098 closed. The system has been building itself for months.

--- 2026-02-22T08:17:59Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: 1. **Platform.** Open Intercore as infrastructure for anyone building autonomous coding agents. Open Clavain as the reference OS. The whole stack, open source, from day one (when it's ready).
NEW: 1. **Platform.** Open Intercore as infrastructure for anyone building autonomous coding agents. Open Clavain as the reference OS. The whole stack, open source, from launch.

--- 2026-02-22T08:31:38Z | .gitignore | CONTEXT:unknown ---
OLD: # ── Research clones (not part of monorepo) ──
frankentui-research/
NEW: # ── Research clones (not part of monorepo) ──
research/

--- 2026-02-22T08:31:54Z | plan.md | CONTEXT:unknown ---
OLD: ├── frankentui-research/       ← gitignored research
NEW: ├── research/frankentui/       ← gitignored research clones

--- 2026-02-22T08:31:59Z | plan.md | CONTEXT:unknown ---
OLD: ├── frankentui-research/       # Stays at root (gitignored research)
NEW: ├── research/frankentui/       # Gitignored research clones

--- 2026-02-22T08:32:02Z | plan.md | CONTEXT:unknown ---
OLD: - `frankentui-research/` stays at root (gitignored)
NEW: - `research/` directory at root (gitignored) holds research clones like frankentui

--- 2026-02-22T08:32:11Z | apps/autarch/docs/research/frankentui-research-synthesis.md | CONTEXT:unknown ---
OLD: The repo is at `frankentui-research/` and gitignored.
NEW: The repo is at `research/frankentui/` (gitignored).

--- 2026-02-22T09:08:03Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Each wraps one capability and extends the system through kernel primitives. Every driver is independently installable, usable in vanilla Claude Code without Clavain, Intercore, or any other Demarch module. The full stack provides enhanced integration when present, but each driver is valuable on its own.
NEW: Each wraps one capability and integrates with kernel primitives when present. Every driver is independently installable, usable in vanilla Claude Code without Clavain, Intercore, or any other Demarch module. Without the kernel, drivers use local or ephemeral state; with it, they get durability, coordination, and event history. The full stack provides enhanced integration, but each driver is valuable on its own.

--- 2026-02-22T09:08:08Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Any capability driver works standalone. Install interflux for multi-agent review, tldr-swinton for code context, or interlock for file coordination. No Clavain, no Intercore, no rest of the stack required. The full Demarch stack adds durable state (kernel), adaptive improvement (profiler), and opinionated workflow (OS), but these are enhancements, not prerequisites.
NEW: Any capability driver works standalone. Install interflux for multi-agent review, tldr-swinton for code context, or interlock for file coordination. No Clavain, no Intercore, no rest of the stack required. Drivers degrade gracefully: they use ephemeral state alone, durable state with the kernel. The full Demarch stack adds adaptive improvement (profiler) and opinionated workflow (OS), but these are enhancements, not prerequisites.

--- 2026-02-22T09:16:05Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## The Autonomy Ladder

Demarch enables increasing levels of autonomous operation. Each level builds on the one below, earned through measured outcomes at the previous level.

The human's role is fixed across all levels: set objectives, make tradeoff decisions, approve deployments, intervene on exceptions. What changes is how frequently the human needs to exercise that authority.

**Level -1: Discover.** Before work can be recorded, it must be found. The discovery pipeline scans sources, scores relevance, and routes findings through confidence-tiered autonomy gates. *(Shipped, kernel primitives landed.)*

**Level 0: Record.** The kernel records what happened. Runs, phases, dispatches, artifacts, all tracked. The human drives everything. The kernel is a logbook. *(Shipped.)*

**Level 1: Enforce.** Gates evaluate real conditions. A run cannot advance without meeting preconditions. The kernel says "no" when evidence is insufficient. The human reviews every phase transition. *(Shipped.)*

**Level 2: React.** Events trigger automatic reactions. Phase transitions spawn agents. Completed dispatches advance phases. The human observes and intervenes on exceptions. *(Shipped.)*

**Level 3: Adapt.** Interspect reads kernel events, correlates with outcomes, and proposes configuration changes. Agents that produce false positives get downweighted. Gate rules evolve based on evidence. The human reviews Interspect proposals. *(In progress, the current frontier.)*

**Level 4: Orchestrate.** The kernel manages a portfolio of concurrent runs across multiple projects. Token budgets prevent runaway costs. Changes in one project trigger verification in dependents. The human sets portfolio goals and reviews weekly digests. *(Shipped, portfolio primitives landed.)*

No level is self-promoting. The system advances only when outcome data justifies it, and any level can be revoked if the evidence stops supporting it.
NEW: ## The Autonomy Ladder

How much human intervention does a single sprint require? The ladder tracks this one dimension. The human's role is fixed at every level (set objectives, make tradeoffs, approve deployments); what changes is how often they need to exercise it.

**Level 0: Record.** The kernel records what happened. Runs, phases, dispatches, artifacts, all tracked. The human drives everything. The kernel is a logbook. *(Shipped.)*

**Level 1: Enforce.** Gates evaluate real conditions. A run cannot advance without meeting preconditions. The kernel says "no" when evidence is insufficient. The human reviews every phase transition. *(Shipped.)*

**Level 2: React.** Events trigger automatic reactions. Phase transitions spawn agents. Completed dispatches advance phases. The human observes and intervenes on exceptions. *(Shipped.)*

**Level 3: Auto-remediate.** The system retries failed gates, substitutes agents, and adjusts parameters without human intervention. The human is notified of remediations but only intervenes when the system exhausts its options. *(Planned.)*

**Level 4: Auto-ship.** The system merges and deploys when confidence thresholds are met. The human approves shipping policy (which thresholds, which repos), not individual changes. *(Future.)*

No level is self-promoting. The system advances only when outcome data justifies it, and any level can be revoked if the evidence stops supporting it.

### Capability Tracks (orthogonal to autonomy)

Two capabilities cut across the autonomy ladder rather than sitting on it:

**Discovery.** The pipeline that finds work before it can be recorded. Scans sources, scores relevance, routes findings through confidence-tiered gates. Operates at any autonomy level. *(Shipped, kernel primitives landed.)*

**Adaptation.** Interspect reads kernel events, correlates with outcomes, and proposes configuration changes. Agents that produce false positives get downweighted. Gate rules evolve based on evidence. Operates at any autonomy level, but its value compounds as more sprints produce more data. *(In progress, the current frontier.)*

**Portfolio orchestration.** The kernel manages concurrent runs across multiple projects. Token budgets prevent runaway costs. Changes in one project trigger verification in dependents. Operates at any autonomy level. *(Shipped, portfolio primitives landed.)*

--- 2026-02-22T09:16:11Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The human is above the loop, not in it. The autonomy ladder below defines what "above the loop" looks like at each level.
NEW: The human is above the loop, not in it. The autonomy ladder below tracks how this plays out as intervention frequency decreases.

--- 2026-02-22T09:20:58Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: - **Not an LLM framework.** Demarch doesn't call LLMs, manage context windows, or process natural language. The dispatched agents do that.
- **Not a general AI gateway.** It doesn't route arbitrary messages to arbitrary agents. It orchestrates software development specifically.
NEW: - **Not a general AI gateway.** It doesn't route arbitrary messages to arbitrary agents. It orchestrates software development specifically.

--- 2026-02-22T09:21:55Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: | **Efficiency** | Model routing accuracy | % of model selections that match the outcome-optimal model |
NEW: | **Efficiency** | Model routing accuracy | % of model selections that match the outcome-optimal model |
| **Efficiency** | Time to merge | Wall-clock minutes from sprint creation to landed commit |

--- 2026-02-22T09:22:03Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch refuses to choose. It orchestrates the full development lifecycle from problem discovery through shipped code, selecting the right model for each task (Claude, Codex, Gemini, GPT-5.2, Haiku) with the discipline, durability, and accountability that shipping real software demands. And it gets cheaper and better every time it runs, because it learns from what happened last time.
NEW: Demarch refuses to choose. It orchestrates the full development lifecycle from problem discovery through shipped code, selecting the right model for each task with the discipline, durability, and accountability that shipping real software demands. And it gets cheaper and better every time it runs, because it learns from what happened last time.

--- 2026-02-22T09:26:48Z | os/clavain/docs/brainstorms/2026-02-22-c1-agency-specs-brainstorm.md | CONTEXT:unknown ---
OLD: # C1: Agency Specs — Declarative Per-Stage Agent/Model/Tool Config
NEW: # C1: Agency Specs — Declarative Per-Stage Agent/Model/Tool Config
**Bead:** iv-ssck

--- 2026-02-22T16:16:44Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: [Interspect](#) (profiler, forthcoming)
NEW: [Interspect](./interspect-vision.md) (profiler)

--- 2026-02-22T16:16:52Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: **The profiler (Interspect)** provides learning. It reads the kernel's event stream, correlates dispatch outcomes with human corrections, and proposes changes to OS configuration. Override rate, false positive rate, finding density: signals that compound over time. Static orchestration is table stakes; a system that improves its own agents through evidence rather than intuition is what makes Demarch different. Interspect never touches the kernel. It modifies the OS layer through safe, reversible overlays.
NEW: **The profiler (Interspect)** provides learning. It reads the kernel's event stream, correlates dispatch outcomes with both human signals (review dismissals, gate overrides, manual corrections) and automated signals (CI results, revert frequency, finding density), and proposes changes to OS configuration. The signal mix shifts as autonomy increases: human-heavy at L0-L2, automated-heavy at L3-L4. Static orchestration is table stakes; a system that improves its own agents through evidence rather than intuition is what makes Demarch different. Interspect never touches the kernel. It modifies the OS layer through safe, reversible overlays. (Full signal taxonomy in the [Interspect vision](./interspect-vision.md).)

--- 2026-02-22T16:18:40Z | docs/interspect-vision.md | CONTEXT:unknown ---
OLD: The Demarch vision claims three axes (autonomy, quality, token efficiency) connected by a flywheel. Interspect is that flywheel.
NEW: Demarch advances three axes (autonomy, quality, token efficiency) connected by a flywheel. Interspect is that flywheel.

--- 2026-02-22T16:18:42Z | docs/interspect-vision.md | CONTEXT:unknown ---
OLD: Phase 1 collects evidence before any modifications are proposed. The product ships value (observability, debugging UX) before it ships risk (modifications). This is not caution for its own sake. It's the mechanism that validates which signals are actually useful before betting on them.
NEW: Phase 1 collects evidence before any modifications are proposed. The product ships value (observability, debugging UX) before it ships risk (modifications). Not caution for its own sake, but the mechanism that validates which signals are actually useful before betting on them.

--- 2026-02-22T16:24:24Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD: # Source intercore state primitives (cache invalidation, sentinel checks)
source "${BASH_SOURCE[0]%/*}/lib-intercore.sh" 2>/dev/null || true
NEW: # Source intercore state primitives (cache invalidation, sentinel checks)
source "${BASH_SOURCE[0]%/*}/lib-intercore.sh" 2>/dev/null || true

# Source agency spec loader (C1: declarative per-stage config)
source "${BASH_SOURCE[0]%/*}/lib-spec.sh" 2>/dev/null || true

--- 2026-02-22T16:24:57Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD: # ─── Gate Wrapper ──────────────────────────────────────────────────

# Gate enforcement. Returns 0 if gate passes, 1 if blocked.
enforce_gate() {
    local bead_id="$1"
    local target_phase="$2"
    local artifact_path="${3:-}"

    local run_id
    run_id=$(_sprint_resolve_run_id "$bead_id") || return 0
    intercore_gate_check "$run_id"
}
NEW: # ─── Gate Wrapper ──────────────────────────────────────────────────

# Map sprint phase names to macro-stage names.
_sprint_phase_to_stage() {
    case "$1" in
        brainstorm) echo "discover" ;;
        brainstorm-reviewed|strategized|planned|plan-reviewed) echo "design" ;;
        executing) echo "build" ;;
        shipping) echo "ship" ;;
        reflect) echo "reflect" ;;
        done) echo "done" ;;
        *) echo "unknown" ;;
    esac
}

# Evaluate spec-defined gates for a stage.
# Args: $1=gates_json, $2=bead_id, $3=target_phase, $4=artifact_path, $5=mode (enforce|shadow)
# Returns: 0 if all pass, 1 if any fail (in enforce mode)
_sprint_evaluate_spec_gates() {
    local gates_json="$1" bead_id="$2" target_phase="$3" artifact_path="$4" mode="$5"
    local any_failed=0

    local gate_names
    gate_names=$(echo "$gates_json" | jq -r 'keys[]' 2>/dev/null) || return 0

    while IFS= read -r gate_name; do
        [[ -z "$gate_name" ]] && continue

        local gate
        gate=$(echo "$gates_json" | jq -c --arg g "$gate_name" '.[$g]' 2>/dev/null) || continue

        # Skip disabled gates
        local disabled
        disabled=$(echo "$gate" | jq -r '.disabled // false' 2>/dev/null) || disabled="false"
        [[ "$disabled" == "true" ]] && continue

        local gate_type
        gate_type=$(echo "$gate" | jq -r '.type // ""' 2>/dev/null) || gate_type=""

        local passed=true
        case "$gate_type" in
            artifact_reviewed)
                local artifact_name min_agents
                artifact_name=$(echo "$gate" | jq -r '.artifact // ""' 2>/dev/null) || artifact_name=""
                min_agents=$(echo "$gate" | jq -r '.min_agents // 1' 2>/dev/null) || min_agents=1
                [[ "$min_agents" =~ ^[0-9]+$ ]] || min_agents=1

                # Check if artifact exists in sprint state
                local artifacts
                artifacts=$(bd state "$bead_id" sprint_artifacts 2>/dev/null) || artifacts="{}"
                local art_path
                art_path=$(echo "$artifacts" | jq -r --arg a "$artifact_name" '.[$a] // ""' 2>/dev/null) || art_path=""

                if [[ -z "$art_path" ]]; then
                    passed=false
                else
                    # Check verdict count in .clavain/verdicts/
                    local verdict_count=0
                    if [[ -d ".clavain/verdicts" ]]; then
                        verdict_count=$(ls .clavain/verdicts/*.json 2>/dev/null | wc -l) || verdict_count=0
                    fi
                    [[ $verdict_count -lt $min_agents ]] && passed=false
                fi
                ;;
            command)
                local cmd expected_exit
                cmd=$(echo "$gate" | jq -r '.command // ""' 2>/dev/null) || cmd=""
                expected_exit=$(echo "$gate" | jq -r '.exit_code // 0' 2>/dev/null) || expected_exit=0
                [[ "$expected_exit" =~ ^[0-9]+$ ]] || expected_exit=0

                if [[ -n "$cmd" ]]; then
                    local actual_exit
                    eval "$cmd" >/dev/null 2>&1
                    actual_exit=$?
                    [[ $actual_exit -ne $expected_exit ]] && passed=false
                fi
                ;;
            phase_completed)
                local required_phase
                required_phase=$(echo "$gate" | jq -r '.phase // ""' 2>/dev/null) || required_phase=""
                if [[ -n "$required_phase" && -n "$bead_id" ]]; then
                    local run_id
                    run_id=$(_sprint_resolve_run_id "$bead_id") || run_id=""
                    if [[ -n "$run_id" ]]; then
                        local events
                        events=$("$INTERCORE_BIN" run events "$run_id" --json 2>/dev/null) || events="[]"
                        local phase_reached
                        phase_reached=$(echo "$events" | jq --arg p "$required_phase" \
                            '[.[] | select(.event_type == "advance" and .to_phase == $p)] | length > 0' 2>/dev/null) || phase_reached="false"
                        [[ "$phase_reached" != "true" ]] && passed=false
                    fi
                fi
                ;;
            verdict_clean)
                local max_attention
                max_attention=$(echo "$gate" | jq -r '.max_needs_attention // 0' 2>/dev/null) || max_attention=0
                [[ "$max_attention" =~ ^[0-9]+$ ]] || max_attention=0
                if [[ -d ".clavain/verdicts" ]]; then
                    local attention_count=0
                    local verdict_file
                    for verdict_file in .clavain/verdicts/*.json; do
                        [[ -f "$verdict_file" ]] || continue
                        local status
                        status=$(jq -r '.status // "CLEAN"' "$verdict_file" 2>/dev/null) || status="CLEAN"
                        [[ "$status" == "NEEDS_ATTENTION" ]] && attention_count=$((attention_count + 1))
                    done
                    [[ $attention_count -gt $max_attention ]] && passed=false
                fi
                ;;
            *)
                # Unknown gate type — log and skip (fail-open)
                echo "spec: unknown gate type '$gate_type' for gate '$gate_name'" >&2
                continue
                ;;
        esac

        if [[ "$passed" != "true" ]]; then
            if [[ "$mode" == "shadow" ]]; then
                echo "spec: gate '$gate_name' ($gate_type) would block at $target_phase [shadow mode]" >&2
            else
                echo "spec: gate '$gate_name' ($gate_type) blocked at $target_phase" >&2
                any_failed=1
            fi
        fi
    done <<< "$gate_names"

    return $any_failed
}

# Gate enforcement. Returns 0 if gate passes, 1 if blocked.
# ic gates are mandatory precondition; spec gates are additive.
enforce_gate() {
    local bead_id="$1"
    local target_phase="$2"
    local artifact_path="${3:-}"

    # Check gate mode from agency spec
    local gate_mode
    gate_mode=$(spec_get_default "gate_mode") || gate_mode="enforce"
    [[ "$gate_mode" == "off" ]] && return 0

    # ALWAYS run ic gate check first (existing invariant — never bypassed)
    local run_id
    run_id=$(_sprint_resolve_run_id "$bead_id") || return 0
    if ! intercore_gate_check "$run_id"; then
        return 1  # ic gate blocked — spec gates cannot override
    fi

    # Additionally check spec-defined gates if spec loaded successfully
    if ! spec_available; then
        return 0  # No spec — ic gate passed, we're done
    fi

    local stage
    stage=$(_sprint_phase_to_stage "$target_phase")
    local gates_json
    gates_json=$(spec_get_stage_gates "$stage") || return 0

    local has_gates
    has_gates=$(echo "$gates_json" | jq 'length > 0' 2>/dev/null) || has_gates="false"
    [[ "$has_gates" != "true" ]] && return 0

    if [[ "$gate_mode" == "shadow" ]]; then
        _sprint_evaluate_spec_gates "$gates_json" "$bead_id" "$target_phase" "$artifact_path" "shadow" || true
        return 0  # Shadow: always pass
    fi

    _sprint_evaluate_spec_gates "$gates_json" "$bead_id" "$target_phase" "$artifact_path" "enforce"
}

--- 2026-02-22T16:25:24Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD:     local remaining=$(( budget - spent ))
    [[ $remaining -lt 0 ]] && remaining=0
    echo "$remaining"
}

# ─── Session Claim ─────────────────────────────────────────────────
NEW:     local remaining=$(( budget - spent ))
    [[ $remaining -lt 0 ]] && remaining=0
    echo "$remaining"
}

# ─── Per-Stage Budget (C1: Agency Spec) ──────────────────────────────

# Get total budget for a sprint (reads token_budget from sprint state).
sprint_budget_total() {
    local sprint_id="$1"
    [[ -z "$sprint_id" ]] && { echo "0"; return 0; }
    local state
    state=$(sprint_read_state "$sprint_id") || { echo "0"; return 0; }
    local budget
    budget=$(echo "$state" | jq -r '.token_budget // 0' 2>/dev/null) || budget="0"
    [[ "$budget" == "null" || -z "$budget" ]] && budget="0"
    echo "$budget"
}

# Private: sum allocations for all 5 stages (for overallocation cap).
_sprint_sum_all_stage_allocations() {
    local sprint_id="$1"
    local total_budget
    total_budget=$(sprint_budget_total "$sprint_id")
    [[ "$total_budget" == "0" || -z "$total_budget" ]] && { echo "0"; return 0; }
    local sum=0
    local stage
    for stage in discover design build ship reflect; do
        local stage_json share min_tokens alloc
        stage_json=$(spec_get_budget "$stage" 2>/dev/null) || continue
        share=$(echo "$stage_json" | jq -r '.share // 20' 2>/dev/null)
        min_tokens=$(echo "$stage_json" | jq -r '.min_tokens // 1000' 2>/dev/null)
        [[ "$share" =~ ^[0-9]+$ ]] || share=20
        [[ "$min_tokens" =~ ^[0-9]+$ ]] || min_tokens=1000
        alloc=$(( total_budget * share / 100 ))
        [[ $alloc -lt $min_tokens ]] && alloc=$min_tokens
        sum=$(( sum + alloc ))
    done
    echo "$sum"
}

# Get allocated budget for a stage.
sprint_budget_stage() {
    local sprint_id="$1" stage="$2"
    [[ -z "$sprint_id" || -z "$stage" ]] && { echo "0"; return 0; }
    local total_budget
    total_budget=$(sprint_budget_total "$sprint_id") || { echo "0"; return 0; }
    [[ "$total_budget" == "0" || -z "$total_budget" ]] && { echo "0"; return 0; }

    # Without spec, return total budget (no per-stage breakdown)
    if ! spec_available; then
        echo "$total_budget"
        return 0
    fi

    local stage_budget_json
    stage_budget_json=$(spec_get_budget "$stage") || { echo "$total_budget"; return 0; }
    local share min_tokens
    share=$(echo "$stage_budget_json" | jq -r '.share // 20' 2>/dev/null)
    min_tokens=$(echo "$stage_budget_json" | jq -r '.min_tokens // 1000' 2>/dev/null)

    # Guard non-numeric values
    [[ "$share" =~ ^[0-9]+$ ]] || share=20
    [[ "$min_tokens" =~ ^[0-9]+$ ]] || min_tokens=1000

    local allocated
    allocated=$(( total_budget * share / 100 ))
    [[ $allocated -lt $min_tokens ]] && allocated=$min_tokens

    # Cap: if all stages' min_tokens push total above budget, scale down
    local uncapped_sum
    uncapped_sum=$(_sprint_sum_all_stage_allocations "$sprint_id")
    if [[ $uncapped_sum -gt $total_budget && $uncapped_sum -gt 0 ]]; then
        allocated=$(( allocated * total_budget / uncapped_sum ))
    fi

    echo "$allocated"
}

# Sum tokens spent across all phases belonging to a stage.
sprint_stage_tokens_spent() {
    local sprint_id="$1" stage="$2"
    [[ -z "$sprint_id" || -z "$stage" ]] && { echo "0"; return 0; }
    local run_id
    run_id=$(_sprint_resolve_run_id "$sprint_id") || { echo "0"; return 0; }
    local phase_tokens_json
    phase_tokens_json=$(intercore_state_get "phase_tokens" "$run_id" 2>/dev/null) || phase_tokens_json="{}"
    [[ -z "$phase_tokens_json" ]] && phase_tokens_json="{}"
    local total=0
    local phase
    while IFS= read -r phase; do
        [[ -z "$phase" ]] && continue
        local phase_stage
        phase_stage=$(_sprint_phase_to_stage "$phase")
        if [[ "$phase_stage" == "$stage" ]]; then
            local phase_total
            phase_total=$(echo "$phase_tokens_json" | jq -r \
                --arg p "$phase" '(.[($p)].input_tokens // 0) + (.[($p)].output_tokens // 0)' 2>/dev/null) || phase_total=0
            [[ "$phase_total" =~ ^[0-9]+$ ]] || phase_total=0
            total=$(( total + phase_total ))
        fi
    done <<< "$(echo "$phase_tokens_json" | jq -r 'keys[]' 2>/dev/null)"
    echo "$total"
}

# Get remaining budget for a stage.
sprint_budget_stage_remaining() {
    local sprint_id="$1" stage="$2"
    [[ -z "$sprint_id" || -z "$stage" ]] && { echo "0"; return 0; }
    local allocated spent remaining
    allocated=$(sprint_budget_stage "$sprint_id" "$stage")
    spent=$(sprint_stage_tokens_spent "$sprint_id" "$stage")
    [[ "$allocated" =~ ^[0-9]+$ ]] || allocated=0
    [[ "$spent" =~ ^[0-9]+$ ]] || spent=0
    remaining=$(( allocated - spent ))
    [[ $remaining -lt 0 ]] && remaining=0
    echo "$remaining"
}

# Check and warn if stage budget exceeded. Returns 1 if exceeded.
sprint_budget_stage_check() {
    local sprint_id="$1" stage="$2"
    [[ -z "$sprint_id" || -z "$stage" ]] && return 0
    local remaining
    remaining=$(sprint_budget_stage_remaining "$sprint_id" "$stage")
    if [[ "$remaining" -le 0 ]]; then
        echo "budget_exceeded|$stage|stage budget depleted" >&2
        return 1
    fi
    return 0
}

# ─── Session Claim ─────────────────────────────────────────────────

--- 2026-02-22T16:25:54Z | os/clavain/hooks/lib-spec.sh | CONTEXT:unknown ---
OLD: # Guard against double-sourcing
[[ -n "${_SPEC_LOADED:-}" ]] && return 0
NEW: # Guard against double-sourcing (separate from _SPEC_LOADED cache state)
[[ -n "${_SPEC_LIB_SOURCED:-}" ]] && return 0
_SPEC_LIB_SOURCED=1

--- 2026-02-22T16:25:59Z | os/clavain/hooks/lib-spec.sh | CONTEXT:unknown ---
OLD: _SPEC_JSON=""
_SPEC_MTIME=""
_SPEC_PATH=""
NEW: _SPEC_LOADED=""  # Cache state: "" | "ok" | "failed" | "fallback"
_SPEC_JSON=""
_SPEC_MTIME=""
_SPEC_PATH=""

--- 2026-02-22T16:26:03Z | os/clavain/hooks/lib-spec.sh | CONTEXT:unknown ---
OLD: 2>&2
NEW: 2>&1 >&2

--- 2026-02-22T16:26:14Z | os/clavain/hooks/lib-spec.sh | CONTEXT:unknown ---
OLD:     json_output=$(python3 "$_SPEC_HELPER" load "${load_args[@]}" 2>&1 >&2) || {
NEW:     json_output=$(python3 "$_SPEC_HELPER" load "${load_args[@]}") || {

--- 2026-02-22T16:26:18Z | os/clavain/hooks/lib-spec.sh | CONTEXT:unknown ---
OLD:         if ! python3 "$_SPEC_HELPER" validate "$spec_path" "$_SPEC_SCHEMA_PATH" 2>&1 >&2; then
NEW:         if ! python3 "$_SPEC_HELPER" validate "$spec_path" "$_SPEC_SCHEMA_PATH"; then

--- 2026-02-22T16:28:30Z | os/clavain/docs/prds/2026-02-22-c1-agency-specs.md | CONTEXT:unknown ---
OLD: - `yq` or `python3` — for YAML parsing in bash (check availability)

## Open Questions

1. **YAML parser:** `yq` is installed on this server. Use `yq` for bash-native parsing, or shell out to `python3 -c 'import yaml'`? `yq` is simpler and avoids Python dependency. **Decision: use `yq`.**
2. **Deep merge semantics for project overrides:** Use `yq` merge operator (`*`) for deep merge of project-level `.clavain/agency-spec.yaml` over defaults.
3. **Capability vocabulary formalization:** Start with free-form strings, add enum validation in a follow-up when vocabulary stabilizes through usage.
NEW: - `python3` + PyYAML — for YAML parsing in bash (`yq` is not installed; Python + PyYAML + jsonschema are available)

## Open Questions

1. **YAML parser:** ~~`yq` is installed on this server.~~ `yq` is NOT available. **Decision: use `python3` + PyYAML** via a helper script (`scripts/agency-spec-helper.py`). Called once per `spec_load()`; all subsequent queries use `jq` on cached JSON.
2. **Deep merge semantics for project overrides:** Arrays replace, dicts merge recursively. Set `disabled: true` on gates to remove defaults. Implemented in Python helper's `deep_merge()`.
3. **Capability vocabulary formalization:** Start with free-form strings, add enum validation in a follow-up when vocabulary stabilizes through usage.

--- 2026-02-22T16:31:55Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD:     # ALWAYS run ic gate check first (existing invariant — never bypassed)
    local run_id
    run_id=$(_sprint_resolve_run_id "$bead_id") || return 0
    if ! intercore_gate_check "$run_id"; then
NEW:     # ALWAYS run ic gate check first (existing invariant — never bypassed)
    local run_id
    run_id=$(_sprint_resolve_run_id "$bead_id") || {
        echo "spec: enforce_gate skipped — no ic run for bead '$bead_id'" >&2
        return 0
    }
    if ! intercore_gate_check "$run_id"; then

--- 2026-02-22T16:32:02Z | os/clavain/hooks/lib-sprint.sh | CONTEXT:unknown ---
OLD:                 if [[ -n "$cmd" ]]; then
                    local actual_exit
                    eval "$cmd" >/dev/null 2>&1
NEW:                 if [[ -n "$cmd" ]]; then
                    # SECURITY: command comes from agency-spec.yaml (admin-controlled config).
                    # eval is required to support shell features in gate commands (pipes, var expansion).
                    # Project overrides at .clavain/agency-spec.yaml are trusted — same trust level as Makefiles.
                    local actual_exit
                    eval "$cmd" >/dev/null 2>&1

--- 2026-02-22T16:32:10Z | os/clavain/hooks/lib-spec.sh | CONTEXT:unknown ---
OLD: # _SPEC_LOADED=""         → never loaded
# _SPEC_LOADED="ok"       → loaded successfully, _SPEC_JSON is valid
# _SPEC_LOADED="failed"   → load attempted, failed. _SPEC_JSON is empty
# _SPEC_LOADED="fallback" → no spec file found. Functions return hardcoded defaults
#
# Critical invariant: set _SPEC_JSON first, then _SPEC_LOADED="ok".
# If Python call fails, set _SPEC_LOADED="failed". Never set guard before data.
NEW: # _SPEC_LOADED=""         → never loaded
# _SPEC_LOADED="ok"       → loaded successfully, _SPEC_JSON is valid
# _SPEC_LOADED="failed"   → load attempted, failed. _SPEC_JSON is empty
# _SPEC_LOADED="fallback" → no spec file found. Functions return hardcoded defaults
#
# "failed" and "fallback" are sticky for the session — spec_load() won't retry.
# Call spec_invalidate_cache() to reset and force a reload.
#
# Critical invariant: set _SPEC_JSON first, then _SPEC_LOADED="ok".
# If Python call fails, set _SPEC_LOADED="failed". Never set guard before data.

--- 2026-02-22T16:32:16Z | os/clavain/scripts/agency-spec-helper.py | CONTEXT:unknown ---
OLD:     total_share = sum(s.get("budget", {}).get("share", 0) for s in stages.values())
    if total_share > 0 and total_share != 100:
NEW:     total_share = sum(s.get("budget", {}).get("share", 0) for s in stages.values())
    if total_share == 0 or total_share == 100:
        pass  # Nothing to normalize
    elif total_share > 0:

--- 2026-02-22T16:32:26Z | os/clavain/scripts/agency-spec-helper.py | CONTEXT:unknown ---
OLD:     total_share = sum(s.get("budget", {}).get("share", 0) for s in stages.values())
    if total_share == 0 or total_share == 100:
        pass  # Nothing to normalize
    elif total_share > 0:
NEW:     total_share = sum(s.get("budget", {}).get("share", 0) for s in stages.values())
    if total_share > 0 and total_share != 100:

--- 2026-02-22T16:41:23Z | docs/interspect-vision.md | CONTEXT:unknown ---
OLD: Each optimization simultaneously increases autonomy (less human calibration needed), improves quality (resources reallocated to where they matter), and reduces cost (less waste). The system that ships the most sprints learns the fastest, and the system that learns the fastest ships the cheapest.
NEW: Each optimization simultaneously increases autonomy (less human calibration needed), improves quality (resources reallocated to where they matter), and reduces cost (less waste). More sprints produce more evidence. More evidence produces better routing. Better routing lowers cost. The flywheel spins.

--- 2026-02-22T16:41:27Z | docs/interspect-vision.md | CONTEXT:unknown ---
OLD: Override rate alone is a trap (Goodhart's Law). Three metrics cross-check each other: override rate, false positive rate, and finding density. Galiana's defect escape rate provides an independent recall signal. When metrics conflict, conservatism wins.
NEW: Override rate alone is a trap (Goodhart's Law). Three metrics cross-check each other: override rate, false positive rate, and finding density. An independent defect escape rate metric provides a recall signal. When metrics conflict, conservatism wins.

--- 2026-02-22T16:58:09Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: [Autarch vision doc](../../../infra/intercore/docs/product/autarch-vision.md) (planned). For term definitions, see the [shared glossary](../../../infra/intercore/docs/product/glossary.md).
NEW: [Autarch vision doc](../../../apps/autarch/docs/autarch-vision.md). For term definitions, see the [shared glossary](../../../core/intercore/docs/product/glossary.md).

--- 2026-02-22T16:58:11Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: [Intercore vision doc](../../../infra/intercore/docs/product/intercore-vision.md) for the full write-path contract table.
NEW: [Intercore vision doc](../../../core/intercore/docs/product/intercore-vision.md) for the full write-path contract table.

--- 2026-02-22T16:58:12Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: [Intercore vision doc](../../../infra/intercore/docs/product/intercore-vision.md) — the kernel records dispatch details
NEW: [Intercore vision doc](../../../core/intercore/docs/product/intercore-vision.md) — the kernel records dispatch details

--- 2026-02-22T16:58:13Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: [Autarch vision doc](../../../infra/intercore/docs/product/autarch-vision.md) (planned).
NEW: [Autarch vision doc](../../../apps/autarch/docs/autarch-vision.md).

--- 2026-02-22T16:58:21Z | core/intercore/docs/product/intercore-vision.md | CONTEXT:unknown ---
OLD: ../../../../os/clavain/docs/clavain-vision.md
NEW: ../../../../os/clavain/docs/clavain-vision.md

--- 2026-02-22T16:58:22Z | core/intercore/docs/product/intercore-vision.md | CONTEXT:unknown ---
OLD: ../../../../hub/autarch/docs/autarch-vision.md
NEW: ../../../../apps/autarch/docs/autarch-vision.md

--- 2026-02-22T16:58:26Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: hub/autarch
NEW: apps/autarch

--- 2026-02-22T16:58:27Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: os/clavain
NEW: os/clavain

--- 2026-02-22T16:58:28Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: plugins/
NEW: interverse/

--- 2026-02-22T16:58:29Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: services/intermute
NEW: core/intermute

--- 2026-02-22T16:58:45Z | apps/autarch/docs/autarch-vision.md | CONTEXT:unknown ---
OLD: ../../../../os/clavain/docs/clavain-vision.md
NEW: ../../../../os/clavain/docs/clavain-vision.md

--- 2026-02-22T16:59:11Z | apps/autarch/docs/autarch-vision.md | CONTEXT:unknown ---
OLD: ../../../../os/clavain/docs/clavain-vision.md
NEW: ../../../os/clavain/docs/clavain-vision.md

--- 2026-02-22T17:27:06Z | core/intercore/docs/product/intercore-vision.md | CONTEXT:unknown ---
OLD: ## The Autonomy Ladder

Intercore enables increasing levels of autonomous operation. Each level builds on the one below.

### Level 0: Record

The kernel records what happened. Runs, phases, dispatches, artifacts — all tracked. A human drives everything. The kernel is a logbook.

*This is where intercore started: replacing temp files with a proper database.*

### Level 1: Enforce

Gates evaluate real conditions. A run cannot advance from `planned` to `executing` without a plan artifact. The kernel enforces discipline that humans and LLMs might skip under pressure.

*This is the gates milestone — the system says "no" when preconditions aren't met.*

### Level 2: React

Events trigger automatic reactions. When a run advances to `review`, the kernel emits an event. The OS tails the event log and spawns review agents. When all agents complete, the OS advances the phase. The human observes and intervenes only on exceptions.

*This is the event bus milestone — the system does the next obvious thing.*

### Level 3: Adapt

Interspect reads kernel events and correlates them with outcomes. Agents that consistently produce false positives get downweighted. Phases that never produce useful artifacts get skipped by default. Gate rules tighten or relax based on evidence.

The kernel supports this by recording structured evidence with enough dimensionality for meaningful analysis. Gate evaluations include not just pass/fail but the specific conditions checked and the artifacts examined. Dispatch outcomes include verdict quality, token cost, and wall-clock time. Over many runs, this evidence enables weighted confidence scoring across multiple dimensions — completeness, consistency, cost-effectiveness — following the pattern of Autarch's `ConfidenceScore` (see [Autarch vision doc](../../../../apps/autarch/docs/autarch-vision.md) for the scoring model) to produce an actionable composite score rather than a binary judgment.

The profiler proposes changes. The OS applies them as overlays. The kernel enforces the updated rules. The human reviews proposals and maintains veto power.

*This is evidence-based self-improvement — the system learns from its own history.*

### Level 4: Orchestrate

The kernel manages a portfolio of concurrent runs across multiple projects. Resource scheduling allocates agents, tokens, and compute across competing priorities. The OS defines priority rules. The kernel enforces them.

An urgent hotfix preempts a routine refactor. A high-complexity feature gets more review agents than a documentation update. Token budgets prevent runaway costs. A change in one project automatically triggers verification in downstream dependents.

*This is fleet management — the system balances competing demands across projects.*
NEW: ## The Autonomy Ladder

Intercore enables increasing levels of autonomous operation. Each level tracks a single dimension: how much human intervention does a sprint require? The human's role is fixed (set objectives, make tradeoffs, approve deployments); what changes is how often they need to exercise it.

### Level 0: Record

The kernel records what happened. Runs, phases, dispatches, artifacts — all tracked. A human drives everything. The kernel is a logbook. *(Shipped.)*

*This is where intercore started: replacing temp files with a proper database.*

### Level 1: Enforce

Gates evaluate real conditions. A run cannot advance from `planned` to `executing` without a plan artifact. The kernel enforces discipline that humans and LLMs might skip under pressure. *(Shipped.)*

*This is the gates milestone — the system says "no" when preconditions aren't met.*

### Level 2: React

Events trigger automatic reactions. When a run advances to `review`, the kernel emits an event. The OS tails the event log and spawns review agents. When all agents complete, the OS advances the phase. The human observes and intervenes only on exceptions. *(Shipped.)*

*This is the event bus milestone — the system does the next obvious thing.*

### Level 3: Auto-remediate

The system retries failed gates, substitutes agents, and adjusts parameters without human intervention. The human is notified of remediations but only intervenes when the system exhausts its options. *(Planned.)*

*This is resilient execution — the system recovers from failures autonomously.*

### Level 4: Auto-ship

The system merges and deploys when confidence thresholds are met. The human approves shipping policy (which thresholds, which repos), not individual changes. *(Future.)*

*This is policy-governed deployment — the system ships when evidence says it's safe.*

No level is self-promoting. The system advances only when outcome data justifies it, and any level can be revoked if the evidence stops supporting it.

### Capability Tracks (orthogonal to autonomy)

Three capabilities cut across the autonomy ladder rather than sitting on it. Each operates at any autonomy level and provides kernel primitives that the OS consumes.

**Adaptation.** Interspect reads kernel events, correlates with outcomes, and proposes configuration changes. Agents that produce false positives get downweighted. Gate rules evolve based on evidence. The kernel supports this by recording structured evidence with enough dimensionality for meaningful analysis — gate evaluations include the specific conditions checked and artifacts examined; dispatch outcomes include verdict quality, token cost, and wall-clock time. Over many runs, this evidence enables weighted confidence scoring across multiple dimensions — completeness, consistency, cost-effectiveness — following the pattern of Autarch's `ConfidenceScore` (see [Autarch vision doc](../../../../apps/autarch/docs/autarch-vision.md) for the scoring model). The profiler proposes changes. The OS applies them as overlays. The kernel enforces the updated rules. *(In progress, the current frontier.)*

**Discovery.** The pipeline that finds work before it can be recorded. The kernel provides discovery primitives (scored records, confidence gates, events); the OS provides the pipeline workflow. *(Shipped, kernel primitives landed.)*

**Portfolio orchestration.** The kernel manages concurrent runs across multiple projects. Resource scheduling allocates agents, tokens, and compute across competing priorities. An urgent hotfix preempts a routine refactor. Token budgets prevent runaway costs. Changes in one project trigger verification in dependents. *(Shipped, portfolio primitives landed.)*

--- 2026-02-22T17:27:15Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: This extends the autonomy ladder with a capability that precedes Level 0: **Level -1: Discover.** Before the system can record, enforce, or react to work, it must find work worth doing.
NEW: Discovery is a capability track orthogonal to the autonomy ladder (see the [Demarch vision](../../../docs/demarch-vision.md) for the full ladder and capability track definitions). It operates at any autonomy level — the pipeline that finds work before it can be recorded.

--- 2026-02-22T17:27:55Z | core/intercore/docs/intercore-roadmap.md | CONTEXT:unknown ---
OLD: ### E4: Level 3 — Adapt (P2) — SHIPPED
**What:** Connected Interspect to kernel events for evidence-based self-improvement.
NEW: ### E4: Adaptation Track — Interspect Integration (P2) — SHIPPED
**What:** Connected Interspect to kernel events for evidence-based self-improvement. (Adaptation is a capability track orthogonal to the autonomy ladder — see Intercore vision.)

--- 2026-02-22T17:27:57Z | core/intercore/docs/intercore-roadmap.md | CONTEXT:unknown ---
OLD: ### E8: Level 4 — Orchestrate (P3) — SHIPPED
**What:** Multi-project coordination and portfolio management.
NEW: ### E8: Portfolio Track — Multi-Project Orchestration (P3) — SHIPPED
**What:** Multi-project coordination and portfolio management. (Portfolio orchestration is a capability track orthogonal to the autonomy ladder — see Intercore vision.)

--- 2026-02-22T17:28:39Z | core/intercore/docs/product/interspect-vision.md | CONTEXT:unknown ---
OLD: # Interspect — Vision Document

**Version:** 2.0 (post-Oracle review)
**Date:** 2026-02-15
**PRD:** `docs/product/interspect-prd.md`
**Roadmap:** `docs/product/interspect-roadmap.md`
**Oracle review:** `docs/research/oracle-interspect-review.md`
NEW: # Interspect — Implementation Vision

**Version:** 2.0 (post-Oracle review)
**Date:** 2026-02-15
**High-level vision:** [docs/interspect-vision.md](../../../../docs/interspect-vision.md) (Demarch-level — canonical framing, signal taxonomy, design principles)
**PRD:** `docs/product/interspect-prd.md`
**Roadmap:** `docs/product/interspect-roadmap.md`
**Oracle review:** `docs/research/oracle-interspect-review.md`

> **Scope note.** This document covers implementation detail: SQLite schema, overlay file formats, hook integration, modification types, and safety infrastructure. For the high-level vision (what Interspect is, why it matters, signal taxonomy, design principles), see the [Demarch-level Interspect vision](../../../../docs/interspect-vision.md). Version numbers are independent — this doc's "v2.0" predates the Demarch-level "v1.0" because this doc was written first and revised after Oracle review.

--- 2026-02-22T17:29:12Z | os/clavain/docs/clavain-roadmap.md | CONTEXT:unknown ---
OLD: 31 companion plugins
NEW: 33 companion plugins

--- 2026-02-22T17:29:16Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ecosystem of 37 modules
NEW: ecosystem of 42 modules across 5 layers

--- 2026-02-22T17:29:45Z | docs/interverse-roadmap.md | CONTEXT:unknown ---
OLD: Clavain is an autonomous software agency — 15 skills, 4 agents, 52 commands, 22 hooks, 1 MCP server. 31 companion plugins in the inter-* constellation. 1000 beads tracked, 660 closed, 339 open. Runs on its own TUI (Autarch), backed by Intercore kernel and Interspect profiler.
NEW: Clavain is an autonomous software agency — 16 skills, 4 agents, 53 commands, 22 hooks, 1 MCP server. 33 companion plugins in the inter-* constellation. 1419 beads tracked, 1098 closed, 321 open. Runs on its own TUI (Autarch), backed by Intercore kernel and Interspect profiler.

--- 2026-02-22T17:34:16Z | interverse/interflux/docs/brainstorms/2026-02-22-flux-gen-precheck-brainstorm.md | CONTEXT:unknown ---
OLD: **Bead:** iv-3ak4
NEW: **Bead:** iv-uaf8

--- 2026-02-22T17:38:28Z | interverse/interflux/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD:   "mcpServers": {
NEW:   "agentCapabilities": {
    "./agents/review/fd-architecture.md": ["review:architecture", "review:code", "review:design-patterns"],
    "./agents/review/fd-safety.md": ["review:safety", "review:security", "review:deployment"],
    "./agents/review/fd-correctness.md": ["review:correctness", "review:concurrency", "review:data-consistency"],
    "./agents/review/fd-user-product.md": ["review:user-experience", "review:product", "review:scope"],
    "./agents/review/fd-quality.md": ["review:quality", "review:style", "review:conventions"],
    "./agents/review/fd-game-design.md": ["review:game-design", "review:balance", "review:pacing"],
    "./agents/review/fd-performance.md": ["review:performance", "review:bottlenecks", "review:scaling"],
    "./agents/review/fd-systems.md": ["review:systems-thinking", "review:feedback-loops", "review:emergence"],
    "./agents/review/fd-decisions.md": ["review:decisions", "review:cognitive-bias", "review:strategy"],
    "./agents/review/fd-people.md": ["review:trust", "review:communication", "review:team-dynamics"],
    "./agents/review/fd-resilience.md": ["review:resilience", "review:antifragility", "review:innovation"],
    "./agents/review/fd-perception.md": ["review:mental-models", "review:sensemaking", "review:information-quality"],
    "./agents/research/framework-docs-researcher.md": ["research:docs", "research:frameworks"],
    "./agents/research/repo-research-analyst.md": ["research:codebase", "research:architecture"],
    "./agents/research/git-history-analyzer.md": ["research:git-history", "research:code-evolution"],
    "./agents/research/learnings-researcher.md": ["research:learnings", "research:institutional-knowledge"],
    "./agents/research/best-practices-researcher.md": ["research:best-practices", "research:industry-standards"]
  },
  "mcpServers": {

--- 2026-02-22T17:38:40Z | core/intermute/internal/storage/storage.go | CONTEXT:unknown ---
OLD: 	ListAgents(ctx context.Context, project string) ([]core.Agent, error)
NEW: 	ListAgents(ctx context.Context, project string, capabilities []string) ([]core.Agent, error)

--- 2026-02-22T17:38:45Z | interverse/interflux/hooks/hooks.json | CONTEXT:unknown ---
OLD: {
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "bash ${CLAUDE_PLUGIN_ROOT}/hooks/session-start.sh"
          }
        ]
      }
    ]
  }
}
NEW: {
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "bash ${CLAUDE_PLUGIN_ROOT}/hooks/session-start.sh"
          },
          {
            "type": "command",
            "command": "bash ${CLAUDE_PLUGIN_ROOT}/hooks/write-capabilities.sh"
          }
        ]
      }
    ]
  }
}

--- 2026-02-22T17:38:46Z | core/intermute/internal/storage/storage.go | CONTEXT:unknown ---
OLD: func (m *InMemory) ListAgents(_ context.Context, project string) ([]core.Agent, error) {
	var out []core.Agent
	for _, agent := range m.agents {
		if project == "" || agent.Project == project {
			out = append(out, agent)
		}
	}
	return out, nil
}
NEW: func (m *InMemory) ListAgents(_ context.Context, project string, capabilities []string) ([]core.Agent, error) {
	var out []core.Agent
	for _, agent := range m.agents {
		if project != "" && agent.Project != project {
			continue
		}
		if len(capabilities) > 0 && !hasAnyCapability(agent.Capabilities, capabilities) {
			continue
		}
		out = append(out, agent)
	}
	return out, nil
}

// hasAnyCapability reports whether agentCaps contains at least one element from queryCaps.
func hasAnyCapability(agentCaps, queryCaps []string) bool {
	for _, qc := range queryCaps {
		for _, ac := range agentCaps {
			if ac == qc {
				return true
			}
		}
	}
	return false
}

--- 2026-02-22T17:39:00Z | core/intermute/internal/storage/sqlite/sqlite.go | CONTEXT:unknown ---
OLD: func (s *Store) ListAgents(_ context.Context, project string) ([]core.Agent, error) {
	query := `SELECT id, session_id, name, project, capabilities_json, metadata_json, status, created_at, last_seen
		FROM agents`
	var args []any
	if project != "" {
		query += " WHERE project = ?"
		args = append(args, project)
	}
	query += " ORDER BY last_seen DESC"
NEW: func (s *Store) ListAgents(_ context.Context, project string, capabilities []string) ([]core.Agent, error) {
	query := `SELECT id, session_id, name, project, capabilities_json, metadata_json, status, created_at, last_seen
		FROM agents`
	var conditions []string
	var args []any
	if project != "" {
		conditions = append(conditions, "project = ?")
		args = append(args, project)
	}
	if len(capabilities) > 0 {
		// OR match: agent has any of the requested capabilities
		// Guard against NULL/empty capabilities_json (legacy agents)
		capPlaceholders := make([]string, len(capabilities))
		for i, capability := range capabilities {
			capPlaceholders[i] = "?"
			args = append(args, capability)
		}
		conditions = append(conditions,
			fmt.Sprintf("EXISTS (SELECT 1 FROM json_each(CASE WHEN capabilities_json IS NULL OR capabilities_json = '' OR capabilities_json = 'null' THEN '[]' ELSE capabilities_json END) WHERE json_each.value IN (%s))",
				strings.Join(capPlaceholders, ",")))
	}
	if len(conditions) > 0 {
		query += " WHERE " + strings.Join(conditions, " AND ")
	}
	query += " ORDER BY last_seen DESC"

--- 2026-02-22T17:39:12Z | core/intermute/internal/storage/sqlite/resilient.go | CONTEXT:unknown ---
OLD: func (r *ResilientStore) ListAgents(ctx context.Context, project string) ([]core.Agent, error) {
	var result []core.Agent
	err := r.cb.Execute(func() error {
		return RetryOnDBLock(func() error {
			var innerErr error
			result, innerErr = r.inner.ListAgents(ctx, project)
			return innerErr
		})
	})
	return result, err
}
NEW: func (r *ResilientStore) ListAgents(ctx context.Context, project string, capabilities []string) ([]core.Agent, error) {
	var result []core.Agent
	err := r.cb.Execute(func() error {
		return RetryOnDBLock(func() error {
			var innerErr error
			result, innerErr = r.inner.ListAgents(ctx, project, capabilities)
			return innerErr
		})
	})
	return result, err
}

--- 2026-02-22T17:39:16Z | core/intermute/internal/http/handlers_agents.go | CONTEXT:unknown ---
OLD: 	agents, err := s.store.ListAgents(r.Context(), project)
NEW: 	var capabilities []string
	if capParam := r.URL.Query().Get("capability"); capParam != "" {
		for _, c := range strings.Split(capParam, ",") {
			if c = strings.TrimSpace(c); c != "" {
				capabilities = append(capabilities, c)
			}
		}
	}

	agents, err := s.store.ListAgents(r.Context(), project, capabilities)

--- 2026-02-22T17:39:20Z | core/intermute/internal/storage/sqlite/sqlite_test.go | CONTEXT:unknown ---
OLD: st.ListAgents(ctx, "")
NEW: st.ListAgents(ctx, "", nil)

--- 2026-02-22T17:39:24Z | core/intermute/internal/storage/sqlite/sqlite_test.go | CONTEXT:unknown ---
OLD: st.ListAgents(ctx, "proj-a")
NEW: st.ListAgents(ctx, "proj-a", nil)

--- 2026-02-22T17:39:28Z | core/intermute/internal/storage/sqlite/sqlite_test.go | CONTEXT:unknown ---
OLD: st.ListAgents(ctx, "proj")
NEW: st.ListAgents(ctx, "proj", nil)

--- 2026-02-22T17:39:37Z | core/intermute/client/client.go | CONTEXT:unknown ---
OLD: func (c *Client) SendMessage(ctx context.Context, msg Message) (SendResponse, error) {
NEW: // DiscoverAgents lists agents filtered by capability tags.
// Capabilities uses OR matching — agents with any of the given capabilities are returned.
func (c *Client) DiscoverAgents(ctx context.Context, capabilities []string) ([]Agent, error) {
	values := url.Values{}
	if c.Project != "" {
		values.Set("project", c.Project)
	}
	if len(capabilities) > 0 {
		values.Set("capability", strings.Join(capabilities, ","))
	}
	endpoint := "/api/agents"
	if len(values) > 0 {
		endpoint += "?" + values.Encode()
	}
	resp, err := c.get(ctx, endpoint)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("discover agents failed: %d", resp.StatusCode)
	}
	var out ListAgentsResponse
	if err := json.NewDecoder(resp.Body).Decode(&out); err != nil {
		return nil, err
	}
	return out.Agents, nil
}

func (c *Client) SendMessage(ctx context.Context, msg Message) (SendResponse, error) {

--- 2026-02-22T17:39:58Z | core/intermute/internal/http/handlers_agents_test.go | CONTEXT:unknown ---
OLD: func TestPatchAgentMetadata(t *testing.T) {
NEW: func TestListAgentsCapabilityFilter(t *testing.T) {
	svc := NewService(storage.NewInMemory())
	srv := httptest.NewServer(NewRouter(svc, nil, nil))
	defer srv.Close()

	// Register agents with capabilities — includes one with empty caps
	for _, tc := range []struct {
		name string
		caps []string
	}{
		{"agent-arch", []string{"review:architecture", "review:code"}},
		{"agent-safety", []string{"review:safety", "review:security"}},
		{"agent-both", []string{"review:architecture", "review:safety"}},
		{"agent-nocaps", []string{}},
	} {
		payload := map[string]any{"name": tc.name, "project": "proj-a", "capabilities": tc.caps}
		buf, _ := json.Marshal(payload)
		resp, err := http.Post(srv.URL+"/api/agents", "application/json", bytes.NewReader(buf))
		if err != nil {
			t.Fatalf("register failed: %v", err)
		}
		resp.Body.Close()
	}

	tests := []struct {
		name     string
		query    string
		expected int
	}{
		{"single match", "?project=proj-a&capability=review:architecture", 2},
		{"multi OR match", "?project=proj-a&capability=review:architecture,review:security", 3},
		{"no match", "?project=proj-a&capability=research:docs", 0},
		{"no filter returns all", "?project=proj-a", 4},
		{"trailing comma ignored", "?project=proj-a&capability=review:architecture,", 2},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			resp, err := http.Get(srv.URL + "/api/agents" + tc.query)
			if err != nil {
				t.Fatalf("request failed: %v", err)
			}
			defer resp.Body.Close()
			if resp.StatusCode != http.StatusOK {
				t.Fatalf("expected 200, got %d", resp.StatusCode)
			}

			var result listAgentsResponse
			if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
				t.Fatalf("decode failed: %v", err)
			}
			if len(result.Agents) != tc.expected {
				t.Fatalf("expected %d agents, got %d", tc.expected, len(result.Agents))
			}
		})
	}
}

func TestCapabilityDiscoveryEndToEnd(t *testing.T) {
	svc := NewService(storage.NewInMemory())
	srv := httptest.NewServer(NewRouter(svc, nil, nil))
	defer srv.Close()

	// Simulate registration with capabilities (as interlock-register.sh would)
	agents := []struct {
		name string
		caps []string
	}{
		{"fd-architecture", []string{"review:architecture", "review:code"}},
		{"fd-safety", []string{"review:safety", "review:security"}},
		{"repo-research-analyst", []string{"research:codebase", "research:architecture"}},
		{"agent-nocaps", nil},
	}

	for _, a := range agents {
		payload := map[string]any{
			"name":         a.name,
			"project":      "demarch",
			"capabilities": a.caps,
		}
		buf, _ := json.Marshal(payload)
		resp, err := http.Post(srv.URL+"/api/agents", "application/json", bytes.NewReader(buf))
		if err != nil {
			t.Fatalf("register %s failed: %v", a.name, err)
		}
		resp.Body.Close()
	}

	// Query by single capability — only fd-architecture has review:architecture
	// (repo-research-analyst has research:architecture — different domain prefix)
	resp, err := http.Get(srv.URL + "/api/agents?project=demarch&capability=review:architecture")
	if err != nil {
		t.Fatalf("query failed: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		t.Fatalf("expected 200, got %d", resp.StatusCode)
	}

	var result listAgentsResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		t.Fatalf("decode failed: %v", err)
	}
	if len(result.Agents) != 1 {
		t.Fatalf("expected 1 agent for review:architecture, got %d", len(result.Agents))
	}
	if result.Agents[0].Name != "fd-architecture" {
		t.Fatalf("expected fd-architecture, got %s", result.Agents[0].Name)
	}

	// Query by OR across domains
	resp2, err := http.Get(srv.URL + "/api/agents?project=demarch&capability=review:safety,research:codebase")
	if err != nil {
		t.Fatalf("query failed: %v", err)
	}
	defer resp2.Body.Close()
	if resp2.StatusCode != http.StatusOK {
		t.Fatalf("expected 200, got %d", resp2.StatusCode)
	}

	var result2 listAgentsResponse
	if err := json.NewDecoder(resp2.Body).Decode(&result2); err != nil {
		t.Fatalf("decode failed: %v", err)
	}
	if len(result2.Agents) != 2 {
		t.Fatalf("expected 2 agents for safety+codebase, got %d", len(result2.Agents))
	}

	// Verify capabilities are returned in the response
	for _, a := range result2.Agents {
		if len(a.Capabilities) == 0 {
			t.Errorf("agent %s has no capabilities in response", a.Name)
		}
	}
}

func TestPatchAgentMetadata(t *testing.T) {

--- 2026-02-22T17:41:42Z | interverse/interlock/scripts/interlock-register.sh | CONTEXT:unknown ---
OLD: # POST to intermute /api/agents
RESPONSE=$(intermute_curl POST "/api/agents" \
    -H "Content-Type: application/json" \
    -d "$(jq -n \
        --arg id "claude-${SESSION_ID:0:8}" \
        --arg name "$AGENT_NAME" \
        --arg project "$PROJECT" \
        --arg session_id "$SESSION_ID" \
        '{id: $id, name: $name, project: $project, session_id: $session_id}')" \
    2>/dev/null) || exit 1
NEW: # Extract capabilities from per-agent capability file (written by each plugin's session hook)
CAPABILITIES="[]"
CAPS_FILE="${HOME}/.config/clavain/capabilities-${AGENT_NAME}.json"
if [[ -f "$CAPS_FILE" ]]; then
    AGENT_CAPS=$(jq -c '.' "$CAPS_FILE" 2>/dev/null)
    if [[ -n "$AGENT_CAPS" ]] && [[ "$AGENT_CAPS" != "null" ]]; then
        CAPABILITIES="$AGENT_CAPS"
    fi
fi

# POST to intermute /api/agents
RESPONSE=$(intermute_curl POST "/api/agents" \
    -H "Content-Type: application/json" \
    -d "$(jq -n \
        --arg id "claude-${SESSION_ID:0:8}" \
        --arg name "$AGENT_NAME" \
        --arg project "$PROJECT" \
        --arg session_id "$SESSION_ID" \
        --argjson capabilities "$CAPABILITIES" \
        '{id: $id, name: $name, project: $project, session_id: $session_id, capabilities: $capabilities}')" \
    2>/dev/null) || exit 1

--- 2026-02-22T17:42:12Z | interverse/interlock/internal/client/client.go | CONTEXT:unknown ---
OLD: // Agent represents a registered agent.
type Agent struct {
	AgentID string `json:"agent_id"`
	Name    string `json:"name"`
	Project string `json:"project"`
	Status  string `json:"status"`
}
NEW: // Agent represents a registered agent.
type Agent struct {
	AgentID      string   `json:"agent_id"`
	Name         string   `json:"name"`
	Project      string   `json:"project"`
	Capabilities []string `json:"capabilities"`
	Status       string   `json:"status"`
	LastSeen     string   `json:"last_seen"`
}

--- 2026-02-22T17:42:19Z | interverse/interlock/internal/client/client.go | CONTEXT:unknown ---
OLD: // SendMessage sends a message to another agent.
func (c *Client) SendMessage(ctx context.Context, to, body string) error {
NEW: // DiscoverAgents lists agents filtered by capability tags.
// Capabilities uses OR matching — agents with any of the given capabilities are returned.
// Pass nil or empty slice to list all agents (same as ListAgents).
func (c *Client) DiscoverAgents(ctx context.Context, capabilities []string) ([]Agent, error) {
	path := "/api/agents?project=" + url.QueryEscape(c.project)
	if len(capabilities) > 0 {
		path += "&capability=" + url.QueryEscape(strings.Join(capabilities, ","))
	}
	var result struct {
		Agents []Agent `json:"agents"`
	}
	if err := c.doJSON(ctx, "GET", path, nil, &result); err != nil {
		return nil, err
	}
	return result.Agents, nil
}

// SendMessage sends a message to another agent.
func (c *Client) SendMessage(ctx context.Context, to, body string) error {

--- 2026-02-22T17:42:34Z | interverse/interlock/internal/tools/tools.go | CONTEXT:unknown ---
OLD: func listAgents(c *client.Client) server.ServerTool {
	return server.ServerTool{
		Tool: mcp.NewTool("list_agents",
			mcp.WithDescription("List all active agents in the project."),
		),
		Handler: func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			agents, err := c.ListAgents(ctx)
			if err != nil {
				return mcp.NewToolResultError(fmt.Sprintf("list agents: %v", err)), nil
			}
			if agents == nil {
				agents = make([]client.Agent, 0)
			}
			return jsonResult(agents)
		},
	}
}
NEW: func listAgents(c *client.Client) server.ServerTool {
	return server.ServerTool{
		Tool: mcp.NewTool("list_agents",
			mcp.WithDescription("List agents registered with intermute. Optionally filter by capability tag (e.g. 'review:architecture'). Comma-separated capabilities use OR matching."),
			mcp.WithString("capability",
				mcp.Description("Capability tag to filter by (e.g. 'review:architecture'). Comma-separated for OR matching. Omit to list all agents."),
			),
		),
		Handler: func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			capability, _ := req.Params.Arguments["capability"].(string)
			var agents []client.Agent
			var err error
			if capability != "" {
				var caps []string
				for _, c := range strings.Split(capability, ",") {
					if c = strings.TrimSpace(c); c != "" {
						caps = append(caps, c)
					}
				}
				agents, err = c.DiscoverAgents(ctx, caps)
			} else {
				agents, err = c.ListAgents(ctx)
			}
			if err != nil {
				return mcp.NewToolResultError(fmt.Sprintf("list agents: %v", err)), nil
			}
			if agents == nil {
				agents = make([]client.Agent, 0)
			}
			return jsonResult(agents)
		},
	}
}

--- 2026-02-22T17:42:38Z | interverse/interlock/internal/tools/tools.go | CONTEXT:unknown ---
OLD: import (
	"context"
	crand "crypto/rand"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"sync/atomic"
	"time"
NEW: import (
	"context"
	crand "crypto/rand"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"sync/atomic"
	"time"

--- 2026-02-22T17:42:52Z | interverse/interlock/internal/tools/tools.go | CONTEXT:unknown ---
OLD: 		Handler: func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			capability, _ := req.Params.Arguments["capability"].(string)
			var agents []client.Agent
NEW: 		Handler: func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			args := req.GetArguments()
			capability, _ := args["capability"].(string)
			var agents []client.Agent

--- 2026-02-22T17:59:22Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch is an autonomous software agency that pushes the frontier on three axes simultaneously: state-of-the-art autonomy, uncompromising quality, and relentless token efficiency.
NEW: Demarch is an open-source autonomous software development agency platform that pushes the frontier on three axes simultaneously: state-of-the-art autonomy, uncompromising quality, and relentless token efficiency.

--- 2026-02-22T17:59:25Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Not a coding assistant. Not an AI gateway. Not a framework for calling LLMs. An agency that builds software with discipline, at a cost that keeps declining.
NEW: Not a coding assistant. Not an AI gateway. Not a framework for calling LLMs. A platform for autonomous software development agencies that build software with discipline, at a cost that keeps declining.

--- 2026-02-22T17:59:30Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: - **Not a general AI gateway.** It doesn't route arbitrary messages to arbitrary agents. It orchestrates software development specifically.
- **Not a coding assistant.** It doesn't help you write code; it *builds software*. The coding is one phase of five.
- **Not a no-code tool.** It's for people who build software with agents. Full stop.
- **Not self-modifying.** Interspect can modify OS-level configuration. It cannot modify the kernel. This is a deliberate safety boundary.
NEW: - **Not a general AI gateway.** It doesn't route arbitrary messages to arbitrary agents. It orchestrates software development specifically.
- **Not a coding assistant.** It doesn't help you write code; it *builds software*. The coding is one phase of five.
- **Not a no-code tool.** It's for people who build software with agents. Full stop.
- **Not self-modifying.** Interspect can modify OS-level configuration. It cannot modify the kernel. This is a deliberate safety boundary.
- **Not just an agency.** Demarch is the platform; Clavain is the reference agency built on it. The kernel and drivers are infrastructure anyone can use to build their own agency.

--- 2026-02-22T17:59:37Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Demarch is infrastructure for anyone building autonomous coding agents. Intercore is the kernel. Clavain is the reference OS. The personal rig is the highest-fidelity eval: built by using it to build itself.
NEW: Demarch is an open-source platform for anyone building autonomous software development agencies. Intercore is the kernel. Clavain is the reference agency. The personal rig is the highest-fidelity eval: built by using it to build itself.

--- 2026-02-22T17:59:43Z | structure.md | CONTEXT:unknown ---
OLD: Monorepo for the Demarch autonomous software agency.
NEW: Monorepo for the Demarch open-source autonomous software development agency platform.

--- 2026-02-22T18:00:05Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: 3. **Platform play.** Once dogfooding proves the model works, open Intercore as infrastructure for anyone building autonomous coding agents, and position Clavain as the reference OS. AI labs get the kernel. Developers get the agency. Both are open source. The differentiation from general-purpose AI gateways is that this stack is purpose-built for building software.
NEW: 3. **Platform play.** Once dogfooding proves the model works, open the Demarch platform — Intercore as infrastructure for anyone building autonomous software development agencies, and Clavain as the reference agency. AI labs get the kernel. Developers get the agency. Both are open source. The differentiation from general-purpose AI gateways is that this stack is purpose-built for building software.

--- 2026-02-22T18:00:10Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: **Not a platform.** That's Intercore. Clavain is the opinionated agency built on the platform.
NEW: **Not the platform.** That's Demarch. Clavain is the opinionated reference agency built on the platform.

--- 2026-02-22T18:00:26Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: 1. **Platform.** Open Intercore as infrastructure for anyone building autonomous coding agents. Open Clavain as the reference OS. The whole stack, open source, from launch.
NEW: 1. **Platform.** Open Intercore as infrastructure for anyone building autonomous software development agencies. Open Clavain as the reference agency. The whole stack, open source, from launch.

--- 2026-02-22T18:00:27Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: The bet is on ecosystem effects. If the kernel is good enough, people will build their own OS layers on top of it. If the OS is good enough, people will write their own companions.
NEW: The bet is on ecosystem effects. If the kernel is good enough, people will build their own agencies on top of it. If the reference agency is good enough, people will write their own companions.

--- 2026-02-22T18:05:39Z | os/clavain/docs/clavain-roadmap.md | CONTEXT:unknown ---
OLD: 33 companion plugins in the inter-* constellation.
NEW: 35 companion plugins in the inter-* constellation (33 shipped/active, 2 planned).

--- 2026-02-22T18:05:41Z | os/clavain/docs/clavain-roadmap.md | CONTEXT:unknown ---
OLD: | **33 companion plugins** | intermap, intermem, intersynth, interlens, interleave, interserve, interpeer, intertest, interkasten, interstat, interfluence, interphase v2, and more |
NEW: | **35 companion plugins** | intermap, intermem, intersynth, interlens, interleave, interserve, interpeer, intertest, interkasten, interstat, interfluence, interphase v2, and more (33 shipped/active, 2 planned) |

--- 2026-02-22T18:05:43Z | os/clavain/docs/clavain-roadmap.md | CONTEXT:unknown ---
OLD: *Synthesized from: [`docs/clavain-vision.md`](clavain-vision.md), [`docs/PRD.md`](PRD.md), 1419 beads, 33 companion plugins, and the Intercore kernel vision. Sources linked throughout.*
NEW: *Synthesized from: [`docs/clavain-vision.md`](clavain-vision.md), [`docs/PRD.md`](PRD.md), 1419 beads, 35 companion plugins, and the Intercore kernel vision. Sources linked throughout.*

--- 2026-02-22T18:05:57Z | os/clavain/docs/clavain-roadmap.md | CONTEXT:unknown ---
OLD: ### Supporting Epics (Intercore)

These Intercore epics are prerequisites for the tracks above:
NEW: ### Autonomy Ladder Mapping

The three tracks map to the [Demarch Autonomy Ladder](../../../docs/demarch-vision.md#the-autonomy-ladder) (L0 Record, L1 Enforce, L2 React, L3 Auto-remediate, L4 Auto-ship):

| Steps | Track | Autonomy Level | Rationale |
|-------|-------|---------------|-----------|
| A1-A3 (done) | Kernel Integration | Enabled L0-L2 (Record, Enforce, React) | Hook cutover gives durable state (L0), sprint handover adds gate enforcement (L1), event-driven advancement enables automatic reactions (L2). |
| B1-B2 (done) | Model Routing | Supports L2 (React) | Routing decisions applied automatically at dispatch time — the system reacts to task complexity without human model selection. |
| B3 (open) | Model Routing | Prerequisite for L3 (Auto-remediate) | Interspect-driven model selection means the system adjusts its own routing based on outcome data, a form of self-remediation. |
| C1-C4 (open) | Agency Architecture | Foundation for L3 (Auto-remediate) | Agency specs, fleet registry, composer, and cross-phase handoff give the system the vocabulary to retry with different agents, substitute models, and adjust parameters autonomously. |
| C5 (open) | Agency Architecture | Gateway to L4 (Auto-ship) | The self-building loop — Clavain using its own agency specs to run its own sprints — is the entry point to fully autonomous shipping. |

### Supporting Epics (Intercore)

These Intercore epics are prerequisites for the tracks above:

--- 2026-02-22T18:21:39Z | interverse/intersynth/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD:   "agents": [
    "./agents/synthesize-review.md",
    "./agents/synthesize-research.md"
  ]
}
NEW:   "agents": [
    "./agents/synthesize-review.md",
    "./agents/synthesize-research.md"
  ],
  "hooks": "./hooks/hooks.json"
}

--- 2026-02-22T18:21:44Z | docs/brainstorms/2026-02-22-flux-drive-intermediate-findings-brainstorm.md | CONTEXT:unknown ---
OLD: **Bead:** iv-905u
NEW: **Bead:** iv-905u
**Sprint:** iv-firp

--- 2026-02-22T18:25:12Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Gates are kernel-enforced invariants, not prompt suggestions. An agent cannot bypass a gate regardless of what the LLM requests. This is the difference between "please check for a plan artifact" and "the system will not advance without a plan artifact."
NEW: Gates are kernel-enforced invariants, not prompt suggestions. An agent cannot bypass a gate regardless of what the LLM requests. This is the difference between "please check for a plan artifact" and "the system will not advance without a plan artifact." The kernel enforces gates for transitions matching its gate rules map; the OS provides additional gates (via agency specs) for OS-specific phases. Both layers contribute to enforcement; neither alone covers the full chain.

--- 2026-02-22T18:25:36Z | docs/glossary.md | CONTEXT:unknown ---
OLD: | # | OS Phase (`PHASES_JSON`) | Kernel Phase (`DefaultPhaseChain`) | Notes |
|---|---|---|---|
| 1 | `brainstorm` | `brainstorm` | Same |
| 2 | `brainstorm-reviewed` | `brainstorm-reviewed` | Same |
| 3 | `strategized` | `strategized` | Same |
| 4 | `planned` | `planned` | Same |
| 5 | `plan-reviewed` | *(no equivalent)* | OS-only — flux-drive plan review gate. Kernel has no `plan-reviewed` phase. |
| 6 | `executing` | `executing` | Same |
| 7 | `shipping` | `polish` | Historical divergence. OS rename deferred (see iv-52om). |
| 8 | `reflect` | `reflect` | Same. Gate rule `CheckArtifactExists` fires for both chains. |
| 9 | `done` | `done` | Same. Terminal phase — sets `status=completed`. |

**Kernel gate rule coverage:** Only `{reflect, done}: CheckArtifactExists` fires for OS-created sprints, because the OS uses different phase names for earlier phases. This is a known pre-existing condition.

**Why divergent:** `plan-reviewed` exists in the OS because flux-drive plan review is an OS-level gate with no kernel equivalent. `shipping` was the original name for the quality-gates/ship step; renaming it to `polish` requires migration of all existing sprints (deferred to iv-52om).
NEW: | # | OS Phase (`PHASES_JSON`) | Kernel Phase (`DefaultPhaseChain`) | Kernel Gate Fires? | Notes |
|---|---|---|---|---|
| 1 | `brainstorm` | `brainstorm` | Yes — `artifact_exists(brainstorm)` | Same name, gate fires |
| 2 | `brainstorm-reviewed` | `brainstorm-reviewed` | Yes — `artifact_exists(brainstorm-reviewed)` | Same name, gate fires |
| 3 | `strategized` | `strategized` | Yes — `artifact_exists(strategized)` | Same name, gate fires |
| 4 | `planned` | `planned` | Yes — `artifact_exists(planned)` | Same name, gate fires |
| 5 | `plan-reviewed` | *(no equivalent)* | No — OS-only | OS enforces via agency-spec gate (min 2 agents, max 3 P1 findings) |
| 6 | `executing` | `executing` | No — from-phase mismatch | Kernel expects `planned→executing`; OS sends `plan-reviewed→executing` |
| 7 | `shipping` | `polish` | No — name mismatch | Kernel expects `review→polish`; OS sends `executing→shipping` |
| 8 | `reflect` | `reflect` | No — from-phase mismatch | Kernel expects `polish→reflect`; OS sends `shipping→reflect` |
| 9 | `done` | `done` | Yes — `artifact_exists(reflect)` | Same from/to names, gate fires |

**Kernel gate rule coverage:** Kernel gates fire for 5 of 8 transitions in OS-created sprints (phases 1-4 and the final `reflect→done`). The middle transitions (5-8) bypass kernel gates because the OS phase names don't match the kernel's gate rules map keys. The OS compensates with its own gate enforcement via agency-spec.yaml, but this is OS-level policy enforcement, not kernel-enforced invariants.

**Why divergent:** `plan-reviewed` exists in the OS because flux-drive plan review is an OS-level gate with no kernel equivalent. `shipping` was the original name for the quality-gates/ship step; renaming it to `polish` requires migration of all existing sprints (deferred to iv-52om). The `plan-reviewed` insertion shifts all subsequent from-phase values, causing cascade mismatches.

**Resolution path:** Align the OS phase chain to use kernel phase names (replacing `plan-reviewed` with a gate on the `planned→executing` transition, and `shipping` with `polish`). This makes kernel gate enforcement cover the full chain. Tracked as iv-v5al.

--- 2026-02-22T18:25:55Z | core/intercore/docs/product/intercore-vision.md | CONTEXT:unknown ---
OLD: Gate rules are data, not code — stored as configuration that maps transitions to check types. Check types are kernel-provided primitives:

- `artifact_exists` — does an artifact exist for a given phase?
- `agents_complete` — are all active agents finished?
- `verdict_exists` — does a non-rejected dispatch verdict exist?
NEW: Gate rules map (from_phase, to_phase) pairs to check types. Check types are kernel-provided primitives:

- `artifact_exists` — does an artifact exist for a given phase?
- `agents_complete` — are all active agents finished?
- `verdict_exists` — does a non-rejected dispatch verdict exist?

> **Current state vs target.** Today, the gate rules map is compiled into the kernel binary (a Go map keyed by `[2]string{from, to}` phase pairs). Transitions not in this map have no gate requirements — they pass through. This means the kernel only enforces gates for transitions whose phase names exactly match the map keys. When the OS creates runs with custom phase names (e.g., `plan-reviewed`, `shipping`) that differ from the kernel's DefaultPhaseChain (`review`, `polish`), those transitions bypass kernel gates. The OS compensates with its own gate enforcement via agency specs, but this is policy-level enforcement, not kernel-enforced invariants. The target design is for gate rules to be runtime-configurable data supplied at run creation time (alongside the phase chain), making kernel gate enforcement work with any phase naming. See [glossary](../../../../docs/glossary.md) for the full phase mapping table.

--- 2026-02-22T18:26:58Z | core/intercore/docs/product/intercore-vision.md | CONTEXT:unknown ---
OLD: | Tier | Score Range | Kernel Event | Horizon |
|---|---|---|---|
| **High** | ≥ 0.8 | `discovery.promoted` | v3 |
| **Medium** | 0.5 – 0.8 | `discovery.proposed` | v3 |
| **Low** | 0.3 – 0.5 | `discovery.scored` | v3 |
| **Discard** | < 0.3 | Recorded with `discarded` status | v3 |

The kernel enforces tier boundaries as gate invariants — the scoring model produces a number, the tier boundaries are configuration, and the kernel rejects promotions that violate tier constraints. The human can always override (promote a low-scoring discovery manually), and that override is recorded as a feedback signal. For the OS-level actions at each tier (work item creation, briefing docs, inbox notifications), see the [Clavain vision doc](../../../../os/clavain/docs/clavain-vision.md) Discovery → Backlog Pipeline section.

> **Horizon note:** The discovery subsystem is planned for product horizon v3 (see Success at Each Horizon table). The `discoveries` table, confidence scoring, and tier enforcement do not exist in the current database schema (schema revision 5, tracked via `PRAGMA user_version`). These are different version axes: product horizons (v1–v4) describe feature milestones; schema revisions (1–N) track database migrations. The table above describes the target design.
NEW: | Tier | Score Range | Kernel Event | Status |
|---|---|---|---|
| **High** | ≥ 0.8 | `discovery.promoted` | Shipped (E5) |
| **Medium** | 0.5 – 0.8 | `discovery.proposed` | Shipped (E5) |
| **Low** | 0.3 – 0.5 | `discovery.scored` | Shipped (E5) |
| **Discard** | < 0.3 | Recorded with `discarded` status | Shipped (E5) |

The kernel enforces tier boundaries as gate invariants — the scoring model produces a number, the tier boundaries are configuration, and the kernel rejects promotions that violate tier constraints. The human can always override (promote a low-scoring discovery manually), and that override is recorded as a feedback signal. For the OS-level actions at each tier (work item creation, briefing docs, inbox notifications), see the [Clavain vision doc](../../../../os/clavain/docs/clavain-vision.md) Discovery → Backlog Pipeline section.

> **Status note:** The kernel discovery primitives are shipped (E5, schema v9): `discoveries` table, confidence scoring, tier enforcement, embedding search, feedback ingestion, decay, and rollback. The full `ic discovery` CLI surface is operational. What remains unshipped is the **OS-level pipeline integration**: interject source adapters emitting kernel events, event-driven scan triggers, and automated backlog refinement. The kernel provides the mechanism; the OS pipeline that consumes it is planned.

--- 2026-02-22T18:27:09Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: > **Current status:** The Discover stage is a future capability — the discovery pipeline, source adapters, and confidence-tiered autonomy depend on Intercore's discovery subsystem (v3). Today, work discovery is manual (beads backlog + human input). The Design → Build → Ship loop is the core product; Discover extends it once the core is proven. A sprint can begin at any macro-stage — `--from-step brainstorm` or `--from-step plan` skips Discover entirely.
NEW: > **Current status:** The kernel discovery primitives are shipped (E5): `ic discovery` CLI with submit, score, promote, dismiss, feedback, decay, rollback, and embedding search. The interject plugin implements source adapters (arXiv, HN, GitHub, Anthropic docs, Exa) with embedding-based scoring. What's **not** shipped is the OS-level pipeline integration: interject emitting kernel events, event-driven scan triggers, automated backlog refinement, and confidence-tiered autonomy policy. Today, work discovery is manual (beads backlog + human input). The Design → Build → Ship loop is the core product; the full Discover pipeline extends it once the OS integration lands. A sprint can begin at any macro-stage — `--from-step brainstorm` or `--from-step plan` skips Discover entirely.

--- 2026-02-22T18:29:06Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: What's missing is kernel integration — discovery events through the event bus, event-driven scan triggers, kernel-enforced confidence tiers, and backlog refinement.
NEW: What's missing is OS pipeline integration — feeding interject discoveries into the kernel event bus, event-driven scan triggers, and automated backlog refinement. The kernel primitives (discovery storage, confidence tiers, scoring, promotion/dismissal) shipped in E5.

--- 2026-02-22T18:29:22Z | os/clavain/docs/clavain-vision.md | CONTEXT:unknown ---
OLD: - Discovery pipeline (requires Intercore v3 + interject)
NEW: - Discovery pipeline (kernel primitives shipped in E5; OS integration with interject pending)

--- 2026-02-22T18:36:06Z | interverse/interflux/skills/flux-drive/SKILL.md | CONTEXT:unknown ---
OLD: ### Step 1.0.1: Classify Project Domain

Detect the project's domain(s) using signals from `config/flux-drive/domains/index.yaml`. This runs once per project and is cached.

**Cache check:** Look for `{PROJECT_ROOT}/.claude/flux-drive.yaml`. If it exists and contains `domains:` with at least one entry, skip detection and use cached results. If the file also contains `override: true`, never re-detect — the user has manually set their domains.

Note: The detect-domains.py script validates cache_version internally. Callers do not need to check the version field — stale formats are detected automatically via --check-stale.

**Detection** (when no cache or cache is stale):

Run the domain detection script:
```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --json
```

The script reads `config/flux-drive/domains/index.yaml`, scans directories/files/build-deps/keywords, computes weighted scores (directories 0.3, files 0.2, frameworks 0.3, keywords 0.2), and writes a cache to `{PROJECT_ROOT}/.claude/flux-drive.yaml`. The highest-confidence domain is marked `primary: true`.

- **Exit 0**: Domains detected — use the JSON output.
- **Exit 1**: No domains detected — use LLM fallback below (first scan only; does not apply to --check-stale).
- **Exit 2**: Script error — log warning, proceed without domain classification.

**LLM fallback** (exit code 1, first scan only): Infer domain from the Document Profile (Step 1.1) or build system files. Set confidence to 0.5 for inferred domains. Write results to `{PROJECT_ROOT}/.claude/flux-drive.yaml`.

**Performance budget:** This step should take <10 seconds. Use `ls` and targeted `grep`, not recursive find. Skip keyword scanning if directory+file+framework signals already exceed min_confidence for at least one domain.

**Output:** The detected domains feed into Step 1.0.2 (staleness check), Step 1.1 (document profile), Step 1.2 (agent scoring with domain bonuses), and Step 2.1a (domain-specific review criteria injection into agent prompts).

### Step 1.0.2: Check Staleness (pure, no side effects)

Check if the cached domain detection results are outdated due to structural project changes. This uses a three-tier strategy (hash → git → mtime) that completes in <100ms for the common case.

```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --check-stale
```

Exit codes:
- **0** → Cache is fresh, use cached domains. Proceed to Step 1.1.
- **3** → Cache is stale (structural changes detected). Proceed to Step 1.0.3.
- **4** → No cache exists (first run or deleted). Proceed to Step 1.0.3.
- **1** → No domains detected. Skip Steps 1.0.3 and 1.0.4 — proceed to Step 1.1 with core plugin agents only.
- **2** → Script error. Log warning: "Domain detection unavailable (detect-domains.py error). Agent auto-generation skipped. Run /flux-gen manually. Proceeding with core agents only." Proceed to Step 1.1.

### Step 1.0.3: Re-detect and Compare (writes cache only)

When staleness is detected (exit 3) or no cache exists (exit 4):

1. Read previous domains from cache (if any) before re-detection.

2. Re-run detection:
   ```bash
   python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --no-cache --json
   ```
   - If exit 1 (no domains): log "No domains detected." Proceed to Step 1.1.
   - If exit 2 (error): log error, proceed to Step 1.1.

3. Compare new domain list to previous:
   - Domains unchanged → proceed to Step 1.0.4 (check agents only)
   - Domains changed → log: "Domain shift: [old] → [new]". Proceed to Step 1.0.4 for domain-shift handling (Step 1.0.4 case b).

### Step 1.0.4: Agent Generation (writes agent files)

Auto-generate project-specific agents when domains are detected but agents are missing. This step is silent (no AskUserQuestion) — it runs non-interactively within the flux-drive pipeline.

1. **Validate domain profiles exist:**
   For each detected domain, check that `${CLAUDE_PLUGIN_ROOT}/config/flux-drive/domains/{domain}.md` exists AND has an `## Agent Specifications` section.
   - If profile missing: log warning, remove domain from generation list.
   - If ALL profiles missing: log error, suggest `--no-cache` re-detect. Skip generation.

2. **Check for existing project agents:**
   ```bash
   ls {PROJECT_ROOT}/.claude/agents/fd-*.md 2>/dev/null
   ```

3. **Decision matrix:**
   a. Agents exist AND domains unchanged → skip generation. Report "up to date."
   b. Agents exist AND domains changed →
      - Identify orphaned agents (domain removed) via YAML frontmatter check: parse `generated_by: flux-gen` and `domain:` fields
      - Report orphaned agents but do NOT delete them (users may have customized them). Log: "Orphaned agents (domain no longer detected): [list]. These will be excluded from triage. Delete manually if unwanted."
      - Identify missing agents (new domain added)
      - Log: "Domain shift: N new agents needed, M agents orphaned."
      - Generate only missing agents (don't touch existing)
   c. No agents exist AND domains detected →
      - Log: "Generating project agents for [domain1, domain2]..."
      - Generate agents using the template from `/flux-gen` Step 4 (including YAML frontmatter with `generated_by`, `domain`, `generated_at`, `flux_gen_version`)

4. **Track generation status per agent:**
   - On success: report agent name and focus line
   - On failure: log error with reason
   - After loop: "Generated N of M agents. K failed."
   - If any failed: list failures with reasons. Do NOT abort flux-drive.

5. **Report summary:**
   ```
   Domain check: game-simulation (0.65) — fresh (scanned 2026-02-09)
   Project agents: 2 exist, 1 generated, 0 failed
   ```
NEW: ### Step 1.0.1: Classify Project Domain

Detect the project's domain(s) for agent selection and domain-specific review criteria injection. Results are cached.

**Cache check:** Look for `{PROJECT_ROOT}/.claude/flux-drive.yaml`. If it exists and contains `domains:` with at least one entry, use cached results. If the file also contains `override: true`, never re-detect — the user has manually set their domains.

**Detection** (when no cache, cache is stale, or `source: heuristic` in cache):

Launch a Haiku subagent to classify the project:

1. Read these files (skip any that don't exist):
   - `{PROJECT_ROOT}/README.md` (or README.rst, README.txt, README)
   - The primary build file (first found: `go.mod`, `Cargo.toml`, `package.json`, `pyproject.toml`, `CMakeLists.txt`, `Makefile`)
   - 2-3 key source files from the main source directory (pick files that reveal purpose, not utility)

2. Dispatch a Haiku subagent (Task tool, `model: haiku`) with this prompt:

   ```
   Classify this project into one or more of these domains based on its actual purpose.
   Return ONLY a JSON object, no other text.

   Available domains:
   - game-simulation (game engines, simulations, ECS, storytelling)
   - ml-pipeline (ML training, inference, experiment tracking)
   - web-api (REST/GraphQL/gRPC services, web backends)
   - cli-tool (command-line tools, terminal utilities)
   - mobile-app (iOS/Android/cross-platform mobile apps)
   - embedded-systems (firmware, RTOS, hardware drivers)
   - library-sdk (reusable libraries, SDKs, packages)
   - data-pipeline (ETL, data warehousing, stream processing)
   - claude-code-plugin (Claude Code plugins, skills, hooks)
   - tui-app (terminal user interfaces, ncurses/bubbletea apps)
   - desktop-tauri (desktop apps via Tauri/Electron/Wails)

   Project files:
   <include file contents here>

   Respond with:
   {"domains": [{"name": "<domain>", "confidence": <0.0-1.0>, "reasoning": "<1 sentence>"}]}

   Rules:
   - Only include domains with confidence >= 0.3
   - A project can match multiple domains (e.g., a game server is both game-simulation and web-api)
   - Set the highest-confidence domain as primary
   - If no domain matches above 0.3, return {"domains": []}
   ```

3. Parse the JSON response. Write cache to `{PROJECT_ROOT}/.claude/flux-drive.yaml`:
   ```yaml
   cache_version: 2
   source: llm
   detected_at: '2026-02-22T12:00:00+00:00'
   content_hash: 'sha256:<hash of files read by LLM>'
   domains:
     - name: game-simulation
       confidence: 0.85
       reasoning: "Godot project with ECS architecture and storytelling system"
       primary: true
     - name: cli-tool
       confidence: 0.4
       reasoning: "Has CLI entry point for development tools"
   ```

**Heuristic fallback** (when Haiku call fails — timeout, API error, or unparseable response):

Run the legacy heuristic detector:
```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --json
```
- Exit 0: use output, mark `source: heuristic` in cache
- Exit 1: no domains detected, proceed with core agents only
- Exit 2: script error, proceed with core agents only

Log: `"Domain detection: LLM unavailable, using heuristic fallback."`

**Performance budget:** Detection should complete in <5 seconds. Cache check is <10ms.

**Output:** The detected domains feed into Step 1.0.2 (staleness), Step 1.1 (document profile), Step 1.2 (agent scoring with domain bonuses), and Step 2.1a (domain-specific review criteria injection).

### Step 1.0.2: Check Staleness

Check if cached domain detection is outdated by comparing content hashes.

1. Read `content_hash` from `{PROJECT_ROOT}/.claude/flux-drive.yaml`
2. If no `content_hash` field (old cache format or heuristic source): cache is stale, proceed to Step 1.0.3
3. Re-hash the same files (README + build file + key source files) using SHA-256
4. If hashes match: cache is fresh, proceed to Step 1.1
5. If hashes differ: cache is stale, proceed to Step 1.0.3

### Step 1.0.3: Re-detect

When staleness is detected or no cache exists:

1. Read previous domains from cache (if any) for comparison
2. Run LLM detection (Step 1.0.1 detection flow)
3. Compare new vs previous:
   - Unchanged → proceed to Step 1.0.4
   - Changed → log: `"Domain shift: [old] → [new]"`. Proceed to Step 1.0.4

### Step 1.0.4: Agent Generation

Auto-generate project-specific agents using the shared `generate-agents.py` script. This runs non-interactively within the flux-drive pipeline.

```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/generate-agents.py {PROJECT_ROOT} --mode=regenerate-stale --json
```

**Exit codes:**
- **0**: Agents generated or all up-to-date. Parse JSON report from stdout.
- **1**: No domains in cache. Skip generation, proceed to Step 1.1 with core agents only.
- **2**: Script error. Log warning, proceed with core agents only.

**Interpret the JSON report:**

```json
{
  "status": "ok",
  "agents": [
    {"name": "fd-simulation-kernel", "domain": "game-simulation", "action": "created"},
    {"name": "fd-game-systems", "domain": "game-simulation", "action": "skipped", "reason": "up-to-date (v4)"},
    {"name": "fd-old-agent", "domain": "removed-domain", "action": "orphaned", "reason": "domain 'removed-domain' no longer detected"}
  ]
}
```

**Actions to report:**
- `created`: Log: `"Generated: {name} ({domain})"`
- `skipped`: Silent (agent is current)
- `regenerated`: Log: `"Regenerated: {name} ({reason})"`
- `orphaned`: Log: `"Orphaned: {name} — {reason}. Delete manually if unwanted."`
- `failed`: Log as warning

**Summary line:**
```
Domain agents: N exist, M generated, K orphaned
```

--- 2026-02-22T18:36:18Z | interverse/interflux/skills/flux-drive/SKILL-compact.md | CONTEXT:unknown ---
OLD: ### Step 1.0.1: Domain Detection

**Cache check:** `{PROJECT_ROOT}/.claude/flux-drive.yaml` — if exists with `domains:`, use cached. If `override: true`, never re-detect.

**Detection:** `python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --json`
- Exit 0: domains detected, use output
- Exit 1: no domains, proceed with core agents only
- Exit 2: script error, proceed with core agents only

**Staleness:** `python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --check-stale`
- Exit 0: fresh. Exit 3: stale (re-detect). Exit 4: no cache (detect).

### Step 1.0.4: Agent Generation

If domains detected but no `{PROJECT_ROOT}/.claude/agents/fd-*.md` exist, generate them using domain profiles from `config/flux-drive/domains/{domain}.md`.
NEW: ### Step 1.0.1: Domain Detection

**Cache check:** `{PROJECT_ROOT}/.claude/flux-drive.yaml` — if exists with `domains:` and `content_hash:` matches current files, use cached. If `override: true`, never re-detect.

**Detection:** Launch Haiku subagent (Task tool, `model: haiku`) with README + build file + 2-3 key source files. Prompt asks for `{"domains": [{"name", "confidence", "reasoning"}]}` from 11 known domains. Cache result with `source: llm` and `content_hash`.

**Fallback:** If Haiku fails: `python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --json`. Mark `source: heuristic`.

**Staleness:** Compare `content_hash` in cache vs current file hashes. No hash or mismatch → stale (re-detect). Match → fresh.

### Step 1.0.4: Agent Generation

```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/generate-agents.py {PROJECT_ROOT} --mode=regenerate-stale --json
```
Exit 0: parse JSON report (created/skipped/regenerated/orphaned per agent). Exit 1: no domains. Exit 2: error. Report orphans, don't delete.

--- 2026-02-22T18:37:44Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD: """Detect project domains using signals from flux-drive domain index.

Scans directories, files, build-system dependencies, and source keywords
to classify a project into one or more domains (e.g. game-simulation,
web-api, ml-pipeline).  Results are cached at {PROJECT}/.claude/flux-drive.yaml.

Exit codes:
    0  Domains detected (or cache is fresh when --check-stale)
    1  No domains detected (first scan: caller may use LLM fallback; staleness check: skip generation)
    2  Fatal error
    3  Cache is stale (structural changes detected) — only with --check-stale
    4  No cache exists — only with --check-stale
"""
NEW: """Detect project domains using signals from flux-drive domain index.

Scans directories, files, build-system dependencies, and source keywords
to classify a project into one or more domains (e.g. game-simulation,
web-api, ml-pipeline).  Results are cached at {PROJECT}/.claude/flux-drive.yaml.

Exit codes:
    0  Domains detected
    1  No domains detected (caller may use LLM fallback)
    2  Fatal error
"""

# This script is the heuristic fallback for domain detection.
# Primary detection uses LLM-based classification (Haiku subagent in flux-drive SKILL.md).
# This script runs when the LLM is unavailable (offline, API error, timeout).

--- 2026-02-22T18:37:48Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD: import argparse
import datetime as dt
import fnmatch
import hashlib
import json
import os
import re
import subprocess
import sys
import tempfile
import tomllib
from pathlib import Path
from typing import Any
NEW: import argparse
import datetime as dt
import fnmatch
import json
import os
import re
import sys
import tempfile
import tomllib
from pathlib import Path
from typing import Any

--- 2026-02-22T18:37:54Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD: # Files whose presence/absence/content indicates structural project changes
STRUCTURAL_FILES = {
    "package.json", "Cargo.toml", "go.mod", "pyproject.toml",
    "requirements.txt", "Gemfile", "build.gradle", "build.gradle.kts",
    "project.godot", "pom.xml", "CMakeLists.txt", "Makefile",
}

# File extensions indicating structural project type changes (new tech stack)
STRUCTURAL_EXTENSIONS = {
    ".gd", ".tscn", ".unity", ".uproject",
}
NEW: 

--- 2026-02-22T18:38:01Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD: # ---------------------------------------------------------------------------
# Structural hash
# ---------------------------------------------------------------------------

def compute_structural_hash(project: Path) -> str:
    """Compute deterministic hash of structural files.

    For each file in sorted(STRUCTURAL_FILES):
      - If file exists: sha256(file_contents)
      - If file missing: sentinel "__absent__"
    Concatenate "filename:hash\\n" pairs, hash the result.
    Returns "sha256:{hex}" prefixed string.
    """
    parts: list[str] = []
    for name in sorted(STRUCTURAL_FILES):
        fpath = project / name
        if fpath.is_file():
            try:
                content = fpath.read_bytes()
                file_hash = hashlib.sha256(content).hexdigest()
            except OSError:
                file_hash = "__absent__"
        else:
            file_hash = "__absent__"
        parts.append(f"{name}:{file_hash}")
    combined = "\n".join(parts) + "\n"
    overall = hashlib.sha256(combined.encode("utf-8")).hexdigest()
    return f"sha256:{overall}"
NEW: 

--- 2026-02-22T18:38:33Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD: # ---------------------------------------------------------------------------
# Staleness detection
# ---------------------------------------------------------------------------

def _parse_iso_datetime(s: str) -> dt.datetime | None:
    """Parse an ISO 8601 datetime string, returning None on failure."""
    if not s:
        return None
    try:
        parsed = dt.datetime.fromisoformat(s)
        if parsed.tzinfo is None:
            parsed = parsed.replace(tzinfo=dt.timezone.utc)
        return parsed
    except (ValueError, TypeError):
        # Fall back to date-only format from v0 caches
        try:
            d = dt.date.fromisoformat(s)
            return dt.datetime(d.year, d.month, d.day, tzinfo=dt.timezone.utc)
        except (ValueError, TypeError):
            return None


def _check_stale_tier1(project: Path, cache: dict[str, Any]) -> int | None:
    """Tier 1: Structural hash comparison (<100ms).

    Returns:
        0 if hash matches (fresh)
        3 if hash differs (stale)
        None if hash missing from cache (try next tier)
    """
    cached_hash = cache.get("structural_hash")
    if not cached_hash or not isinstance(cached_hash, str):
        return None
    current_hash = compute_structural_hash(project)
    if current_hash == cached_hash:
        return 0
    return 3


def _check_stale_tier2(project: Path, cache: dict[str, Any], dry_run: bool = False) -> int | None:
    """Tier 2: Git log check (<500ms).

    Returns:
        0 if no structural changes since detection (fresh)
        3 if structural changes found (stale)
        None if git unavailable (try next tier)
    """
    git_dir = project / ".git"
    if not git_dir.exists():
        return None

    # Detect shallow clone — git log --since is unreliable without full history
    try:
        shallow_check = subprocess.run(
            ["git", "rev-parse", "--is-shallow-repository"],
            capture_output=True, text=True, timeout=5, cwd=str(project),
        )
        if shallow_check.returncode == 0 and shallow_check.stdout.strip() == "true":
            return None  # fall to tier 3
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass

    detected_at = cache.get("detected_at", "")
    parsed = _parse_iso_datetime(str(detected_at))
    if parsed is None:
        return 3  # can't compare without a timestamp

    since_str = parsed.isoformat()

    # Check additions, modifications, copies, deletions (not renames — handled separately)
    try:
        result = subprocess.run(
            ["git", "log", f"--since={since_str}", "--diff-filter=ACDM",
             "--name-only", "--format=", "HEAD"],
            capture_output=True, text=True, timeout=5, cwd=str(project),
        )
        if result.returncode != 0:
            if result.stderr.strip():
                print(f"Warning: git log failed (exit {result.returncode}): {result.stderr.strip()}", file=sys.stderr)
            return None  # git error, fall to tier 3
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return None

    changed_files = {line.strip() for line in result.stdout.splitlines() if line.strip()}

    triggers: list[str] = []
    for f in changed_files:
        basename = os.path.basename(f)
        if basename in STRUCTURAL_FILES:
            triggers.append(f"structural file: {f}")
        _, ext = os.path.splitext(f)
        if ext in STRUCTURAL_EXTENSIONS:
            triggers.append(f"structural extension: {f}")

    # Check renames separately
    try:
        rename_result = subprocess.run(
            ["git", "log", f"--since={since_str}", "--diff-filter=R",
             "--name-status", "--format=", "HEAD"],
            capture_output=True, text=True, timeout=5, cwd=str(project),
        )
        if rename_result.returncode == 0:
            for line in rename_result.stdout.splitlines():
                parts = line.strip().split("\t")
                if len(parts) >= 3:
                    old_name = os.path.basename(parts[1])
                    new_name = os.path.basename(parts[2])
                    old_structural = old_name in STRUCTURAL_FILES
                    new_structural = new_name in STRUCTURAL_FILES
                    if old_structural != new_structural:
                        triggers.append(f"structural rename: {parts[1]} -> {parts[2]}")
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass  # rename check is best-effort

    if dry_run and triggers:
        for t in triggers:
            print(f"  Trigger: {t}")

    return 3 if triggers else 0


def _check_stale_tier3(project: Path, cache: dict[str, Any]) -> int:
    """Tier 3: Mtime fallback for non-git projects.

    Returns:
        0 if no structural files newer than detection (fresh)
        3 if any structural file is newer (stale)
    """
    detected_at = cache.get("detected_at", "")
    parsed = _parse_iso_datetime(str(detected_at))
    if parsed is None:
        return 3  # can't compare without a timestamp

    # Convert to epoch for mtime comparison
    detected_epoch = parsed.timestamp()

    for name in STRUCTURAL_FILES:
        fpath = project / name
        if fpath.is_file():
            try:
                if fpath.stat().st_mtime > detected_epoch:
                    return 3
            except OSError:
                pass

    return 0


def check_stale(project: Path, cache_path: Path, dry_run: bool = False) -> int:
    """Check if cached domain detection is stale.

    Returns exit code:
        0 — cache is fresh (or override: true)
        3 — cache is stale
        4 — no cache exists
    """
    cache = read_cache(cache_path)
    if cache is None:
        if dry_run:
            print("No cache found.")
        return 4

    # override: true short-circuits before any computation
    if cache.get("override"):
        if dry_run:
            print("Cache has override: true — never stale.")
        return 0

    # cache_version missing or mismatched (older OR newer than expected)
    version = cache.get("cache_version")
    if version is None or (isinstance(version, int) and version != CACHE_VERSION):
        if dry_run:
            direction = "older" if version is None or version < CACHE_VERSION else "newer"
            print(f"Cache version {version} != {CACHE_VERSION} — stale ({direction} format).")
        return 3

    # Tier 1: Hash check
    if dry_run:
        cached_hash = cache.get("structural_hash", "(none)")
        current_hash = compute_structural_hash(project)
        print(f"Tier 1 (hash): {cached_hash} → {current_hash}")
    tier1 = _check_stale_tier1(project, cache)
    if tier1 is not None:
        if dry_run:
            print(f"  Verdict: {'FRESH' if tier1 == 0 else 'STALE'}")
        return tier1

    # Tier 2: Git log
    if dry_run:
        print(f"Tier 2 (git): checking changes since {cache.get('detected_at', '(unknown)')}")
    tier2 = _check_stale_tier2(project, cache, dry_run=dry_run)
    if tier2 is not None:
        if dry_run:
            print(f"  Verdict: {'FRESH' if tier2 == 0 else 'STALE'}")
        return tier2

    # Tier 3: Mtime fallback
    if dry_run:
        print("Tier 3 (mtime): checking file modification times")
    tier3 = _check_stale_tier3(project, cache)
    if dry_run:
        print(f"  Verdict: {'FRESH' if tier3 == 0 else 'STALE'}")
    return tier3
NEW: 

--- 2026-02-22T18:38:40Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD: def write_cache(path: Path, results: list[dict[str, Any]], structural_hash: str | None = None) -> None:
    """Write detection results as YAML cache with atomic rename.

    Uses temp-file-and-rename pattern to prevent corruption from
    interrupted writes.
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    payload: dict[str, Any] = {
        "cache_version": CACHE_VERSION,
        "domains": results,
        "detected_at": dt.datetime.now(dt.timezone.utc).isoformat(),
    }
    if structural_hash is not None:
        payload["structural_hash"] = structural_hash
NEW: def write_cache(path: Path, results: list[dict[str, Any]]) -> None:
    """Write detection results as YAML cache with atomic rename.

    Uses temp-file-and-rename pattern to prevent corruption from
    interrupted writes.
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    payload: dict[str, Any] = {
        "cache_version": CACHE_VERSION,
        "domains": results,
        "detected_at": dt.datetime.now(dt.timezone.utc).isoformat(),
    }

--- 2026-02-22T18:38:50Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD:     parser.add_argument("--no-cache", action="store_true", help="Force re-scan even if cache exists")
    parser.add_argument("--json", action="store_true", dest="json_output", help="Output JSON instead of YAML")
    parser.add_argument("--check-stale", action="store_true", help="Check if cache is stale (exit 0=fresh, 3=stale, 4=none)")
    parser.add_argument("--dry-run", action="store_true", help="With --check-stale: show diagnostic details")
    args = parser.parse_args()

    project = args.project_root.resolve()
    if not project.is_dir():
        print(f"Error: {project} is not a directory", file=sys.stderr)
        return 2

    cache_path = (args.cache_path or project / ".claude" / "flux-drive.yaml").resolve()

    # --check-stale mode: just check and exit
    if args.check_stale:
        return check_stale(project, cache_path, dry_run=args.dry_run)

    index_path = args.index_yaml.resolve()
NEW:     parser.add_argument("--no-cache", action="store_true", help="Force re-scan even if cache exists")
    parser.add_argument("--json", action="store_true", dest="json_output", help="Output JSON instead of YAML")
    args = parser.parse_args()

    project = args.project_root.resolve()
    if not project.is_dir():
        print(f"Error: {project} is not a directory", file=sys.stderr)
        return 2

    cache_path = (args.cache_path or project / ".claude" / "flux-drive.yaml").resolve()

    index_path = args.index_yaml.resolve()

--- 2026-02-22T18:38:54Z | interverse/interflux/scripts/detect-domains.py | CONTEXT:unknown ---
OLD:     if not results:
        return 1

    # Compute structural hash for cache
    structural_hash = compute_structural_hash(project)

    # Write cache and output
    write_cache(cache_path, results, structural_hash=structural_hash)
NEW:     if not results:
        return 1

    # Write cache and output
    write_cache(cache_path, results)

--- 2026-02-22T18:39:09Z | interverse/interflux/tests/structural/test_detect_domains.py | CONTEXT:unknown ---
OLD: import importlib.util
import json
import os
import subprocess
import sys
import time
from pathlib import Path
NEW: import importlib.util
import json
import os
import subprocess
import sys
from pathlib import Path

--- 2026-02-22T18:39:15Z | interverse/interflux/tests/structural/test_detect_domains.py | CONTEXT:unknown ---
OLD: CACHE_VERSION = _mod.CACHE_VERSION
DomainSpec = _mod.DomainSpec
STRUCTURAL_FILES = _mod.STRUCTURAL_FILES
check_stale = _mod.check_stale
compute_structural_hash = _mod.compute_structural_hash
detect = _mod.detect
gather_directories = _mod.gather_directories
gather_files = _mod.gather_files
gather_frameworks = _mod.gather_frameworks
gather_keywords = _mod.gather_keywords
load_index = _mod.load_index
read_cache = _mod.read_cache
score_domain = _mod.score_domain
write_cache = _mod.write_cache
NEW: CACHE_VERSION = _mod.CACHE_VERSION
DomainSpec = _mod.DomainSpec
detect = _mod.detect
gather_directories = _mod.gather_directories
gather_files = _mod.gather_files
gather_frameworks = _mod.gather_frameworks
gather_keywords = _mod.gather_keywords
load_index = _mod.load_index
read_cache = _mod.read_cache
score_domain = _mod.score_domain
write_cache = _mod.write_cache

--- 2026-02-22T18:39:26Z | interverse/interflux/tests/structural/test_detect_domains.py | CONTEXT:unknown ---
OLD: class TestStructuralHash:
    """Tests for compute_structural_hash()."""

    def test_empty_project_deterministic(self, tmp_path):
        """Empty project - consistent hash (all files absent)."""
        h1 = compute_structural_hash(tmp_path)
        h2 = compute_structural_hash(tmp_path)
        assert h1 == h2
        assert h1.startswith("sha256:")

    def test_hash_changes_with_file(self, tmp_path):
        """Adding a structural file changes the hash."""
        h1 = compute_structural_hash(tmp_path)
        (tmp_path / "package.json").write_text('{"name": "test"}', encoding="utf-8")
        h2 = compute_structural_hash(tmp_path)
        assert h1 != h2

    def test_hash_stable_with_same_content(self, tmp_path):
        """Same file content - same hash regardless of mtime."""
        (tmp_path / "Cargo.toml").write_text('[package]\nname = "x"\n', encoding="utf-8")
        h1 = compute_structural_hash(tmp_path)
        # Rewrite with identical content
        time.sleep(0.01)
        (tmp_path / "Cargo.toml").write_text('[package]\nname = "x"\n', encoding="utf-8")
        h2 = compute_structural_hash(tmp_path)
        assert h1 == h2

    def test_hash_ignores_non_structural_files(self, tmp_path):
        """Non-structural files do not affect the hash."""
        h1 = compute_structural_hash(tmp_path)
        (tmp_path / "README.md").write_text("hello", encoding="utf-8")
        (tmp_path / "main.py").write_text("print('hi')", encoding="utf-8")
        h2 = compute_structural_hash(tmp_path)
        assert h1 == h2

    def test_hash_prefix_format(self, tmp_path):
        """Hash output has sha256: prefix."""
        h = compute_structural_hash(tmp_path)
        assert h.startswith("sha256:")
        hex_part = h.split(":")[1]
        assert len(hex_part) == 64  # SHA-256 hex length

    def test_all_structural_files_considered(self, tmp_path):
        """Each STRUCTURAL_FILE independently affects the hash."""
        base_hash = compute_structural_hash(tmp_path)
        for name in sorted(STRUCTURAL_FILES):
            (tmp_path / name).write_text(f"content-{name}", encoding="utf-8")
            new_hash = compute_structural_hash(tmp_path)
            assert new_hash != base_hash, f"Adding {name} should change the hash"
            (tmp_path / name).unlink()


class TestStalenessCheck:
NEW: class TestStalenessCheck:

--- 2026-02-22T18:39:37Z | interverse/interflux/tests/structural/test_detect_domains.py | CONTEXT:unknown ---
OLD: class TestStalenessCheck:
    """Tests for check_stale() and its tier functions."""

    def test_no_cache_returns_4(self, tmp_path):
        """No cache file - exit code 4."""
        result = check_stale(tmp_path, tmp_path / ".claude" / "flux-drive.yaml")
        assert result == 4

    def test_override_always_fresh(self, tmp_path):
        """Cache with override: true - exit code 0 regardless of staleness."""
        cache_path = tmp_path / "flux-drive.yaml"
        cache_path.write_text(
            "override: true\ncache_version: 1\ndomains:\n  - name: custom\n    confidence: 1.0\ndetected_at: '2026-01-01'\n",
            encoding="utf-8",
        )
        result = check_stale(tmp_path, cache_path)
        assert result == 0

    def test_missing_version_is_stale(self, tmp_path):
        """Cache without cache_version - exit code 3 (format upgrade)."""
        cache_path = tmp_path / "flux-drive.yaml"
        cache_path.write_text(
            "domains:\n  - name: test\n    confidence: 0.5\ndetected_at: '2026-01-01'\n",
            encoding="utf-8",
        )
        result = check_stale(tmp_path, cache_path)
        assert result == 3

    def test_matching_hash_is_fresh(self, tmp_path):
        """Cache with matching structural hash - exit code 0."""
        current_hash = compute_structural_hash(tmp_path)
        cache_path = tmp_path / "flux-drive.yaml"
        cache_path.write_text(
            f"cache_version: {CACHE_VERSION}\nstructural_hash: '{current_hash}'\n"
            f"domains:\n  - name: test\n    confidence: 0.5\ndetected_at: '2026-01-01T00:00:00+00:00'\n",
            encoding="utf-8",
        )
        result = check_stale(tmp_path, cache_path)
        assert result == 0

    def test_mismatched_hash_is_stale(self, tmp_path):
        """Cache with different structural hash - exit code 3."""
        cache_path = tmp_path / "flux-drive.yaml"
        cache_path.write_text(
            f"cache_version: {CACHE_VERSION}\nstructural_hash: 'sha256:stale_hash_value'\n"
            f"domains:\n  - name: test\n    confidence: 0.5\ndetected_at: '2026-01-01T00:00:00+00:00'\n",
            encoding="utf-8",
        )
        result = check_stale(tmp_path, cache_path)
        assert result == 3


class TestDetect:
NEW: class TestDetect:

--- 2026-02-22T18:39:41Z | docs/glossary.md | CONTEXT:unknown ---
OLD: # Interverse Glossary

> Canonical terminology for the Interverse ecosystem. When terms are used differently across documents, this glossary defines the correct usage. See [architecture.md](architecture.md) for the 3-layer model diagram.

## Kernel (L1 — Intercore)
NEW: # Demarch Glossary

> Canonical terminology for the Demarch platform. When terms are used differently across documents, this glossary defines the correct usage. See [architecture.md](architecture.md) for the 3-layer model diagram.

## Pillars

Demarch has five pillars — the major components that make up the platform:

| Pillar | What it is | Layer |
|--------|-----------|-------|
| **Intercore** | Orchestration kernel — runs, phases, gates, dispatches, events. The durable system of record. | L1 (Kernel) |
| **Clavain** | Agent OS — workflow policy, sprint lifecycle, model routing, agent dispatch. The reference agency. | L2 (OS) |
| **Interverse** | 33+ companion plugins, each wrapping one capability. Independently installable. | L2 (Drivers) |
| **Autarch** | Application layer — TUI tools (Bigend, Gurgeh, Coldwine, Pollard). | L3 (Apps) |
| **Interspect** | Adaptive profiler — reads kernel events, proposes OS configuration changes. The learning loop. | Cross-cutting |

"Pillar" is the organizational term for major components. "Layer" (L1/L2/L3) describes the architectural dependency hierarchy between them. Use "pillar" when listing what Demarch is made of; use "layer" when discussing how components interact, write-path contracts, or survival properties.

## Kernel (L1 — Intercore)

--- 2026-02-22T18:39:45Z | interverse/interflux/tests/structural/test_detect_domains.py | CONTEXT:unknown ---
OLD:     def test_write_includes_structural_hash(self, tmp_path):
        """write_cache() with structural_hash param includes it in output."""
        cache_path = tmp_path / "flux-drive.yaml"
        test_hash = "sha256:abc123"
        write_cache(cache_path, [{"name": "test", "confidence": 0.5}], structural_hash=test_hash)
        cached = read_cache(cache_path)
        assert cached is not None
        assert cached["structural_hash"] == test_hash

    def test_write_without_structural_hash(self, tmp_path):
        """write_cache() without structural_hash param omits the key."""
        cache_path = tmp_path / "flux-drive.yaml"
        write_cache(cache_path, [{"name": "test", "confidence": 0.5}])
        cached = read_cache(cache_path)
        assert cached is not None
        assert "structural_hash" not in cached

    def test_write_iso_timestamp(self, tmp_path):
NEW:     def test_write_no_structural_hash(self, tmp_path):
        """write_cache() does not include structural_hash (staleness removed)."""
        cache_path = tmp_path / "flux-drive.yaml"
        write_cache(cache_path, [{"name": "test", "confidence": 0.5}])
        cached = read_cache(cache_path)
        assert cached is not None
        assert "structural_hash" not in cached

    def test_write_iso_timestamp(self, tmp_path):

--- 2026-02-22T18:39:47Z | docs/glossary.md | CONTEXT:unknown ---
OLD: | "API" (for intercore v1) | CLI surface | There is no Go library API in v1; the CLI is the contract |
NEW: | "API" (for intercore v1) | CLI surface | There is no Go library API in v1; the CLI is the contract |
| "component" (for top-level) | pillar | Intercore, Clavain, Interverse, Autarch, and Interspect are pillars; "component" is vague |
| "pillar" (for sub-modules) | driver, companion plugin, tool | Pillars are only the 5 top-level entries; interflux, interlock, etc. are drivers |

--- 2026-02-22T18:39:52Z | interverse/interflux/tests/structural/test_detect_domains.py | CONTEXT:unknown ---
OLD: class TestCacheV1:
    """Tests for cache format v1 features: cache_version, structural_hash, ISO timestamps."""
NEW: class TestCacheV1:
    """Tests for cache format v1 features: cache_version and ISO timestamps."""

--- 2026-02-22T18:39:54Z | docs/architecture.md | CONTEXT:unknown ---
OLD: # Interverse Architecture

> **Version:** 1.1 | **Last updated:** 2026-02-20

## The Three-Layer Model
NEW: # Demarch Architecture

> **Version:** 1.2 | **Last updated:** 2026-02-22

## Five Pillars

Demarch is built from five pillars — major components that together form the platform:

| Pillar | Role |
|--------|------|
| **Intercore** | Orchestration kernel — the durable system of record |
| **Clavain** | Agent OS — workflow policy and the reference agency |
| **Interverse** | 33+ companion plugins, each independently valuable |
| **Autarch** | Application layer — TUI surfaces for kernel state |
| **Interspect** | Adaptive profiler — the learning loop |

Pillars describe *what* makes up Demarch. The three-layer model below describes *how* they relate.

## The Three-Layer Model

--- 2026-02-22T18:39:59Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: ## The Stack

Three layers, one cross-cutting profiler. Each has a clear owner, a clear boundary, and a clear survival property.
NEW: ## The Stack

Five pillars, organized in three layers plus one cross-cutting profiler. Each pillar has a clear owner, a clear boundary, and a clear survival property.

--- 2026-02-22T18:40:04Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: Everything is open source. The kernel (Intercore), the OS (Clavain), all 33+ companion plugins, the TUI tools (Autarch), and the profiler (Interspect).
NEW: Everything is open source. All five pillars: the kernel (Intercore), the OS (Clavain), the companion plugins (Interverse), the TUI tools (Autarch), and the profiler (Interspect).

--- 2026-02-22T18:40:09Z | docs/demarch-vision.md | CONTEXT:unknown ---
OLD: It has since grown into an autonomous agency with its own kernel, profiler, TUI suite, and ecosystem of 42 modules across 5 layers.
NEW: It has since grown into an autonomous software development agency platform with five pillars and 42 modules.

--- 2026-02-22T18:40:31Z | docs/demarch-reference.md | CONTEXT:unknown ---
OLD: ## The Constellation

37 modules organized by architectural role.

### Infrastructure
NEW: ## The Five Pillars

Demarch's top-level organizational units. Each pillar has a clear owner and boundary. See [glossary.md](./glossary.md) for how pillars relate to the 3-layer architecture.

| Pillar | Role | Layer |
|--------|------|-------|
| **Intercore** | Orchestration kernel — durable system of record | L1 (Kernel) |
| **Clavain** | Agent OS — workflow policy, reference agency | L2 (OS) |
| **Interverse** | 33+ companion plugins, each independently valuable | L2 (Drivers) |
| **Autarch** | TUI surfaces — Bigend, Gurgeh, Coldwine, Pollard | L3 (Apps) |
| **Interspect** | Adaptive profiler — the learning loop | Cross-cutting |

## The Constellation

37 modules organized by architectural role within the pillars.

### Infrastructure (Intercore pillar)

--- 2026-02-22T18:40:35Z | docs/demarch-reference.md | CONTEXT:unknown ---
OLD: ### Operating System
NEW: ### Operating System (Clavain pillar)

--- 2026-02-22T18:40:39Z | docs/demarch-reference.md | CONTEXT:unknown ---
OLD: ### Core Drivers
NEW: ### Core Drivers (Interverse pillar)

--- 2026-02-22T18:40:43Z | docs/demarch-reference.md | CONTEXT:unknown ---
OLD: ### Applications
NEW: ### Applications (Autarch pillar)

--- 2026-02-22T18:40:52Z | docs/demarch-reference.md | CONTEXT:unknown ---
OLD: Demarch is adoptable incrementally. Each step adds capability on top of the previous:

**Step 1: One driver.** Install a single companion plugin (interflux for code review, tldr-swinton for code context). Works in vanilla Claude Code. No other Demarch modules required.

**Step 2: Clavain (OS).** Install Clavain for the sprint workflow, quality gates, and brainstorm→ship lifecycle. Drivers are auto-discovered and integrated.

**Step 3: Intercore (kernel).** Install the `ic` CLI for durable state. Runs, phases, gates, and events persist across sessions. Crash recovery. Audit trails.

**Step 4: Interspect (profiler).** Enable the adaptive profiler. Agent routing improves based on outcome data. Gate rules tighten or relax based on evidence. The system starts learning.

**Step 5: Autarch (apps).** Install the TUI tools for interactive dashboards, PRD generation, and task orchestration.

Each step is optional. Step 1 is useful without Step 2. Step 2 is useful without Step 3. The stack rewards depth but doesn't demand it.
NEW: Demarch is adoptable incrementally — one pillar at a time. Each step adds capability on top of the previous:

**Step 1: Interverse (one driver).** Install a single companion plugin (interflux for code review, tldr-swinton for code context). Works in vanilla Claude Code. No other pillars required.

**Step 2: Clavain (OS).** Install the OS pillar for the sprint workflow, quality gates, and brainstorm→ship lifecycle. Drivers are auto-discovered and integrated.

**Step 3: Intercore (kernel).** Install the kernel pillar for durable state. Runs, phases, gates, and events persist across sessions. Crash recovery. Audit trails.

**Step 4: Interspect (profiler).** Enable the profiler pillar. Agent routing improves based on outcome data. Gate rules tighten or relax based on evidence. The system starts learning.

**Step 5: Autarch (apps).** Install the apps pillar for interactive dashboards, PRD generation, and task orchestration.

Each step is optional. Step 1 is useful without Step 2. Step 2 is useful without Step 3. The stack rewards depth but doesn't demand it.

--- 2026-02-22T18:46:28Z | interverse/interflux/scripts/generate-agents.py | CONTEXT:unknown ---
OLD: def _atomic_write(path: Path, content: str) -> None:
    """Write content to a file atomically using tempfile + rename."""
    path.parent.mkdir(parents=True, exist_ok=True)
    data = content.encode("utf-8")

    fd, tmp_path = tempfile.mkstemp(dir=str(path.parent), suffix=".tmp")
    try:
        os.write(fd, data)
        os.fsync(fd)
        os.close(fd)
        os.rename(tmp_path, str(path))
    except Exception:
        try:
            os.close(fd)
        except OSError:
            pass
        try:
            os.unlink(tmp_path)
        except OSError:
            pass
        raise
NEW: def _atomic_write(path: Path, content: str) -> None:
    """Write content to a file atomically using tempfile + rename."""
    path.parent.mkdir(parents=True, exist_ok=True)
    data = content.encode("utf-8")

    fd, tmp_path = tempfile.mkstemp(dir=str(path.parent), suffix=".tmp")
    closed = False
    try:
        os.write(fd, data)
        os.fsync(fd)
        os.close(fd)
        closed = True
        os.rename(tmp_path, str(path))
    except Exception:
        if not closed:
            try:
                os.close(fd)
            except OSError:
                pass
        try:
            os.unlink(tmp_path)
        except OSError:
            pass
        raise

--- 2026-02-22T18:46:45Z | docs/plans/2026-02-22-flux-drive-intermediate-findings.md | CONTEXT:unknown ---
OLD:     timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    jq -n -c \
      --arg sev "$severity" \
      --arg agt "$agent" \
      --arg cat "$category" \
      --arg sum "$summary" \
      --arg ts "$timestamp" \
      --argjson refs "$refs" \
      '{severity:$sev, agent:$agt, category:$cat, summary:$sum, file_refs:$refs, timestamp:$ts}' \
      >> "$findings_file"
NEW:     timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    # Build JSON line in memory, then write as single atomic append (< PIPE_BUF)
    line=$(jq -n -c \
      --arg sev "$severity" \
      --arg agt "$agent" \
      --arg cat "$category" \
      --arg sum "$summary" \
      --arg ts "$timestamp" \
      --argjson refs "$refs" \
      '{severity:$sev, agent:$agt, category:$cat, summary:$sum, file_refs:$refs, timestamp:$ts}')
    echo "$line" >> "$findings_file"

--- 2026-02-22T18:46:52Z | docs/plans/2026-02-22-flux-drive-intermediate-findings.md | CONTEXT:unknown ---
OLD:     filter="${2:-all}"
    if [[ ! -f "$findings_file" ]]; then
      echo "[]"
      exit 0
    fi
    case "$filter" in
      blocking) jq -s '[.[] | select(.severity == "blocking")]' "$findings_file" ;;
      notable)  jq -s '[.[] | select(.severity == "notable")]' "$findings_file" ;;
      all)      jq -s '.' "$findings_file" ;;
      *)        jq -s '.' "$findings_file" ;;
    esac
NEW:     filter="${1:-all}"
    if [[ ! -f "$findings_file" ]]; then
      echo "[]"
      exit 0
    fi
    # Safe read: filter out incomplete trailing lines before parsing
    safe_content=$(grep -a '^{' "$findings_file" || true)
    if [[ -z "$safe_content" ]]; then
      echo "[]"
      exit 0
    fi
    case "$filter" in
      blocking) echo "$safe_content" | jq -s '[.[] | select(.severity == "blocking")]' ;;
      notable)  echo "$safe_content" | jq -s '[.[] | select(.severity == "notable")]' ;;
      all)      echo "$safe_content" | jq -s '.' ;;
      *)        echo "$safe_content" | jq -s '.' ;;
    esac

--- 2026-02-22T18:46:55Z | interverse/interflux/skills/flux-drive/SKILL.md | CONTEXT:unknown ---
OLD: **Interpret the JSON report:**

```json
{
  "status": "ok",
  "agents": [
    {"name": "fd-simulation-kernel", "domain": "game-simulation", "action": "created"},
    {"name": "fd-game-systems", "domain": "game-simulation", "action": "skipped", "reason": "up-to-date (v4)"},
    {"name": "fd-old-agent", "domain": "removed-domain", "action": "orphaned", "reason": "domain 'removed-domain' no longer detected"}
  ]
}
```

**Actions to report:**
- `created`: Log: `"Generated: {name} ({domain})"`
- `skipped`: Silent (agent is current)
- `regenerated`: Log: `"Regenerated: {name} ({reason})"`
- `orphaned`: Log: `"Orphaned: {name} — {reason}. Delete manually if unwanted."`
- `failed`: Log as warning

**Summary line:**
```
Domain agents: N exist, M generated, K orphaned
```
NEW: **Interpret the JSON report:**

```json
{
  "status": "ok",
  "generated": ["fd-simulation-kernel", "fd-agent-narrative"],
  "skipped": ["fd-game-systems"],
  "orphaned": ["fd-old-agent"],
  "errors": []
}
```

**Lists to report:**
- `generated`: Log each: `"Generated: {name}"`
- `skipped`: Silent (agents are current)
- `orphaned`: Log each: `"Orphaned: {name}. Delete manually if unwanted."`
- `errors`: Log as warnings

**Summary line:**
```
Domain agents: N exist, M generated, K orphaned
```

--- 2026-02-22T18:46:56Z | docs/plans/2026-02-22-flux-drive-intermediate-findings.md | CONTEXT:unknown ---
OLD: findings.jsonl
NEW: peer-findings.jsonl

--- 2026-02-22T18:47:03Z | docs/plans/2026-02-22-flux-drive-intermediate-findings.md | CONTEXT:unknown ---
OLD: These are resolved at dispatch time when constructing each agent's prompt.
NEW: These are resolved at dispatch time when constructing each agent's prompt. The orchestrator (flux-drive skill) performs string substitution when building the Task prompt for each agent — replacing `{FINDINGS_HELPER}` with the absolute path `${CLAUDE_PLUGIN_ROOT}/scripts/findings-helper.sh` and `{AGENT_NAME}` with the agent's short name (e.g., `fd-safety`). This follows the same pattern already used for `{OUTPUT_DIR}` and `{REVIEW_FILE}`.

--- 2026-02-22T18:47:16Z | docs/plans/2026-02-22-flux-drive-intermediate-findings.md | CONTEXT:unknown ---
OLD: echo "=== Test 10: Concurrent append simulation ==="
for i in {1..5}; do
  bash "$HELPER" write "$FINDINGS" "notable" "fd-agent-$i" "test-$i" "Concurrent finding $i" &
done
wait
total=$(jq -s 'length' "$FINDINGS")
assert_eq "7 total findings after concurrent writes" "7" "$total"
NEW: echo "=== Test 10: Concurrent append simulation ==="
# Launch 5 concurrent writes, each atomic (< PIPE_BUF)
for i in {1..5}; do
  bash "$HELPER" write "$FINDINGS" "notable" "fd-agent-$i" "test-$i" "Concurrent finding $i" &
done
wait
# Verify all lines are valid JSON (no interleaving corruption)
total=$(grep -c '^{' "$FINDINGS")
assert_eq "7 total findings after concurrent writes" "7" "$total"
invalid=$(grep -v '^{' "$FINDINGS" | grep -v '^$' | wc -l)
assert_eq "no corrupted lines" "0" "$invalid"

--- 2026-02-22T18:47:22Z | interverse/interflux/scripts/generate-agents.py | CONTEXT:unknown ---
OLD:     if report["status"] == "no_domains":
        if args.json_output:
            print(json.dumps(report, indent=2))
        else:
            print("No domains detected. Run detect-domains.py first.", file=sys.stderr)
        return 1
NEW:     if report["status"] == "no_domains":
        if args.json_output:
            print(json.dumps(report, indent=2))
        else:
            for err in report.get("errors", []):
                print(f"Error: {err}", file=sys.stderr)
            print("No domains detected. Run detect-domains.py first.", file=sys.stderr)
        return 1

--- 2026-02-22T18:47:25Z | docs/plans/2026-02-22-flux-drive-intermediate-findings.md | CONTEXT:unknown ---
OLD: ---

## Task 1: Create Finding Schema Helper Script
NEW: ---

## Review Fixes Applied

Flux-drive review (fd-architecture + fd-correctness) found 2 P0 and 7 P1 issues. All addressed:

| Fix | Finding | Change |
|-----|---------|--------|
| P0 atomic write | jq pipe to `>>` is two writes | Capture to variable, single `echo` append |
| P0 safe read | `jq -s` fails on partial trailing line | Filter lines with `grep '^{'` before parsing |
| P1 arg parsing | `filter="${2:-all}"` wrong after shift | Changed to `"${1:-all}"` |
| P1 naming collision | `findings.jsonl` vs `findings.json` | Renamed to `peer-findings.jsonl` |
| P1 template var | No resolution path documented | Added explicit substitution note |
| P1 test reliability | Concurrent test counted with `jq -s` | Count with `grep -c '^{'` + validate no corrupted lines |

---

## Task 1: Create Finding Schema Helper Script

--- 2026-02-22T18:49:59Z | interverse/interflux/skills/flux-drive/phases/launch.md | CONTEXT:unknown ---
OLD: - Include the research result in your finding as "Context: [source] confirms/contradicts..."
```
NEW: - Include the research result in your finding as "Context: [source] confirms/contradicts..."

## Peer Findings Protocol

Other reviewer agents are analyzing this artifact in parallel. You can share and receive high-severity findings via a shared findings file.

**Findings file**: `{OUTPUT_DIR}/peer-findings.jsonl`

### Writing findings (during your analysis)

When you discover a finding that other agents should know about, append it to the findings file. Only share findings at these severity levels:

- **blocking** — contradicts or invalidates another agent's likely analysis (e.g., "this API endpoint doesn't exist", "this data model was removed")
- **notable** — significant finding that may affect other agents' conclusions (e.g., "no authentication on admin endpoints", "critical race condition in shared state")

Do NOT share informational or improvement-level findings — those belong only in your report.

To write a finding, use the Bash tool:
```bash
bash {FINDINGS_HELPER} write "{OUTPUT_DIR}/peer-findings.jsonl" "<severity>" "{AGENT_NAME}" "<category>" "<summary>" "<file_ref1>" "<file_ref2>"
```

Where:
- `<severity>` is `blocking` or `notable`
- `<category>` is a short kebab-case tag (e.g., `api-conflict`, `auth-bypass`, `race-condition`)
- `<summary>` is a 1-2 sentence description
- `<file_ref>` entries are optional `file:line` references

### Reading peer findings (before your final report)

**Before writing your final report**, check for peer findings:

```bash
bash {FINDINGS_HELPER} read "{OUTPUT_DIR}/peer-findings.jsonl"
```

For each finding returned:
- **blocking**: You MUST acknowledge it in your report. If it affects your domain, adjust your analysis accordingly.
- **notable**: Consider whether it changes any of your recommendations. Note it if relevant.

If the findings file doesn't exist or is empty, proceed normally — you may be the first agent to finish.
```

--- 2026-02-22T18:50:06Z | interverse/intersynth/agents/synthesize-review.md | CONTEXT:unknown ---
OLD: - `PROTECTED_PATHS` — file patterns to exclude from findings (e.g., `docs/plans/*.md`)
NEW: - `PROTECTED_PATHS` — file patterns to exclude from findings (e.g., `docs/plans/*.md`)
- `FINDINGS_TIMELINE` — path to `peer-findings.jsonl` (optional; may not exist if no agents wrote findings)

--- 2026-02-22T18:50:10Z | interverse/interflux/skills/flux-drive/phases/launch.md | CONTEXT:unknown ---
OLD: Record all REVIEW_FILE paths for use in prompt construction (Step 2.2).

### Step 2.2: Stage 1 — Launch top agents
NEW: Record all REVIEW_FILE paths for use in prompt construction (Step 2.2).

**Peer findings template variables** (used in the Peer Findings Protocol section of the prompt template):
```
FINDINGS_HELPER = ${CLAUDE_PLUGIN_ROOT}/scripts/findings-helper.sh
AGENT_NAME = <the agent's short name, e.g., fd-safety>
```

The orchestrator performs string substitution when building the Task prompt — replacing `{FINDINGS_HELPER}` with the absolute path and `{AGENT_NAME}` with the agent's short name. Same pattern as `{OUTPUT_DIR}` and `{REVIEW_FILE}`.

### Step 2.2: Stage 1 — Launch top agents

--- 2026-02-22T18:50:16Z | interverse/intersynth/agents/synthesize-review.md | CONTEXT:unknown ---
OLD: ### 4. Write verdicts
NEW: ### 3.5. Read Findings Timeline (optional)

If `FINDINGS_TIMELINE` is provided:

```bash
ls {FINDINGS_TIMELINE} 2>/dev/null
```

If the file exists:
1. Read it — each line is a JSON object with `severity`, `agent`, `category`, `summary`, `file_refs`, `timestamp`
2. Build a timeline of when agents discovered and shared findings
3. Use this in step 6 (Deduplicate) to:
   - Track **convergence via timeline**: if Agent A wrote a blocking finding AND Agent B's report acknowledges it, note "Agent B adjusted based on Agent A's finding" — this is stronger convergence than independent discovery
   - Detect **remaining contradictions**: if Agent A wrote a blocking finding about X but Agent B's report contradicts X without acknowledging the finding, flag this explicitly in the Conflicts section
   - **Attribute discovery**: when deduplicating, the agent that wrote the finding to the timeline first gets discovery credit (`"discovered_by": "agent_name"`)
4. Add a `## Findings Timeline` section to `synthesis.md` output:
   ```markdown
   ## Findings Timeline
   | Time | Agent | Severity | Category | Summary |
   |------|-------|----------|----------|---------|
   [one row per finding, ordered by timestamp]

   **Cross-agent adjustments:** [count] agents adjusted their analysis based on peer findings.
   **Unresolved contradictions:** [count or "None"]
   ```

If the file doesn't exist or is empty, skip this step entirely — synthesis proceeds as before.

### 4. Write verdicts

--- 2026-02-22T18:50:22Z | interverse/interflux/skills/flux-drive/phases/synthesize.md | CONTEXT:unknown ---
OLD:     OUTPUT_DIR={OUTPUT_DIR}
    VERDICT_LIB={CLAUDE_PLUGIN_ROOT}/../../os/clavain/hooks/lib-verdict.sh
    MODE=flux-drive
    CONTEXT="Reviewing {INPUT_TYPE}: {INPUT_STEM} ({N} agents, {early_stop_note})"
NEW:     OUTPUT_DIR={OUTPUT_DIR}
    VERDICT_LIB={CLAUDE_PLUGIN_ROOT}/../../os/clavain/hooks/lib-verdict.sh
    MODE=flux-drive
    CONTEXT="Reviewing {INPUT_TYPE}: {INPUT_STEM} ({N} agents, {early_stop_note})"
    FINDINGS_TIMELINE={OUTPUT_DIR}/peer-findings.jsonl

--- 2026-02-22T18:50:37Z | interverse/interflux/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD:   "commands": [
    "./commands/flux-drive.md",
    "./commands/flux-research.md",
    "./commands/flux-gen.md"
  ],
NEW:   "commands": [
    "./commands/flux-drive.md",
    "./commands/flux-research.md",
    "./commands/flux-gen.md",
    "./commands/fetch-findings.md"
  ],

--- 2026-02-22T18:50:50Z | interverse/interflux/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD: 3 commands, 2 skills, 2 MCP servers
NEW: 4 commands, 2 skills, 2 MCP servers

--- 2026-02-22T18:52:02Z | interverse/interflux/skills/flux-drive/phases/launch.md | CONTEXT:unknown ---
OLD: find {OUTPUT_DIR} -maxdepth 1 -type f \( -name "*.md" -o -name "*.md.partial" \) -delete
NEW: find {OUTPUT_DIR} -maxdepth 1 -type f \( -name "*.md" -o -name "*.md.partial" -o -name "peer-findings.jsonl" \) -delete

--- 2026-02-22T18:52:04Z | interverse/interflux/.claude-plugin/plugin.json | CONTEXT:unknown ---
OLD:   "version": "0.2.19",
  "description": "Multi-agent review and research with scored triage, domain detection, content slicing, and knowledge injection. 17 agents (12 review + 5 research), 4 commands, 2 skills, 2 MCP servers. Companion plugin for Clavain.",
NEW:   "version": "0.2.20",
  "description": "Multi-agent review and research with scored triage, domain detection, content slicing, intermediate finding sharing, and knowledge injection. 17 agents (12 review + 5 research), 4 commands, 2 skills, 2 MCP servers. Companion plugin for Clavain.",

--- 2026-02-22T18:52:05Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD: | Components | 13 agents (8 review + 5 research), 3 commands, 2 skills, 2 MCP servers, 1 hook |
NEW: | Components | 17 agents (12 review + 5 research), 4 commands, 2 skills, 2 MCP servers, 1 hook |

--- 2026-02-22T18:52:07Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD: | `/interflux:flux-gen` | Generate project-specific review agents from detected domains |
NEW: | `/interflux:flux-gen` | Generate project-specific review agents from detected domains |
| `/interflux:fetch-findings` | Inspect shared findings from parallel reviews |

--- 2026-02-22T18:52:13Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD: ## MCP Servers
NEW: ## Intermediate Finding Sharing

During parallel flux-drive reviews, agents can share high-severity findings via `{OUTPUT_DIR}/peer-findings.jsonl`.

**Severity levels:**
- `blocking` — contradicts another agent's analysis (MUST acknowledge)
- `notable` — significant finding that may affect others (SHOULD consider)

**Helper script:** `scripts/findings-helper.sh`
- `write <file> <severity> <agent> <category> <summary> [file_refs...]`
- `read <file> [--severity blocking|notable|all]`

**Timeline in synthesis:** The synthesis agent reads the findings timeline for convergence tracking and contradiction detection.

**Command:** `/interflux:fetch-findings <output_dir> [--severity ...]` — inspect shared findings.

## MCP Servers

--- 2026-02-22T18:53:43Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD: ├── scripts/
│   ├── detect-domains.py          # Domain profile scoring (deterministic)
│   ├── update-domain-profiles.py  # Regenerate domain profiles
│   └── validate-roster.sh        # Validate agent roster consistency
NEW: ├── scripts/
│   ├── detect-domains.py          # Domain heuristic fallback (offline scoring)
│   ├── generate-agents.py         # Deterministic agent file generation from domain profiles
│   ├── update-domain-profiles.py  # Regenerate domain profiles
│   └── validate-roster.sh        # Validate agent roster consistency

--- 2026-02-22T18:53:47Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD:         ├── test_detect_domains.py
NEW:         ├── test_detect_domains.py
        ├── test_generate_agents.py  # 23 tests for agent file generation

--- 2026-02-22T18:53:51Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD:     └── structural/               # 103 pytest tests
NEW:     └── structural/               # 59+ pytest tests

--- 2026-02-22T18:53:59Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD:     └── structural/               # 59+ pytest tests
NEW:     └── structural/               # 120 pytest tests

--- 2026-02-22T18:54:13Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD: ### Domain Detection

Signal-based project classification using 4 signal types:
- **Directory names** (weight 0.3) — `hooks/`, `agents/`, `game/`
- **File patterns** (weight 0.2) — `plugin.json`, `SKILL.md`, `Cargo.toml`
- **Framework keywords** (weight 0.3) — `claude-plugin`, `MCP`, `tokio`
- **Content keywords** (weight 0.2) — `simulation`, `pipeline`, `endpoint`

11 domains defined in `config/flux-drive/domains/`. Each domain profile contains review criteria, agent specs, and Research Directives for external research agents.
NEW: ### Domain Detection

**Primary:** LLM-based classification — a Haiku subagent reads README + build files + key source files and classifies the project into 11 known domains. Cached in `.claude/flux-drive.yaml` with `content_hash` for staleness detection.

**Fallback:** Heuristic scoring via `scripts/detect-domains.py` — signal-based classification using directory names, file patterns, framework keywords, and content keywords. Used when LLM is unavailable.

11 domains defined in `config/flux-drive/domains/`. Each domain profile contains review criteria, agent specs, and Research Directives for external research agents.

### Agent Generation

`scripts/generate-agents.py` reads cached domain classification + domain profile markdown → writes `.claude/agents/fd-*.md` files. Deterministic template expansion (no LLM involvement). Three modes: `skip-existing`, `regenerate-stale` (checks `flux_gen_version` in frontmatter), `force`.

--- 2026-02-22T18:55:32Z | interverse/interflux/skills/flux-drive/SKILL.md | CONTEXT:unknown ---
OLD: **Heuristic fallback** (when Haiku call fails — timeout, API error, or unparseable response):

Run the legacy heuristic detector:
```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --json
```
- Exit 0: use output, mark `source: heuristic` in cache
- Exit 1: no domains detected, proceed with core agents only
- Exit 2: script error, proceed with core agents only

Log: `"Domain detection: LLM unavailable, using heuristic fallback."`

**Performance budget:** Detection should complete in <5 seconds. Cache check is <10ms.
NEW: **If Haiku call fails** (timeout, API error, or unparseable response): proceed with core agents only (no domain-specific agents). Log: `"Domain detection: LLM unavailable, proceeding with core agents only."`

**Performance budget:** Detection should complete in <5 seconds. Cache check is <10ms.

--- 2026-02-22T18:55:36Z | interverse/interflux/skills/flux-drive/SKILL-compact.md | CONTEXT:unknown ---
OLD: **Fallback:** If Haiku fails: `python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --json`. Mark `source: heuristic`.
NEW: **If Haiku fails:** Proceed with core agents only (no domain-specific agents).

--- 2026-02-22T18:55:39Z | interverse/interflux/commands/flux-gen.md | CONTEXT:unknown ---
OLD: **Detection** (no cache, stale cache, or `source: heuristic`):

Use the same LLM-based detection as flux-drive. Launch a Haiku subagent (Task tool, `model: haiku`) that reads README + build file + 2-3 key source files and classifies into 11 known domains. Cache the result with `source: llm` and `content_hash`.

**Heuristic fallback** (if Haiku fails):
```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py {PROJECT_ROOT} --json
```
Mark `source: heuristic` in cache.
NEW: **Detection** (no cache or stale cache):

Use the same LLM-based detection as flux-drive. Launch a Haiku subagent (Task tool, `model: haiku`) that reads README + build file + 2-3 key source files and classifies into 11 known domains. Cache the result with `source: llm` and `content_hash`.

**If Haiku fails:** Tell the user domain detection is unavailable and offer to retry or specify a domain manually.

--- 2026-02-22T18:55:41Z | interverse/interflux/scripts/generate-agents.py | CONTEXT:unknown ---
OLD:             print("No domains detected. Run detect-domains.py first.", file=sys.stderr)
NEW:             print("No domains detected. Run LLM domain detection first (flux-drive Step 1.0.1).", file=sys.stderr)

--- 2026-02-22T18:55:51Z | interverse/interflux/skills/flux-research/SKILL.md | CONTEXT:unknown ---
OLD: Check for domain context that can sharpen research queries:

```bash
python3 ${CLAUDE_PLUGIN_ROOT}/scripts/detect-domains.py --check-stale 2>/dev/null || true
```

If a `{PROJECT_ROOT}/.claude/flux-drive.yaml` cache exists, read the detected domains. For each detected domain, load `${CLAUDE_PLUGIN_ROOT}/config/flux-drive/domains/{domain-name}.md` and extract the `## Research Directives` section (if present).

**Fallback**: If no domains detected or no Research Directives sections exist, skip domain injection — agents run with the raw query only.
NEW: Check for domain context that can sharpen research queries:

If a `{PROJECT_ROOT}/.claude/flux-drive.yaml` cache exists, read the detected domains. For each detected domain, load `${CLAUDE_PLUGIN_ROOT}/config/flux-drive/domains/{domain-name}.md` and extract the `## Research Directives` section (if present).

If no cache exists, run flux-drive's LLM domain detection (Step 1.0.1 in flux-drive SKILL.md) to populate it.

**Fallback**: If no domains detected or no Research Directives sections exist, skip domain injection — agents run with the raw query only.

--- 2026-02-22T18:55:56Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD: │   ├── detect-domains.py          # Domain heuristic fallback (offline scoring)
│   ├── generate-agents.py         # Deterministic agent file generation from domain profiles
NEW: │   ├── content-hash.py            # Deterministic content hash for cache staleness
│   ├── generate-agents.py         # Deterministic agent file generation from domain profiles

--- 2026-02-22T18:56:02Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD: **Primary:** LLM-based classification — a Haiku subagent reads README + build files + key source files and classifies the project into 11 known domains. Cached in `.claude/flux-drive.yaml` with `content_hash` for staleness detection.

**Fallback:** Heuristic scoring via `scripts/detect-domains.py` — signal-based classification using directory names, file patterns, framework keywords, and content keywords. Used when LLM is unavailable.
NEW: LLM-based classification — a Haiku subagent reads README + build files + key source files and classifies the project into 11 known domains. Cached in `.claude/flux-drive.yaml` with `content_hash` for staleness detection. Staleness computed deterministically by `scripts/content-hash.py`.

--- 2026-02-22T18:56:07Z | interverse/interflux/AGENTS.md | CONTEXT:unknown ---
OLD:         ├── test_detect_domains.py
        ├── test_generate_agents.py  # 23 tests for agent file generation
NEW:         ├── test_content_hash.py       # Tests for content hash helper
        ├── test_generate_agents.py  # 23 tests for agent file generation

--- 2026-02-22T18:56:23Z | interverse/interflux/skills/flux-drive/SKILL.md | CONTEXT:unknown ---
OLD: ### Step 1.0.2: Check Staleness

Check if cached domain detection is outdated by comparing content hashes.

1. Read `content_hash` from `{PROJECT_ROOT}/.claude/flux-drive.yaml`
2. If no `content_hash` field (old cache format or heuristic source): cache is stale, proceed to Step 1.0.3
3. Re-hash the same files (README + build file + key source files) using SHA-256
4. If hashes match: cache is fresh, proceed to Step 1.1
5. If hashes differ: cache is stale, proceed to Step 1.0.3
NEW: ### Step 1.0.2: Check Staleness

Check if cached domain detection is outdated using the deterministic content hash helper.

1. Read `content_hash` from `{PROJECT_ROOT}/.claude/flux-drive.yaml`
2. If no `content_hash` field (old cache format): cache is stale, proceed to Step 1.0.3
3. Run the hash helper to compare:
   ```bash
   python3 ${CLAUDE_PLUGIN_ROOT}/scripts/content-hash.py {PROJECT_ROOT} --check <cached_hash>
   ```
   - Exit 0: cache is fresh, proceed to Step 1.1
   - Exit 1: cache is stale (hash mismatch or no hashable files), proceed to Step 1.0.3
   - Exit 2: script error, treat as stale, proceed to Step 1.0.3

--- 2026-02-22T18:56:34Z | interverse/interflux/skills/flux-drive/SKILL.md | CONTEXT:unknown ---
OLD: 3. Parse the JSON response. Write cache to `{PROJECT_ROOT}/.claude/flux-drive.yaml`:
   ```yaml
   cache_version: 2
   source: llm
   detected_at: '2026-02-22T12:00:00+00:00'
   content_hash: 'sha256:<hash of files read by LLM>'
   domains:
NEW: 3. Parse the JSON response. Compute content hash:
   ```bash
   python3 ${CLAUDE_PLUGIN_ROOT}/scripts/content-hash.py {PROJECT_ROOT}
   ```
   Write cache to `{PROJECT_ROOT}/.claude/flux-drive.yaml`:
   ```yaml
   cache_version: 2
   source: llm
   detected_at: '2026-02-22T12:00:00+00:00'
   content_hash: '<output from content-hash.py>'
   domains:

--- 2026-02-22T18:56:39Z | interverse/interflux/skills/flux-drive/SKILL-compact.md | CONTEXT:unknown ---
OLD: **Staleness:** Compare `content_hash` in cache vs current file hashes. No hash or mismatch → stale (re-detect). Match → fresh.
NEW: **Staleness:** `python3 ${CLAUDE_PLUGIN_ROOT}/scripts/content-hash.py {PROJECT_ROOT} --check <cached_hash>`. Exit 0 → fresh. Exit 1 → stale (re-detect).

--- 2026-02-22T18:56:47Z | interverse/interflux/skills/flux-drive/SKILL-compact.md | CONTEXT:unknown ---
OLD: **Detection:** Launch Haiku subagent (Task tool, `model: haiku`) with README + build file + 2-3 key source files. Prompt asks for `{"domains": [{"name", "confidence", "reasoning"}]}` from 11 known domains. Cache result with `source: llm` and `content_hash`.
NEW: **Detection:** Launch Haiku subagent (Task tool, `model: haiku`) with README + build file + 2-3 key source files. Prompt asks for `{"domains": [{"name", "confidence", "reasoning"}]}` from 11 known domains. Compute hash: `python3 ${CLAUDE_PLUGIN_ROOT}/scripts/content-hash.py {PROJECT_ROOT}`. Cache result with `source: llm` and `content_hash`.

--- 2026-02-22T18:57:13Z | interverse/interflux/tests/structural/test_content_hash.py | CONTEXT:unknown ---
OLD:     project = tmp_path / "project"
    project.mkdir()
NEW:     project = tmp_path / "project"
    project.mkdir(parents=True)

--- 2026-02-22T18:57:46Z | interverse/interflux/scripts/generate-agents.py | CONTEXT:unknown ---
OLD: def parse_agent_specs(profile_path: Path, domain: str) -> list[dict[str, Any]]:
    """Extract agent specifications from a domain profile markdown file.

    Parses the ``## Agent Specifications`` section. Each ``### fd-*``
    subsection contains Focus, Persona, Decision lens, Key review areas,
    and optionally Success criteria hints.

    Returns a list of spec dicts, each with keys:
        name, domain, focus, persona, decision_lens,
        review_areas (list[str]), success_hints (list[str])
    """
    text = profile_path.read_text(encoding="utf-8")

    # Find the Agent Specifications section
    agent_section_match = re.search(
        r"^## Agent Specifications\s*\n(.*?)(?=^## |\Z)",
        text,
        re.MULTILINE | re.DOTALL,
    )
    if not agent_section_match:
        return []

    section_text = agent_section_match.group(1)

    # Split into individual agent subsections by ### fd-*
    agent_blocks = re.split(r"^### (fd-[\w-]+)\s*$", section_text, flags=re.MULTILINE)
    # agent_blocks[0] is the preamble text before the first ### fd-*
    # Then alternating: name, content, name, content, ...

    specs: list[dict[str, Any]] = []
    i = 1
    while i < len(agent_blocks) - 1:
        name = agent_blocks[i].strip()
        content = agent_blocks[i + 1]
        i += 2

        # Skip core agents
        if name in CORE_AGENTS:
            continue

        spec = _parse_single_agent(content, name, domain)
        specs.append(spec)

    return specs
NEW: def parse_agent_specs(profile_path: Path, domain: str) -> list[dict[str, Any]]:
    """Extract agent specifications from a domain profile markdown file.

    Parses the ``## Agent Specifications`` section. Each ``### fd-*``
    subsection contains Focus, Persona, Decision lens, Key review areas,
    and optionally Success criteria hints.

    Returns a list of spec dicts, each with keys:
        name, domain, focus, persona, decision_lens,
        review_areas (list[str]), success_hints (list[str])
    """
    text = profile_path.read_text(encoding="utf-8")

    # Strip fenced code blocks to avoid matching headings inside them
    text_no_code = re.sub(r"```.*?```", "", text, flags=re.DOTALL)

    # Find the Agent Specifications section (tolerant of trailing whitespace)
    agent_section_match = re.search(
        r"^## Agent Specifications[ \t]*\n(.*?)(?=^## |\Z)",
        text_no_code,
        re.MULTILINE | re.DOTALL,
    )
    if not agent_section_match:
        return []

    section_text = agent_section_match.group(1)

    # Split into individual agent subsections by ### fd-*
    # Tolerant of trailing whitespace on heading lines
    agent_blocks = re.split(r"^### (fd-[\w-]+)[ \t]*$", section_text, flags=re.MULTILINE)
    # agent_blocks[0] is the preamble text before the first ### fd-*
    # Then alternating: name, content, name, content, ...

    specs: list[dict[str, Any]] = []
    i = 1
    while i < len(agent_blocks) - 1:
        name = agent_blocks[i].strip()
        content = agent_blocks[i + 1]
        i += 2

        # Skip core agents
        if name in CORE_AGENTS:
            continue

        spec = _parse_single_agent(content, name, domain)
        if not spec.get("focus"):
            # Warn but still include — allows manual fixing
            print(
                f"Warning: {profile_path.name}: agent {name} has no Focus line",
                file=sys.stderr,
            )
        specs.append(spec)

    return specs

--- 2026-02-22T18:58:01Z | interverse/interflux/scripts/generate-agents.py | CONTEXT:unknown ---
OLD: def _parse_single_agent(content: str, name: str, domain: str) -> dict[str, Any]:
    """Parse a single agent subsection content into a spec dict."""
    # Extract Focus line
    focus_match = re.search(r"^Focus:\s*(.+)$", content, re.MULTILINE)
    focus = focus_match.group(1).strip() if focus_match else ""

    # Extract Persona line
    persona_match = re.search(r"^Persona:\s*(.+)$", content, re.MULTILINE)
    persona = persona_match.group(1).strip() if persona_match else None

    # Extract Decision lens line
    lens_match = re.search(r"^Decision lens:\s*(.+)$", content, re.MULTILINE)
    decision_lens = lens_match.group(1).strip() if lens_match else None

    # Extract Key review areas (bullet list)
    review_areas: list[str] = []
    review_match = re.search(
        r"^Key review areas:\s*\n((?:- .+\n?)+)",
        content,
        re.MULTILINE,
    )
    if review_match:
        for line in review_match.group(1).strip().splitlines():
            line = line.strip()
            if line.startswith("- "):
                review_areas.append(line[2:].strip())

    # Extract Success criteria hints (optional bullet list)
    success_hints: list[str] = []
    hints_match = re.search(
        r"^Success criteria hints:\s*\n((?:- .+\n?)+)",
        content,
        re.MULTILINE,
    )
    if hints_match:
        for line in hints_match.group(1).strip().splitlines():
            line = line.strip()
            if line.startswith("- "):
                success_hints.append(line[2:].strip())

    return {
        "name": name,
        "domain": domain,
        "focus": focus,
        "persona": persona,
        "decision_lens": decision_lens,
        "review_areas": review_areas,
        "success_hints": success_hints,
    }
NEW: def _extract_field(content: str, field_name: str) -> str | None:
    """Extract a single-line field value, tolerant of bold/italic formatting.

    Matches: ``Focus: value``, ``**Focus:** value``, ``*Focus:* value``
    """
    pattern = rf"^\**{re.escape(field_name)}:?\**:?\s*(.+)$"
    match = re.search(pattern, content, re.MULTILINE)
    return match.group(1).strip() if match else None


def _extract_bullet_list(content: str, field_name: str) -> list[str]:
    """Extract a bullet list following a field label.

    Tolerates both ``- `` and ``* `` bullet markers, and optional
    bold/italic on the field label.
    """
    pattern = rf"^\**{re.escape(field_name)}:?\**:?\s*\n((?:[\-\*] .+\n?)+)"
    match = re.search(pattern, content, re.MULTILINE)
    if not match:
        return []
    items: list[str] = []
    for line in match.group(1).strip().splitlines():
        line = line.strip()
        if line.startswith(("- ", "* ")):
            items.append(line[2:].strip())
    return items


def _parse_single_agent(content: str, name: str, domain: str) -> dict[str, Any]:
    """Parse a single agent subsection content into a spec dict."""
    return {
        "name": name,
        "domain": domain,
        "focus": _extract_field(content, "Focus") or "",
        "persona": _extract_field(content, "Persona"),
        "decision_lens": _extract_field(content, "Decision lens"),
        "review_areas": _extract_bullet_list(content, "Key review areas"),
        "success_hints": _extract_bullet_list(content, "Success criteria hints"),
    }

--- 2026-02-22T18:58:09Z | interverse/interflux/scripts/generate-agents.py | CONTEXT:unknown ---
OLD: def _parse_frontmatter(path: Path) -> dict[str, Any] | None:
    """Parse YAML frontmatter from a markdown file.

    Returns the parsed dict, or None if no valid frontmatter found.
    """
    try:
        text = path.read_text(encoding="utf-8")
    except OSError:
        return None

    if not text.startswith("---"):
        return None

    end = text.find("---", 3)
    if end == -1:
        return None

    try:
        return yaml.safe_load(text[3:end])
    except yaml.YAMLError:
        return None
NEW: def _parse_frontmatter(path: Path) -> dict[str, Any] | None:
    """Parse YAML frontmatter from a markdown file.

    Returns the parsed dict, or None if no valid frontmatter found.
    Tolerates leading whitespace/BOM and requires the closing --- on its own line.
    """
    try:
        text = path.read_text(encoding="utf-8")
    except OSError:
        return None

    # Strip BOM if present
    text = text.lstrip("\ufeff")

    if not text.startswith("---"):
        return None

    # Find closing --- that starts on its own line
    end = text.find("\n---", 3)
    if end == -1:
        return None

    try:
        data = yaml.safe_load(text[3:end])
        if not isinstance(data, dict):
            return None
        return data
    except yaml.YAMLError:
        return None

--- 2026-02-22T18:58:47Z | interverse/interflux/tests/structural/test_agents.py | CONTEXT:unknown ---
OLD:     assert len(agent_files) == 13, (
        f"Expected 13 agents, found {len(agent_files)}: "
        f"{[f.stem for f in agent_files]}"
    )
NEW:     assert len(agent_files) == 17, (
        f"Expected 17 agents, found {len(agent_files)}: "
        f"{[f.stem for f in agent_files]}"
    )

--- 2026-02-22T18:58:50Z | interverse/interflux/tests/structural/test_commands.py | CONTEXT:unknown ---
OLD:     assert len(files) == 3, (
        f"Expected 3 commands, found {len(files)}: {[f.stem for f in files]}"
    )
NEW:     assert len(files) == 4, (
        f"Expected 4 commands, found {len(files)}: {[f.stem for f in files]}"
    )

--- 2026-02-22T19:29:34Z | README.md | CONTEXT:unknown ---
OLD: ## Hub

| Module | Version | Description |
|--------|---------|-------------|
| [Autarch](https://github.com/mistakeknot/Autarch) | n/a | AI agent development tools suite (Bigend, Gurgeh, Coldwine, Pollard) |
| [Clavain](https://github.com/mistakeknot/Clavain) | 0.6.39 | Self-improving agent rig — product and engineering discipline from brainstorm to ship. Core of the ecosystem. |
NEW: ## Hub

| Module | Version | Description |
|--------|---------|-------------|
| [Autarch](https://github.com/mistakeknot/Autarch) | n/a | AI agent development tools suite (Bigend, Gurgeh, Coldwine, Pollard) |
| [Clavain](https://github.com/mistakeknot/Clavain) | 0.6.39 | Self-improving agent rig — product and engineering discipline from brainstorm to ship. Core of the ecosystem. |
| [Intercom](https://github.com/mistakeknot/Intercom) | 1.0.0 | Multi-runtime personal AI assistant — Claude, Gemini, Codex backends with container isolation (Telegram/WhatsApp) |
