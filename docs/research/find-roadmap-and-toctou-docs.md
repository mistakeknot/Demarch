---
title: "Search Results: Roadmap Files, TOCTOU Documentation, and Kernel Architecture"
date: 2026-02-20
scope: /root/projects/Interverse
---

# Interverse Codebase Search Results

## Executive Summary

This document consolidates findings from a comprehensive search of the Interverse monorepo for:
1. Existing roadmap files (roadmap.md, ROADMAP.md, roadmap.json)
2. TOCTOU-related documentation and analysis
3. Intercore kernel schema and architecture docs
4. Dispatch/merge systems in intermute and intercore

**Key finding:** The codebase has extensive roadmap generation infrastructure, two detailed TOCTOU analyses, comprehensive kernel documentation in AGENTS.md format, and event-driven dispatch systems.

---

## 1. Roadmap Files (23 files found)

### Monorepo-Level Roadmaps

| Path | Type | Status | Notes |
|------|------|--------|-------|
| `/root/projects/Interverse/docs/roadmap.json` | JSON | Canonical | Machine-readable roadmap (likely auto-generated) |
| `/root/projects/Interverse/hub/autarch/docs/bigend/roadmap.md` | Markdown | Human-readable | Bigend TUI module roadmap |
| `/root/projects/Interverse/hub/autarch/docs/gurgeh/roadmap.md` | Markdown | Human-readable | Gurgeh module roadmap |

### Plugin-Specific Roadmaps (16 JSON files)

All plugins under `/root/projects/Interverse/plugins/` have auto-generated `docs/roadmap.json`:
- interject, interphase, intersearch, interwatch, interpath, interserve, intercheck, interdoc
- interstat, internext, intercraft, interfluence, intermux, interpub, interlens, interline, interslack
- tuivision, interform, interdev

These are auto-generated by the `/interpath:roadmap` skill (artifact generator) from beads, brainstorms, and PRDs.

### Skill-Level Roadmaps

- `/root/projects/Interverse/plugins/interleave/examples/roadmap-walkthrough.md` — Example roadmap
- `/root/projects/Interverse/plugins/interpath/commands/roadmap.md` — Command documentation
- `/root/projects/Interverse/plugins/interpath/skills/artifact-gen/phases/roadmap.md` — Skill phase description (100 lines)
- `/root/projects/Interverse/plugins/interpath/skills/artifact-gen/phases/roadmap-monorepo.md` — Monorepo variant

### Roadmap Generation Infrastructure

**Location:** `/root/projects/Interverse/plugins/interpath/`
**Type:** Claude Code plugin (companion to Clavain)
**Artifact types:** roadmaps, PRDs, vision docs, changelogs, status reports

**Key characteristics:**
- Single skill (`artifact-gen`) with phase-based routing
- Generates human-readable `.md` + machine-readable `.json` pairs
- Sources: beads state, brainstorms, PRDs, project context
- Output: `/docs/{module}-roadmap.md` and `/docs/roadmap.json`
- Graceful degradation — missing sources silently skipped
- No hooks — on-demand invocation only

**Interpath Skill Structure:**
```
plugins/interpath/
├── skills/artifact-gen/
│   ├── SKILL.md (main)
│   └── phases/
│       ├── discovery.md (find brainstorms, PRDs, beads)
│       ├── synthesis.md (organize by priority)
│       ├── roadmap.md (output format)
│       └── roadmap-monorepo.md (multi-project variant)
├── commands/
│   ├── roadmap.md
│   ├── prd.md
│   ├── vision.md
│   └── ... (6 total)
└── .claude-plugin/
    └── plugin.json
```

**Usage:**
```bash
/interpath:roadmap           # Regenerate current project roadmap
/interpath:roadmap --force   # Force refresh all artifacts
```

---

## 2. TOCTOU-Related Documentation (2 detailed analyses found)

### 2.1 Advisory-Only Timeout Pattern (2026-02-16)

**Location:** `/root/projects/Interverse/plugins/interlock/docs/solutions/2026-02-16-advisory-only-timeout-eliminates-toctou.md`

**Problem statement:**
A multi-agent file coordination system had a background goroutine that force-released reservations on timeout. This caused four P0 bugs:

1. **TOCTOU Race:** Timeout checker reads reservation state, decides to force-release, issues DELETE. Between read and DELETE, holder re-acquires reservation. Result: holder has fresh reservation but message bus has stale release-ack.

2. **Non-idempotent DELETE:** `ReleaseByPattern` iterated active reservations and called DELETE for each. Concurrent releases caused 404 errors on the second DELETE.

3. **Consent violation:** Background goroutine auto-released without holder consent, breaking coordination invariant.

4. **Goroutine leak:** `sync.Once` spawned goroutine that never stopped (no context cancellation, no lifecycle management).

**Root cause:** Background process writes to shared mutable state (reservations, message bus) based on stale reads. The gap between "read state" and "mutate state" is inherently racy.

**Solution (Pattern 1: Advisory-Only Enforcement):**
- Convert timeout checker from state-mutating actor to read-only observer
- Remove `ReleaseByPattern` call from `CheckExpiredNegotiations`
- Return `Released: 0` in timeout structs (informational only)
- Requester agent decides whether to act (explicit `respond_to_release` tool call)

**Solution (Pattern 2: Idempotent DELETE):**
```go
if err := c.DeleteReservation(ctx, r.ID); err != nil {
    if !isNotFound(err) {
        return released, fmt.Errorf("delete reservation %q: %w", r.ID, err)
    }
    // 404 = already deleted by another goroutine/session, count as success.
}
released++
```

**Key insight:** Read-only code cannot race. By making timeout checks purely advisory (no writes), the number of interleaving hazards drops to zero. The holder retains full control of its reservations.

**Applies to:** interlock (file coordination), intermute (dispatch coordination)

---

### 2.2 Portfolio Dependency Scheduling (E9 Sprint, 2026-02-20)

**Location:** `/root/projects/Interverse/infra/intercore/docs/solutions/e9-portfolio-dependency-scheduling-learnings.md`

**Bead:** iv-wp62
**Sprint:** E9
**Severity:** High

**What was built:**
- Cycle detection in `DepStore.Add()` via DFS reachability
- Gate integration — `CheckUpstreamsAtPhase` blocks downstream child runs when upstream dependencies haven't reached target phase
- Topological sort using Kahn's algorithm
- Portfolio status CLI command showing per-child readiness with blocked-by details
- Integration tests covering deps, cycles, gates, topo order

**Pattern 1: TOCTOU Race in Check-Then-Insert with SQLite (Critical Fix)**

**Problem:** `HasPath()` (reads graph) and `INSERT` (writes) were separate DB operations. Two concurrent `Add()` calls could both pass cycle check, then both INSERT, creating a cycle.

**Fix:** Wrap both in `BeginTx` transaction. Introduced `queryCtx` interface to let DFS work with `*sql.DB` or `*sql.Tx`:

```go
type queryCtx interface {
    QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
    ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
}
```

**Lesson:** Any read-then-write pattern in SQLite needs a transaction, even with `SetMaxOpenConns(1)`. Go's connection pool serializes at connection level, not logical operation level.

**Pattern 2: Terminal Status Exhaustiveness**

**Problem:** `CheckUpstreamsAtPhase` only exempted `StatusCompleted` upstreams. Cancelled/failed upstreams would block downstream forever.

**Fix:** Exempt all terminal states: `StatusCompleted`, `StatusCancelled`, `StatusFailed`.

**Pattern 3: Map Collision in Lookup Construction**

**Problem:** `siblingByProject` map used last-write-wins on duplicate `project_dir`. Silent data loss worse than loud failure.

**Fix:** First-write-wins with `if _, exists := m[key]; !exists` guard.

**Pattern 4: Interface Injection for Gate Extension**

4th querier interface added (`DepQuerier`). Concern: `Advance()` signature now has 9 parameters. If 5th gate type is needed, consider `GateContext` struct.

**Pattern 5: Integration Test Gotcha — Multi-Line CLI Output**

`ic run create --projects=A,B` outputs portfolio run ID on line 1, child run IDs on subsequent lines. Capture with `| head -1`.

**Pattern 6: Gate Interaction**

All applicable gate rules fire together, not just the one being tested. Integration tests must satisfy all gates.

**Complexity:** Estimated C3 (moderate). Actual C3. Scope well-bounded (6 tasks), but correctness review caught 3 real issues adding ~30% effort.

---

## 3. Intercore Kernel Documentation

### 3.1 AGENTS.md (Comprehensive 547 lines)

**Location:** `/root/projects/Interverse/infra/intercore/AGENTS.md`

**Key sections:**

#### Architecture Overview
```
cmd/ic/main.go              CLI entry point
cmd/ic/dispatch.go          Dispatch subcommands
cmd/ic/run.go               Run subcommands
cmd/ic/gate.go              Gate subcommands
cmd/ic/portfolio.go         Portfolio subcommands
cmd/ic/lock.go              Lock subcommands
internal/db/db.go           SQLite connection, migration
internal/db/schema.sql      Embedded DDL
internal/state/             State CRUD with JSON validation, TTL
internal/sentinel/          Atomic throttle guards with UPDATE+RETURNING
internal/dispatch/          Agent dispatch lifecycle
internal/phase/             Phase state machine
internal/portfolio/         Portfolio orchestration
internal/budget/            Token budget threshold checking
internal/lock/              Filesystem-based mutex
internal/event/             Event bus
internal/runtrack/          Agent/artifact tracking
lib-intercore.sh            Bash wrappers (v0.6.0)
test-integration.sh         ~105 integration tests
```

#### Database Schema (v10)

Tables:
- `state` — Key-value store with TTL
- `sentinels` — Throttle guards
- `dispatches` — Agent dispatch lifecycle
- `runs` — Sprint runs
- `phase_events` — Phase transitions
- `dispatch_events` — Status changes
- `run_agents` — Agents within a run
- `run_artifacts` — Files produced during run
- `project_deps` — Cross-project dependencies

#### Dispatch Module

Lifecycle:
```
ic dispatch spawn  → INSERT (status=spawned) → fork dispatch.sh → UPDATE (status=running, pid)
ic dispatch poll   → kill(pid,0) liveness → read state file → UPDATE stats
ic dispatch wait   → poll loop → on timeout: SIGTERM/SIGKILL → status=timeout
ic dispatch collect → read .verdict + .summary sidecars → UPDATE final results
```

State flow: `spawned → running → completed | failed | timeout | cancelled`

#### Run Tracking Module (v4)

Agent and artifact tracking within runs.

Agent status flow: `active → completed | failed`

#### Lock Module (Filesystem-only)

Process-level mutual exclusion using POSIX `mkdir` atomicity. No SQLite involved. Separates concerns: SQLite sentinels handle time-based throttles; filesystem locks handle read-modify-write serialization.

Lock directory: `/tmp/intercore/locks/<name>/<scope>/owner.json`

Acquire behavior:
1. `os.Mkdir` atomic attempt (fail = lock held)
2. Write `owner.json` with caller identity
3. Spin-wait on failure with 100ms sleep
4. Stale detection: compare created timestamp against `StaleAge` (5s default)
5. Stale-break: `os.Remove(owner.json)` + `os.Remove(lockDir)`

PID-liveness check: `syscall.Kill(pid, 0)` before evicting

#### Phase Module (State Machine)

Configurable phase chains (v6). Default 9-phase Clavain lifecycle:
```
brainstorm → brainstorm-reviewed → strategized → planned → executing → review → polish → reflect → done
```

Custom chains via `--phases='["a","b","c"]'` at creation (min 2 phases, no duplicates).

Phase skip via `ic run skip <id> <phase>`.

**Gate system:**
- `artifact_exists` — requires artifact for source phase
- `agents_complete` — no active agents
- `verdict_exists` — non-rejected dispatch verdict
- `children_at_phase` — (portfolio) all active children at/past target phase
- `upstreams_at_phase` — (child with deps) upstream projects reached target phase

Gate tiers by priority:
- 0-1: Hard (block)
- 2-3: Soft (warn, allow)
- 4+: None (skip)

#### Event Bus Module (v5)

Reactive notification of phase transitions and dispatch status changes.

Architecture:
```
phase.Advance() → PhaseEventCallback → Notifier.Notify() → handlers
dispatch.UpdateStatus() → DispatchEventRecorder → Notifier.Notify() → handlers
```

Callbacks fire **after DB commit** (fire-and-forget). Handler errors logged but never fail parent operation.

Handlers:
- LogHandler — logs to stderr; quiet mode suppresses
- HookHandler — executes `.clavain/hooks/on-event.sh` with event JSON on stdin; async goroutine with 5s timeout
- SpawnHandler — auto-spawns pending agents on phase transitions

Dual cursors (separate high-water marks for phase and dispatch events, independent AUTOINCREMENT sequences). Cursors persisted in state table with 24h TTL.

#### Portfolio Orchestration Module (v10)

Cross-project coordination through parent/child run hierarchies, project dependencies, event relay.

Portfolio run: `project_dir = ""` with children linked via `parent_run_id`

Project dependencies: Directed edges between child projects. Validation: no self-loops, no cycles (via DFS reachability check `HasPath`).

Event relay: `ic portfolio relay <id>` polls child DBs (read-only `?mode=ro`), queries `phase_events` since last cursor, inserts relay events into portfolio `phase_events`, persists cursors atomically.

Portfolio gates: All active children must reach phase P (or later) before portfolio advances. Completed/cancelled children don't block. Failed children DO block.

Dispatch budget: `max_dispatches` limits concurrent agent dispatches across all children. Relay maintains `active-dispatch-count` in state table. Advisory (TOCTOU-vulnerable).

#### Security

Path traversal protection: `--db` flag validated (`.db` extension, no `..`, under CWD, no parent symlinks).

JSON payload validation: max 1MB, nesting depth 20, key length 1000, string values 100KB, array length 10,000.

#### SQLite Patterns

- `SetMaxOpenConns(1)` — single writer for WAL mode correctness
- PRAGMAs set explicitly after `sql.Open` (DSN `_pragma` unreliable)
- `busy_timeout` set to prevent immediate SQLITE_BUSY
- **No CTE + UPDATE RETURNING** — modernc.org/sqlite limitation

Transaction isolation:
| Operation | Isolation | Rationale |
|-----------|-----------|-----------|
| state set | Transaction | Write with REPLACE |
| sentinel check | Transaction | Atomic claim + auto-prune |
| dep add | Transaction | Cycle check + INSERT atomicity (TOCTOU prevention) |
| dispatch create | No transaction | Single INSERT |
| dispatch update | Transaction | Capture prev status + UPDATE + commit before event |

---

### 3.2 Event Reactor Pattern (265 lines)

**Location:** `/root/projects/Interverse/infra/intercore/docs/event-reactor-pattern.md`

**Concept:** Long-running process consuming kernel events via `ic events tail -f` and dispatching actions in response. Kernel is stateless — writes events to SQLite but never acts on them. Reactors are OS components that subscribe and decide.

**Consumer registration:** `--consumer=<name>` gives durable cursor (persists, survives restarts). Cursors have 24h TTL.

**Event schema:**
```json
{
  "id": 42,
  "run_id": "run-abc123",
  "source": "phase",
  "type": "advance",
  "from_state": "planned",
  "to_state": "executing",
  "reason": "",
  "timestamp": "2026-02-19T12:00:00Z"
}
```

**Event types by source:**
- Phase: `advance`, `skip`, `block`, `pause`
- Dispatch: `status_change`
- Budget: `budget.warning`, `budget.exceeded`

**Common patterns:**
1. Phase-triggered agent spawning
2. Dispatch completion → phase advance
3. Budget alerting
4. Agent state inspection

**Idempotency:** At-least-once delivery. Reactors MUST be idempotent. Before acting, check current state via `ic run phase`, `ic dispatch list`, etc.

**Lifecycle management:** Systemd (production), bash background process (dev), Clavain session hook (per-session).

**Design guidelines:**
1. One reactor per concern
2. Prefer polling over tight loops
3. Kernel is source of truth — don't cache state
4. Log actions
5. Fail open, not closed

---

### 3.3 Schema Upgrade Deployment Pattern (70 lines)

**Location:** `/root/projects/Interverse/docs/solutions/patterns/intercore-schema-upgrade-deployment-20260218.md`

**Problem:** Live binary doesn't pick up schema changes automatically. Schema DDL is embedded in Go binary via `//go:embed schema.sql`.

**Solution: 3-step sequence**
```bash
# 1. Rebuild binary (schema.sql is //go:embed'd)
cd /root/projects/Interverse/infra/intercore
go build -o /home/mk/go/bin/ic ./cmd/ic

# 2. Migrate live DB
cd /root/projects/Interverse
ic init   # Creates backup automatically

# 3. Verify
ic version
```

**Why it works:** Migration is additive-only using `CREATE TABLE IF NOT EXISTS`. All tables use `IF NOT EXISTS`, so re-applying full DDL on existing DB safely creates only new tables. `PRAGMA user_version` bumped inside transaction.

**Key gotcha:** Schema version constant and DDL travel together in binary. Must rebuild installed binary before running `ic init`.

**Pattern limitation:** Breaks for destructive changes (ALTER TABLE, column renames, data migrations).

---

## 4. Dispatch Systems

### 4.1 Intercore Dispatch Module

**File:** `/root/projects/Interverse/infra/intercore/internal/dispatch/`

**Components:**
- `dispatch.go` — Store (CRUD), Dispatch struct, ID generation
- `spawn.go` — Process spawning, dispatch.sh resolution, prompt hashing
- `collect.go` — Liveness polling, verdict/summary parsing, wait loop
- `dispatch_test.go` — Unit tests

**Lifecycle tracked in SQLite:**
- `ic dispatch spawn` — INSERT record, fork dispatch.sh
- `ic dispatch poll` — Check liveness via `kill(pid, 0)`, read state file, UPDATE
- `ic dispatch wait` — Poll loop, timeout handling
- `ic dispatch collect` — Read `.verdict` + `.summary` sidecars, UPDATE results

---

### 4.2 Intermute Multi-Agent Coordination Service

**Location:** `/root/projects/Interverse/services/intermute/`

**Type:** Go HTTP service (`:7338`)

**Architecture:**
```
internal/http/          HTTP handlers, middleware, routing
internal/storage/       SQLite database, queries
internal/storage/sqlite/ SQLite implementation, migrations
internal/ws/            WebSocket hub, connections
internal/domain/        Domain entities (specs/epics/stories/tasks)
internal/core/          Shared utilities
cmd/intermute/          CLI entry
client/                 Go client library
```

**Event-Sourced Storage:**
- Events append to `events` table
- Materialized to indexes (`inbox_index`, `thread_index`, `message_recipients`)
- Domain entities (specs/epics/stories/tasks) follow CRUD pattern

**Multi-tenant isolation:** Composite primary keys `(project, id)`

**Cursor-based pagination:** Not offset/limit

**Recent fix (2026-02-11):** Silent JSON marshal/unmarshal errors in storage layer. Switched to fail-hard on writes, log-and-continue on reads.

---

### 4.3 Merge Architecture (Autarch Hub)

**Files found:**
- `/root/projects/Interverse/hub/autarch/pkg/agenttargets/merge.go` — Merge logic
- `/root/projects/Interverse/hub/autarch/internal/coldwine/git/merge.go` — Git merge
- `/root/projects/Interverse/hub/autarch/internal/gurgeh/exploration/merge.go` — Exploration merge

**Related brainstorm:**
- `/root/projects/Interverse/docs/brainstorms/2026-02-15-multi-session-phase4-merge-agent-brainstorm.md`

These are part of the Autarch multi-agent TUI framework, not direct dispatch/merge in the kernel sense.

---

## 5. Sprint Kernel Handover Documentation

### 5.1 Sprint Handover PRD (2026-02-20)

**Location:** `/root/projects/Interverse/docs/prds/2026-02-20-sprint-handover-kernel-driven.md`

**Bead:** iv-kj6w

**Problem:** Sprint skill state is hybrid (~1276 lines, ~50% fallback). Every function has `ic`-primary and beads-fallback branches. Per-call `bd state ic_run_id` lookup adds latency and fragility.

**Solution:** Make sprint skill fully kernel-driven. `ic run` is only state backend. Beads remain user-facing identity (bead ID = human handle, run ID = cached internal). Hard-fail without `ic`. Remove ~600 lines of fallback.

**Features:**
- F1: `ic` guard and run ID cache (`sprint_require_ic()`, `_sprint_resolve_run_id()`)
- F2: Fallback removal — delete all beads fallback branches
- F3: Transition table removal — read phase chain from `ic run status`
- F4: Sprint skill cleanup — remove lib-gates.sh sourcing
- F5: Test updates — ic-only paths, no fallback tests

**Dependency:** Requires intercore binary available and functional. Beads still needed for bead creation and `ic_run_id` read.

---

## 6. Additional Kernel-Related Documents

### PDRs
- `/root/projects/Interverse/docs/prds/2026-02-20-bigend-kernel-migration.md` — Bigend TUI kernel migration
- `/root/projects/Interverse/infra/intercore/docs/prds/2026-02-19-intercore-e1-kernel-primitives.md` — E1 kernel primitives

### Plans
- `/root/projects/Interverse/docs/plans/2026-02-20-tui-kernel-validation.md` — TUI kernel validation
- `/root/projects/Interverse/docs/plans/2026-02-19-hierarchical-dispatch-meta-agent.md` — Hierarchical dispatch

### Research
- `/root/projects/Interverse/os/clavain/docs/research/kernel-contract-verification.md` — Kernel contract verification
- `/root/projects/Interverse/os/clavain/.claude/agents/fd-kernel-contract.md` — Flux-drive kernel contract

---

## 7. Memory Files (Project Knowledge)

**Location:** `/home/mk/.claude/projects/-root-projects-Interverse/memory/MEMORY.md` (user's auto-memory)

Key sections relevant to this search:
- **Intercore CLI Gotchas** — `ic run create` accepts `--phases=`, schema v10 portfolio runs, DB path default, skip vs advance
- **TOCTOU in check-then-insert** — Wrap in `BeginTx` transaction
- **Terminal status exhaustiveness** — Exempt `StatusCompleted`, `StatusCancelled`, `StatusFailed`
- **Monorepo Git structure** — Each subproject has own `.git`, all Clavain commits from `/root/projects/Interverse/os/clavain/`
- **Beads DB location** — `.beads/` at Interverse root

---

## 8. Integration Points

### Dispatch-Roadmap
- `/interpath:roadmap` generates `roadmap.json` artifacts
- These are artifacts tracked in runs via `ic run artifact add`
- Roadmap generation is phase-based (discovery → synthesis → output)

### TOCTOU-Portfolio
- TOCTOU race fixed in `DepStore.Add()` (cycle check + INSERT in transaction)
- Portfolio gates check `upstreams_at_phase` with all-terminal-states logic
- Advisory dispatch budget (acknowledged TOCTOU-vulnerable in docs)

### Event-Reactor-Dispatch
- Dispatch module emits events via `DispatchEventRecorder`
- Event reactors subscribe via `ic events tail -f --consumer=<name>`
- At-least-once delivery means reactors must be idempotent

### Sprint-Kernel
- Sprint skill transitioning to kernel-driven (E handover)
- Fallback paths being deleted in favor of `ic run` operations
- Phase chain read from `ic run status` instead of shell transition table

---

## 9. Conclusion

The Interverse codebase has:

1. **Mature roadmap infrastructure** — Plugin-driven artifact generation via interpath, all modules auto-generate roadmap.json
2. **TOCTOU analysis depth** — Two detailed patterns (advisory-only, transactional cycles), applied across interlock/intermute/intercore
3. **Comprehensive kernel docs** — AGENTS.md (547 lines), event-reactor pattern (265 lines), schema deployment (70 lines)
4. **Event-driven dispatch** — Kernel emits events, OS reactors consume and act (at-least-once delivery, idempotent)
5. **Portfolio coordination** — Cross-project dependencies, topological ordering, blocked-until gates, event relay

All kernel features documented via:
- AGENTS.md (definitive reference)
- Solution docs (patterns, gotchas, recovery)
- PRDs/Plans/Brainstorms (upcoming work)
- Integration tests (executable spec)

TOCTOU issues are explicitly known, analyzed, and patterns provided (advisory-only, transactional atomicity, idempotent operations).

