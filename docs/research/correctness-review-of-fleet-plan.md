# Correctness Review: C2 — Agent Fleet Registry Plan

**Plan reviewed:** `os/clavain/docs/plans/2026-02-22-c2-fleet-registry.md`
**Primary output:** `.claude/reviews/c2-fleet-registry-correctness.md`
**Reviewer:** Julik (fd-correctness)
**Date:** 2026-02-22
**Status:** NEEDS_ATTENTION — 8 findings, 3 HIGH, 4 MEDIUM, 1 LOW

---

## Invariants Established

These must remain true across all plan features:

1. **Merge invariant:** Curated fields (capabilities, models, cold_start_tokens, tags) must survive any number of scan-fleet.sh runs, even when agent source files are modified.
2. **Removal safety invariant:** An agent deleted from source must not produce a ghost entry that consumers dispatch to.
3. **New-agent invariant:** A newly discovered agent must produce a valid scaffold entry, not crash or skip.
4. **Sourcing idempotency invariant:** `_FLEET_LOADED` must guarantee the same behavior whether lib-fleet.sh is sourced once or many times in the same shell process.
5. **Consumer contract invariant:** All lib-fleet.sh public functions must return consistent output format regardless of registry state.
6. **Schema invariant:** A registry that passes JSON Schema validation must be safe to consume.

---

## Finding 1 — HIGH: Ghost agents are silently preserved and treated as live

**Area:** F2 scan-fleet.sh merge logic — removed agents

The plan specifies merge semantics for the case where an agent is discovered (overwrite generated fields, preserve curated fields). It does not specify what happens to existing registry entries for agents that are NOT discovered.

If an agent's .md file is deleted, renamed, or moved to a different plugin, scan-fleet.sh will fail to discover it. The existing registry entry survives untouched. C3 Composer and flux-drive triage will then attempt to dispatch to a `subagent_type` that no longer exists.

**Concrete failure sequence:**

1. scan-fleet.sh runs, finds `.claude/agents/fd-dispatch-efficiency.md`, writes entry to registry.
2. The agent file is later deleted or the agents directory is reorganized.
3. scan-fleet.sh runs again. The entry for `fd-dispatch-efficiency` remains in the registry.
4. C3 Composer reads the registry, selects `fd-dispatch-efficiency` for dispatch.
5. Claude Code's Task tool cannot locate the agent. Dispatch silently fails or throws.

The registry is described as a "static catalog" (non-goal: no agent health checks). That makes stale-entry detection even more important — there is no runtime safety net.

**Required fix:** Implement one of: tombstone mode (add `orphaned_at` field, matching the pattern in `docs/solutions/patterns/critical-patterns.md`), prune mode (remove undiscovered entries), or warn-and-preserve (log all entries not seen in current scan to stderr). The default must not be silent preservation. Document the chosen behavior.

---

## Finding 2 — HIGH: Frontmatter extraction is fragile under three real-world conditions

**Area:** F2 scan-fleet.sh — `sed -n '/^---$/,/^---$/p'` pipeline

**A) Files with no frontmatter produce an empty yq input.** The plan acknowledges this as a test case ("handles missing frontmatter gracefully") but does not specify the handling. A missing frontmatter produces an empty `name` field. An empty name used as a YAML map key corrupts the registry silently.

**B) flux-gen-generated files use non-standard frontmatter fields.** Agent files in `.claude/agents/` generated by flux-gen use `generated_by`, `domain`, `generated_at` instead of `name`/`description`. The plan's F1 schema specifies `name` and `description` as the fields to extract. flux-gen files may not have `name` in frontmatter at all (the `# fd-cli-ux` heading is in the body, not frontmatter). This means scan-fleet.sh would extract an empty name for generated agents and either skip them (correct) or insert a corrupt entry (wrong). The plan does not specify the fallback source for `name` when frontmatter lacks it (derive from filename? from body heading?).

**C) yq parse failures are not handled.** If frontmatter contains tab indentation or other YAML-invalid content, yq exits non-zero. The shell pipeline `sed ... | yq ...` will exit with yq's status code. Without per-call error handling, a single malformed agent file will abort the entire scan.

**Required fix:** Derive name from filename as a fallback when frontmatter lacks it (strip `.md` extension, use basename). Wrap yq in `2>/dev/null || { echo "Warning: $file"; continue; }`. Validate that extracted name is non-empty before constructing the registry entry.

---

## Finding 3 — HIGH: `_FLEET_LOADED` guard breaks when registry path changes between sources

**Area:** F3 lib-fleet.sh — source guard pattern

The `[[ -n "${_FLEET_LOADED:-}" ]] && return 0` guard, copied from lib-routing.sh, prevents re-initialization when the same registry path is used. It breaks when `CLAVAIN_FLEET_CONFIG` differs between sourcing calls in the same shell process:

```bash
export CLAVAIN_FLEET_CONFIG=/tmp/test-registry.yaml
source lib-fleet.sh    # Resolves to test-registry.yaml, sets _FLEET_LOADED=1

# Later, in the same process:
export CLAVAIN_FLEET_CONFIG=/real/fleet-registry.yaml
source lib-fleet.sh    # Guard fires immediately — wrong registry is still cached
```

More immediately: the F4 bats test suite runs all tests in a single shell process. Without `unset _FLEET_LOADED` in setup(), the first test's source contaminates all subsequent tests. The F4 test plan does not mention this. The routing tests handle this correctly (test_routing.bats line 14: `unset _ROUTING_LOADED`).

**Required fix:** Store the resolved path in `_FLEET_REGISTRY_PATH`. On each source call, compare the current resolution against `_FLEET_REGISTRY_PATH`; invalidate and reinitialize if they differ. F4 tests must `unset _FLEET_LOADED` (and the path variable) in setup().

---

## Finding 4 — MEDIUM: yq invocations are prone to injection and type mismatch

**Area:** F3 lib-fleet.sh — all query functions

Three specific failure modes:

**A) Variable interpolation in yq expressions.** `fleet_by_capability <capability>` will compose a yq expression like `select(.value.capabilities[] == "$cap")`. If `$cap` contains special characters, the expression is malformed or matches more than intended. Use yq's `env()` function or `--arg` to pass values safely.

**B) Numeric comparison without type casting.** `fleet_within_budget <max_tokens>` requires a numeric comparison (`cold_start_tokens <= max_tokens`). yq compares as strings by default. String comparison "800" <= "500" is `true` (lexicographic). Explicit cast is required: `select((.value.cold_start_tokens | tonumber) <= ($max | tonumber))`.

**C) Missing file not distinguished from empty result.** If `_FLEET_REGISTRY_PATH` is absent, yq exits non-zero but the function may swallow this and return empty output — indistinguishable from "no matching agents." Consumers cannot distinguish "no agents found" from "registry not found."

**Required fix:** Use `--arg cap "$cap"` for string parameters. Cast numeric fields explicitly. Check `_FLEET_REGISTRY_PATH` before every yq call; emit a clear error and return non-zero if absent.

---

## Finding 5 — MEDIUM: Agent rename produces both an orphan and a scaffold, losing curated data

**Area:** F2 scan-fleet.sh — rename handling

Curated fields are preserved by registry key (agent ID). If an agent is renamed (fd-old.md → fd-new.md), scan-fleet.sh will: (1) create a new scaffold for `fd-new` with empty curated fields, (2) leave `fd-old` as a stale entry (or delete it, depending on stale-entry policy). Either way, the curated capabilities authored for `fd-old` are silently discarded — there is no mechanism to detect or warn about the rename.

This is expected behavior for a key-based merge system and is not a code bug, but it must be explicitly documented and the `--dry-run` output must surface it. A `--dry-run` that shows three columns (added, updated, orphaned) makes the rename pattern immediately recognizable without special logic.

**Required fix:** Document the limitation. Make `--dry-run` output categorized: adds, updates, orphans (separate lists).

---

## Finding 6 — MEDIUM: JSON Schema validation toolchain is underspecified, with a YAML→JSON numeric round-trip risk

**Area:** F1 schema validation

The plan offers "yq + ajv or python jsonschema" as alternatives. ajv is not in the dependency list. The two paths have different behaviors for YAML numeric types: yq may emit `cold_start_tokens` as JSON string `"800"` rather than integer `800`, depending on the output mode and whether the YAML value is quoted. A JSON Schema with `"type": "integer"` for `cold_start_tokens` will then fail spuriously.

The existing agency-spec.schema.json uses draft-07 and python jsonschema (inferred from project tooling). Fleet schema should match.

**Required fix:** Specify `python3 -m jsonschema` (via `uv run`) as the single validation path, matching existing tooling. Set `"$schema": "http://json-schema.org/draft-07/schema#"`. Add a bats test that performs the full round-trip: `yq -o=json fleet-registry.yaml | python3 -m jsonschema ...` and verify `cold_start_tokens` validates as an integer.

---

## Finding 7 — MEDIUM: `fleet_check_coverage` return code semantics are undefined under partial coverage

**Area:** F3 lib-fleet.sh — fleet_check_coverage

The plan specifies "returns 0 when covered, 1 when missing" but does not define behavior for partial coverage: `fleet_check_coverage cap_a cap_b` where `cap_a` is covered and `cap_b` is not. AND semantics (all must be covered) are the correct default for dispatch validation, but if the implementation uses OR semantics, C3 may dispatch stages lacking required capabilities.

The F4 test plan only tests the binary case. A partial-coverage test case is absent.

**Required fix:** Define AND semantics in the function comment. Add test: two capabilities, one covered and one not, must return 1 and print the uncovered capability name.

---

## Finding 8 — LOW: `_FLEET_LOADED` is not exported; subshell invocations reinitialize unexpectedly

**Area:** F3 lib-fleet.sh — subshell sourcing model

`declare -g` variables are not exported to subshells. If flux-drive triage invokes lib-fleet.sh in a subshell (`bash -c "source lib-fleet.sh; fleet_by_category review"`), `_FLEET_LOADED` is not inherited even if the parent set it. The guard does not fire; the library reinitializes from the registry file. This is actually correct behavior, but the plan does not document the sourcing model, and callers may incorrectly assume that setting `_FLEET_LOADED=1` in the parent prevents subshell initialization.

**Required fix:** Export `_FLEET_LOADED`. Add a subshell invocation test using `run bash -c "source lib-fleet.sh; fleet_list"` (same pattern as the routing shadow-mode tests in test_routing.bats lines 539-548). Document that each subshell source re-initializes from the registry file.

---

## Test Coverage Gaps Not Covered by the 8 Findings

- **Stale-entry / ghost-agent test for scan-fleet.sh:** No test verifies that a registry entry for a deleted agent is tombstoned, pruned, or flagged. This is the most important merge correctness property.
- **yq not installed test:** The plan says scripts must fail clearly when yq is absent. No test verifies this behavior.
- **Atomic write test for `--in-place`:** If the sprint pipeline reads fleet-registry.yaml while scan-fleet.sh is writing it, the reader sees a partial file. scan-fleet.sh must write to a temp file and `mv` atomically. No test verifies this.
- **FLEET_FORMAT=json test:** The plan specifies JSON output mode. No planned test exercises it. C3 Composer will likely consume JSON output.
- **Empty registry test:** `fleet_list` on `agents: {}` must return exit 0 with empty output. Not planned.
- **Agent ID with special characters:** IDs containing dots or other yq-significant characters need quoted map key access. Not planned.

---

## Patterns from lib-routing.sh to Replicate

lib-routing.sh established correct patterns for this exact problem domain. Do not diverge:

- Config path resolution order: env var (`CLAVAIN_FLEET_CONFIG`) → script-relative → `CLAVAIN_SOURCE_DIR` → plugin cache
- Guard variable at bottom of file: `_FLEET_LOADED=1` (not `export _FLEET_LOADED` — but this review recommends changing to export)
- Separate cache-populated flag: `_FLEET_CACHE_POPULATED`
- Malformed-config warning to stderr (see lib-routing.sh lines 313–315)
- Test helper `_source_fleet()` with `unset _FLEET_LOADED` + `export CLAVAIN_FLEET_CONFIG=...` in every test
- Tests use `run bash -c "..."` for subshell behavior verification

The bats tests at `os/clavain/tests/shell/test_routing.bats` are the correct template for F4.

---

## Summary Table

| # | Severity | Area | One-line fix |
|---|----------|------|--------------|
| 1 | HIGH | F2 merge: stale entries | Tombstone or prune undiscovered entries; no silent ghost agents |
| 2 | HIGH | F2 frontmatter extraction | Fallback name from filename; per-call yq error handling; skip empty names |
| 3 | HIGH | F3 `_FLEET_LOADED` guard | Compare cached path vs current resolution; unset in test setup() |
| 4 | MEDIUM | F3 yq invocations | Use `--arg` for strings; `tonumber` for numeric comparisons; fail on absent registry |
| 5 | MEDIUM | F2 rename handling | Document limitation; `--dry-run` shows adds/updates/orphans separately |
| 6 | MEDIUM | F1 schema validation | Single path (python jsonschema); test cold_start_tokens numeric round-trip |
| 7 | MEDIUM | F3 fleet_check_coverage | Define AND semantics; add partial-coverage test |
| 8 | LOW | F3 subshell sourcing | Export `_FLEET_LOADED`; add subshell invocation test |
