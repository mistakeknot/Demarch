# Correctness Review: generate-agents.py (flux-gen v4 refactor)

Reviewer: Julik (fd-correctness)
Date: 2026-02-22
Diff: /tmp/qg-diff-1771785677.txt
Files reviewed: scripts/generate-agents.py (new), scripts/detect-domains.py (modified),
tests/structural/test_generate_agents.py (new), commands/flux-gen.md (modified),
skills/flux-drive/SKILL.md (modified), skills/flux-drive/SKILL-compact.md (modified)

---

## Invariants That Must Hold

1. Agent files are never partially written (atomicity invariant).
2. Existing user-customized agent files are not silently overwritten unless the caller
   explicitly chose force or regenerate-stale mode AND version check passes.
3. A dry-run execution must leave the filesystem identical to its pre-run state.
4. YAML frontmatter parse errors in existing agent files degrade gracefully (skip, not crash).
5. The JSON report returned from generate() is consistent with what was actually written
   to disk (no phantom "generated" entries that were never written).
6. An orphaned agent is reported but never deleted.
7. Atomic write: if the process dies mid-write the target file is not corrupted or truncated.
8. PLUGIN_ROOT is computed at import time from __file__; test monkeypatching of DOMAINS_DIR
   is the only safe override path.

---

## Finding Detail

### F1 — MEDIUM: `_parse_frontmatter` finds `---` inside YAML body, not closing fence

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, line 350

```python
end = text.find("---", 3)
```

`str.find` scans forward from byte-offset 3, which is the character immediately after the
opening `---`. It will match the FIRST occurrence of the three-character sequence `---`
anywhere in the file, including inside the YAML body (e.g. a value that contains `---`
or a markdown horizontal rule in the body after the frontmatter).

Correct frontmatter parsing requires the closing `---` to be at the start of a line,
not anywhere in the string. The standard pattern is to search for `\n---\n` (or the
lookahead `(?m)^---$`) starting after position 3.

Concrete failure: a domain profile file whose YAML `persona` or `focus` field contains
the substring `---` (a long em-dash sequence, or a YAML triple-dash used as a section
separator comment) will cause `yaml.safe_load` to receive a truncated YAML block and
likely return None or a partial dict. The result is `_parse_frontmatter` returning None
and the agent being treated as "not generated by flux-gen", which in skip-existing mode
means it will be unconditionally overwritten — violating invariant 2.

Fix: replace `text.find("---", 3)` with a line-anchored search:
```python
m = re.search(r"(?m)^---$", text[3:])
end = m.start() + 3 if m else -1
```

---

### F2 — MEDIUM: `_atomic_write` double-close on `os.write` failure corrupts fd state

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, lines 369-384

```python
fd, tmp_path = tempfile.mkstemp(dir=str(path.parent), suffix=".tmp")
try:
    os.write(fd, data)
    os.fsync(fd)
    os.close(fd)           # (A) normal close
    os.rename(tmp_path, str(path))
except Exception:
    try:
        os.close(fd)       # (B) emergency close — also runs if (A) succeeded
    except OSError:
        pass
    try:
        os.unlink(tmp_path)
    except OSError:
        pass
    raise
```

If `os.rename` raises (e.g. EXDEV — cross-device rename, or permission error on
`path.parent`), the `except Exception` block runs. At that point `fd` was already closed
at line (A). The emergency `os.close(fd)` at line (B) attempts to close an already-closed
file descriptor. On Linux this is benign (EBADF, caught by the inner OSError guard).
However, if the process has opened another file between (A) and the rename failure, that
new file may have been assigned the same fd number, and the spurious close silently closes
it. This is a classic fd recycling hazard.

The standard fix is to close the fd before attempting the rename, and set a sentinel so
the except block knows whether to close:

```python
fd, tmp_path = tempfile.mkstemp(dir=str(path.parent), suffix=".tmp")
fd_closed = False
try:
    os.write(fd, data)
    os.fsync(fd)
    os.close(fd)
    fd_closed = True
    os.rename(tmp_path, str(path))
except Exception:
    if not fd_closed:
        try:
            os.close(fd)
        except OSError:
            pass
    try:
        os.unlink(tmp_path)
    except OSError:
        pass
    raise
```

In practice, os.rename rarely fails after fsync on a same-filesystem POSIX path, so the
probability of triggering this in production is low — but the latent hazard is real.

---

### F3 — LOW-MEDIUM: `Key review areas` regex does not handle multi-line bullet items

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, lines 138-147

```python
review_match = re.search(
    r"^Key review areas:\s*\n((?:- .+\n?)+)",
    content,
    re.MULTILINE,
)
```

The pattern `- .+\n?` matches exactly one line per bullet. A bullet that wraps to a
continuation line (indented with spaces, as Markdown allows) will be silently truncated:
only the first line is captured.

Examining the actual domain profiles in
`/home/mk/projects/Demarch/interverse/interflux/config/flux-drive/domains/` shows that
all existing bullets are single-line, so this is not currently broken. The risk is a
profile author writing a multi-line bullet without knowing it will be silently dropped,
producing an agent with incomplete review criteria. Since generation claims to be
deterministic ("same domain profile always produces the same agent file"), a silent data
drop here would be hard to notice.

Mitigation: add a comment in the profile format documentation that bullets must be
single-line, OR extend the regex to consume indented continuation lines:
```python
r"^Key review areas:\s*\n((?:- .+(?:\n  .+)*\n?)+)"
```

---

### F4 — LOW: `parse_agent_specs` walk loop discards the final odd block when agent count is even

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, lines 106-110

```python
i = 1
while i < len(agent_blocks) - 1:
    name = agent_blocks[i].strip()
    content = agent_blocks[i + 1]
    i += 2
```

`re.split` with a capturing group produces:
```
[preamble, name1, content1, name2, content2, ..., nameN, contentN]
```
Total length = 1 + 2*N elements.

The loop condition `i < len(agent_blocks) - 1` terminates when `i == len - 1`, i.e.
when `i` points to the last element. For N agents:
- len = 1 + 2N
- Final name is at index 2N-1, content at 2N
- Loop runs while i < 2N, so final iteration: i=2N-1, reads [2N-1] and [2N] — correct.

When the loop would set i=2N+1, condition 2N+1 < 2N is false, loop exits. This is
correct. No agent is dropped.

However, the condition silently ignores an unpaired trailing name if re.split produces
an odd-length result from a profile that has a `### fd-name` header with no body before
the end of the section. In that case the last block is a name with no content, and the
loop correctly stops without processing it — but also without warning. The caller gets
a silently truncated spec list.

Severity: low (malformed profile edge case, not a parsing regression in well-formed files).

---

### F5 — LOW: Frontmatter `---` prefix check uses `str.startswith` but does not verify it ends at a newline

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, line 347

```python
if not text.startswith("---"):
    return None
```

A file starting with `---x` (no newline after the dashes) passes the check but is not
valid YAML frontmatter. The yaml.safe_load will then parse whatever comes between the
opening `---x` and the first `---` it finds, likely producing garbage or None. This is
a secondary concern given F1 dominates the frontmatter parsing correctness story.

Fix: check for `text.startswith("---\n")`.

---

### F6 — LOW: `render_agent` timestamp is not deterministic despite the docstring claiming it is

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, lines 231, 252-256

```python
now_utc = dt.datetime.now(dt.timezone.utc).strftime("%Y-%m-%dT%H:%M:%S+00:00")
```

The generated agent file includes `generated_at: '<current time>'` in its YAML frontmatter.
This means two consecutive calls to `render_agent` with identical spec dicts produce
different strings. The SKILL.md and closing notes in the diff say:
> "Generation is deterministic — same domain profile always produces the same agent file"

This is false. The generated_at field makes every render call produce a unique output.
This matters for `--mode=regenerate-stale`: an agent regenerated today will have a
different generated_at than one regenerated a minute later, which is fine for display
purposes, but the comment in the code creates a false expectation that can mislead future
contributors who try to add idempotency checks (e.g., "skip if rendered content
matches existing file").

The timestamp is not used for any correctness-critical logic in this codebase, so the
only risk is documentation mismatch leading to misplaced confidence. Recommend removing
or qualifying the "deterministic" claim in the SKILL.md notes.

---

### F7 — LOW: JSON report `generated` list includes dry-run entries, exit code is 0 even when no_domains

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, lines 533-538

```python
if report["status"] == "no_domains":
    if args.json_output:
        print(json.dumps(report, indent=2))
    else:
        print("No domains detected...", file=sys.stderr)
    return 1
```

When `--json` is combined with `no_domains`, the JSON is printed to stdout then exit 1
is returned. The caller in SKILL.md says:
> "Exit 1: No domains in cache. Skip generation..."

This is consistent, so the contract is correct. However, the JSON body when no_domains
includes `"generated": []`, `"skipped": []`, etc., which is fine.

The subtle issue: when `--dry-run` is active AND there are domains, the `generated` list
is populated in the report even though no files were written. This is intentional and
documented, but the SKILL.md caller parses `generated` list to decide what to log as
"created". If a caller doesn't check `args.dry_run` context, it might log false
"Generated: fd-x" messages. Callers should key on the `action` field in the report (per
the SKILL.md JSON example), but the actual report format returned by `generate()` uses
flat lists (`generated`, `skipped`) not per-agent action objects. This is a schema
discrepancy between the documented JSON example and the actual output.

Documented format in SKILL.md:
```json
{"agents": [{"name": "fd-x", "domain": "...", "action": "created"}]}
```

Actual format from generate():
```json
{"status": "ok", "generated": ["fd-x"], "skipped": [...], "orphaned": [...], "errors": [...]}
```

This discrepancy means any code that tries to parse the documented `agents[].action`
format will fail. The tests use the flat-list format (correct), but the SKILL.md
documentation shows the wrong schema. This does not cause a runtime failure in the
current code path because SKILL.md is an LLM-executed skill, not code — but it will
cause the LLM to misinterpret the output and produce incorrect log messages.

---

### F8 — LOW: `_atomic_write` does not guard against `path.parent` being on a different
filesystem from the tempfile directory

**File:** `/home/mk/projects/Demarch/interverse/interflux/scripts/generate-agents.py`, line 369

```python
fd, tmp_path = tempfile.mkstemp(dir=str(path.parent), suffix=".tmp")
```

By passing `dir=str(path.parent)`, the temp file is created in the same directory as
the target, which guarantees same-filesystem and enables atomic rename. This is correct
and the right choice. Noting it explicitly because the `detect-domains.py` write_cache
uses the same pattern — both are correctly implemented.

No action required; this is a positive confirmation of correct practice.

---

## Improvements (non-blocking)

### I1: Add an explicit schema comment to generate() return value

The `generate()` docstring lists the return keys but the SKILL.md example shows a
different schema. A type alias or TypedDict for the report dict would catch this at
development time.

### I2: Test coverage for F1 (_parse_frontmatter with --- inside YAML value)

No test covers the case where existing agent frontmatter contains `---` as a substring
of a field value. Adding one would prevent F1 from regressing silently.

### I3: Test coverage for F3 (multi-line bullet truncation)

Add a profile fixture with a two-line bullet. Assert the second line is preserved (or
explicitly document that it is not supported).

### I4: Qualify the "deterministic" claim in SKILL.md and flux-gen.md

The claim is false due to the `generated_at` timestamp. Change to "content-deterministic
except for the generated_at timestamp field" or add a note that generated_at varies
per run.

### I5: `_short_title` em-dash handling

The regex `[,\.\-—]` includes both ASCII hyphen-minus (`\-`, which inside a character
class should be escaped or placed at an edge) and em-dash (`—`). The placement of `\-`
between `.` and `—` in the character class is valid Python regex but fragile. Consider
using `[-,\.—]` (hyphen-minus first) for clarity and explicit intent.

---

## Summary

The file I/O core (`_atomic_write`, `write_cache`) is structurally sound — tempfile +
same-directory rename is the correct POSIX atomicity pattern, and both files use it.
`os.fsync` before rename is present and correct.

The main correctness concern is in `_parse_frontmatter` (F1): `str.find("---", 3)` is
not line-anchored and will match `---` inside a YAML value, causing silent frontmatter
misparse. In skip-existing mode this can silently overwrite a user-customized agent file
that the generator fails to recognize as flux-gen-generated.

The double-close hazard in `_atomic_write` (F2) is a real fd recycling risk but extremely
unlikely to trigger in practice given the narrow window between close and rename.

The schema discrepancy between SKILL.md's documented JSON format and the actual generate()
return format (F7) is the highest-impact documentation correctness issue — LLM-executed
skills that parse the wrong schema will log incorrect results.

No race conditions or concurrency hazards are present (single-threaded script, no
background threads, no shared state between invocations).
