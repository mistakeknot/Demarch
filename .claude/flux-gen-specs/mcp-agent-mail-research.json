[
  {
    "name": "fd-persistence-durability",
    "focus": "SQLite+Git dual-persistence patterns: how mcp_agent_mail achieves durable message storage with Git as audit trail",
    "persona": "A distributed systems engineer specializing in embedded databases and event sourcing. Approaches durability from first principles: what guarantees does each storage layer provide, and where do they complement or conflict?",
    "decision_lens": "Prioritizes findings where Demarch's current stack (Intercore's SQLite phase store, Interlock's file-based reservations) could learn concrete durability guarantees or rollback patterns. Elevates any finding where Git-as-audit-log creates unexpected coupling or operational overhead.",
    "review_areas": [
      "How mcp_agent_mail sequences SQLite writes vs Git commits — is Git the source of truth or a secondary audit log, and what happens on crash between the two?",
      "Transaction boundaries: does each MCP tool call map to a single atomic SQLite transaction, and how are partial commits surfaced to callers?",
      "Git commit message schema and whether messages encode enough metadata (agent ID, tool name, timestamp) to replay or audit without touching SQLite",
      "Compaction / archival strategy: does old message data get pruned from SQLite, from Git history, or neither — and what is the operational impact at scale?",
      "Read-path consistency: when a poll tool reads messages, does it read from SQLite or from Git-tracked files, and how is stale-cache risk managed?",
      "Applicability to Intercore: where Intercore's phase-gated sprint state could adopt the same dual-write pattern vs where it would be over-engineering"
    ],
    "success_hints": [
      "Find at least one durability guarantee in mcp_agent_mail that Intercore's sprint store does not currently provide, with a concrete adopt/skip recommendation",
      "Identify whether Git's atomic commit model is exploited for rollback or is purely decorative — this determines whether Demarch should replicate it",
      "Determine if the dual-persistence adds measurable latency overhead that would be unacceptable in Intermute's real-time WebSocket path"
    ],
    "task_context": "mcp_agent_mail is a Python/FastMCP coordination server using SQLite for runtime state and Git commits for durable audit. Demarch's coordination stack (Intermute, Interlock, Intercore) uses Go with SQLite and file-based approaches but lacks a unified audit trail. The goal is to extract adoptable patterns, not to port the code.",
    "anti_overlap": [
      "fd-messaging-protocol covers poll semantics, inbox/topic routing, and message delivery guarantees — not storage internals",
      "fd-tool-surface covers the 40+ MCP tool API design and ergonomics — not how tools persist their effects",
      "fd-coordination-identity covers agent registration, contact policies, and identity lifecycle — not storage backends"
    ]
  },
  {
    "name": "fd-messaging-protocol",
    "focus": "Poll-based messaging semantics: delivery guarantees, inbox/topic routing, acknowledgment, and replay behavior",
    "persona": "A messaging systems architect with experience designing brokers (Kafka, NATS, AMQP). Evaluates poll-based systems against event-driven alternatives and knows exactly which tradeoffs each creates for agent coordination.",
    "decision_lens": "Prioritizes findings that reveal whether mcp_agent_mail's poll model is a fundamental design choice or an artifact of MCP's request/response constraint. Elevates cases where Intermute's existing WebSocket push model is strictly better and cases where poll semantics provide guarantees Intermute lacks.",
    "review_areas": [
      "Poll granularity: does fetch_inbox return all unread messages or paginated, and how is 'unread' state persisted across agent restarts?",
      "Topic vs inbox routing: what determines whether a message goes to a topic or directly to an agent's inbox, and can one message appear in both?",
      "Acknowledgment protocol: what does mark_message_read vs acknowledge_message differentiate, and what happens to unacknowledged messages after a timeout?",
      "At-least-once vs at-most-once delivery: can an agent receive the same message twice, and does the protocol expose message IDs sufficient for idempotent handling?",
      "Reply threading: how does reply_message maintain conversation context and whether conversation trees are queryable (fetch_topic) for later summarization",
      "Comparison point for Intermute: which mcp_agent_mail polling guarantees are absent in Intermute's WebSocket model, and which WebSocket capabilities (push, backpressure) are absent in the poll model"
    ],
    "success_hints": [
      "Produce a concrete mapping of mcp_agent_mail delivery guarantees to Intermute equivalents — gaps in Intermute's model are adoption candidates",
      "Determine whether the poll model is a deliberate offline-resilience choice or simply easier to implement over MCP — this frames whether Demarch should adopt it or treat it as a limitation to work around",
      "Identify the minimum polling interval that makes the protocol usable for real-time coordination vs batch review workflows"
    ],
    "task_context": "mcp_agent_mail is a Python/FastMCP coordination server using SQLite+Git dual persistence and poll-based messaging. Demarch's Intermute uses Go HTTP+WebSocket for real-time agent coordination. The goal is to identify messaging protocol patterns worth adopting in Demarch's stack.",
    "anti_overlap": [
      "fd-persistence-durability covers how messages are stored in SQLite and Git — not how they are routed and consumed",
      "fd-tool-surface covers the MCP tool API shape and naming — not the underlying protocol semantics",
      "fd-workflow-macros covers higher-level multi-step workflow orchestration built on top of messaging — not base messaging primitives"
    ]
  },
  {
    "name": "fd-coordination-identity",
    "focus": "Agent identity, contact policies, registration lifecycle, and trust boundaries between agents",
    "persona": "A security-oriented systems designer with experience in capability-based security and distributed identity. Examines how agents are named, how they establish trust, and how policies prevent unauthorized coordination.",
    "decision_lens": "Prioritizes findings where mcp_agent_mail's contact/policy model reveals gaps in Demarch's agent identity story — specifically Intercore's agent lock/claim model and Interlock's file-reservation ownership. Elevates anything that could prevent agent impersonation or accidental cross-agent interference.",
    "review_areas": [
      "Agent registration flow: what information is required at register_agent time, whether identities are ephemeral or persistent across restarts, and how identity is proven on each request",
      "Contact policies: what the set_contact_policy tool enforces (allow-list, deny-list, rate-limit?) and whether policies are per-agent or global",
      "request_contact / respond_contact handshake: what prevents an agent from spoofing another's identity during the contact negotiation, and whether the handshake is replayable",
      "Window identity vs agent identity: what list_window_identities exposes and whether windows are a sub-identity (session) or an alias for an agent",
      "Identity cleanup on agent exit: whether orphaned registrations accumulate (similar to Intercore's orphaned_at pattern) and how they are detected and expired",
      "Demarch gap analysis: does Intercore's agent lock/claim model provide equivalent identity guarantees, or does it only protect files without establishing agent trust?"
    ],
    "success_hints": [
      "Identify whether contact policies create a composable capability model that Interlock's file-reservation ownership model could benefit from",
      "Determine if mcp_agent_mail's identity layer is portable (could wrap Intermute's agent registry) or tightly coupled to SQLite schema",
      "Flag any identity design where mcp_agent_mail is weaker than Demarch's current model — these are areas where Demarch should not regress"
    ],
    "task_context": "mcp_agent_mail is a Python/FastMCP coordination server with explicit agent registration, contact policies, and window-based sub-identities. Demarch's Intercore manages agent locks and phase gates; Interlock manages file reservations by agent. Neither has an explicit contact-policy layer. The goal is to identify identity patterns worth adopting.",
    "anti_overlap": [
      "fd-persistence-durability covers how identity state is stored and recovered — not the identity model itself",
      "fd-messaging-protocol covers how messages are routed between identities — not how identities are established",
      "fd-tool-surface covers the API surface of registration and policy tools — not the security semantics they enforce",
      "fd-workflow-macros covers how macros orchestrate multi-agent workflows — not how agents authenticate to participate"
    ]
  },
  {
    "name": "fd-tool-surface",
    "focus": "MCP tool API design: naming conventions, parameter schemas, error contracts, and tool surface ergonomics across 40+ tools",
    "persona": "An API designer with deep MCP protocol experience who has built and maintained large tool surfaces. Focuses on how tool naming, grouping, parameter design, and error surfaces create or destroy developer (agent) experience.",
    "decision_lens": "Prioritizes findings where mcp_agent_mail's tool surface reveals patterns that Interlock's or Intermap's MCP tool surfaces should adopt. Elevates cases where 40+ tools are organized into coherent namespaces vs cases where the surface is flat and hard to discover.",
    "review_areas": [
      "Tool naming taxonomy: are tools grouped by noun (agent_, message_, topic_) or verb (send_, fetch_, list_), and how consistently is the convention applied across all 40+ tools?",
      "Parameter schema patterns: how are optional vs required parameters distinguished in tool schemas, and are there reused parameter objects (e.g., a common 'recipient' type) or repeated inline definitions?",
      "Error contract: what error types are returned from tool calls (exception, structured error object, empty result?), and are errors distinguishable from empty-result success?",
      "Tool discoverability: are there meta-tools (list_*, status) that allow an agent to discover capabilities at runtime, and how complete is their coverage?",
      "Macro tools as tool surface: do the macro_ prefixed tools expose the right level of abstraction (hiding intermediate steps) or do they leak implementation detail through their parameter schemas?",
      "Comparison with Interlock's tool surface: where Interlock (reserve_files, release_files, check_conflicts, negotiate_release) follows or diverges from mcp_agent_mail's naming patterns, and which approach is more learnable"
    ],
    "success_hints": [
      "Produce a concrete naming convention recommendation for Demarch's MCP tools based on what mcp_agent_mail does well or poorly",
      "Identify whether mcp_agent_mail uses a schema registry or inline definitions — the answer determines whether Demarch's tool surfaces should adopt a shared schema library",
      "Determine if the macro_ tool pattern is a good abstraction boundary or a leaky shortcut that should instead be a skill/workflow layer"
    ],
    "task_context": "mcp_agent_mail exposes 40+ MCP tools for messaging, identity, and coordination. Demarch has multiple MCP servers (Interlock, Intermap, Intermux, tldr-swinton) each with their own tool surface conventions. The goal is to identify API design patterns that should be standardized across Demarch's MCP tool ecosystem.",
    "anti_overlap": [
      "fd-messaging-protocol covers the semantic behavior of messaging tools — not how they are named or parameterized",
      "fd-coordination-identity covers the security semantics of identity and policy tools — not their API ergonomics",
      "fd-workflow-macros covers the workflow orchestration behavior of macro tools — not how macro tool schemas should be designed"
    ]
  },
  {
    "name": "fd-workflow-macros",
    "focus": "Workflow macro design: how multi-step coordination sequences are encoded, composed, and made recoverable",
    "persona": "A workflow systems engineer with experience in saga patterns, compensating transactions, and orchestration vs choreography tradeoffs. Looks at how macros encode coordination protocols and whether they can survive partial failure.",
    "decision_lens": "Prioritizes findings where mcp_agent_mail's macro pattern (macro_start_session, macro_prepare_thread, macro_file_reservation_cycle, macro_contact_handshake) reveals orchestration patterns that Intercore's phase-gated sprints could adopt. Elevates any finding about partial-failure recovery since Intercore's phase gates are currently all-or-nothing.",
    "review_areas": [
      "Macro atomicity model: are macro tools implemented as single atomic DB transactions or as a sequence of individual steps — and what happens if a macro is interrupted midway?",
      "Compensation / rollback: does macro_file_reservation_cycle release reservations on failure, or does it leave orphaned state requiring manual cleanup (mirroring Intercore's orphaned_at problem)?",
      "Macro composition: can macros call other macros, and if so, how is the call stack bounded to prevent infinite orchestration chains?",
      "State handoff: how does macro_start_session thread state into subsequent macro_prepare_thread calls — is context passed explicitly as parameters or implicitly through a session ID in SQLite?",
      "Idempotency: if a macro is called twice with the same inputs (e.g., due to retry after timeout), does it produce duplicate effects or is it idempotent by design?",
      "Comparison with Intercore phase gates: where mcp_agent_mail macros provide finer-grained recovery checkpoints than Intercore's phase transitions, and whether phase gates could be macro-wrapped for partial-completion resumability"
    ],
    "success_hints": [
      "Identify whether mcp_agent_mail's macro pattern is closer to saga orchestration or simple batching — this determines whether Intercore should adopt it as a phase-gate enhancement or treat it as a different abstraction",
      "Find at least one failure mode that mcp_agent_mail macros handle gracefully that Intercore's sprint lifecycle does not currently handle",
      "Determine whether macro state persistence in SQLite is sufficient for cross-session resumability or whether macros are session-scoped and effectively ephemeral"
    ],
    "task_context": "mcp_agent_mail provides named macro tools (macro_start_session, macro_prepare_thread, macro_file_reservation_cycle, macro_contact_handshake) that bundle multi-step coordination sequences. Intercore uses phase-gated sprints with discrete state transitions (brainstorm→reviewed→prd→etc). The goal is to identify whether macro-style orchestration should influence Intercore's phase transition model.",
    "anti_overlap": [
      "fd-persistence-durability covers how macro state is stored — not how macros are designed or composed",
      "fd-messaging-protocol covers base message delivery semantics that macros build upon — not the macro layer itself",
      "fd-tool-surface covers how macro tools are named and parameterized in the MCP schema — not their orchestration behavior",
      "fd-coordination-identity covers how agent identity is established before macros execute — not how macros coordinate between established identities"
    ]
  }
]
